# Utility functions for bash
# (ported from .zsh_utils)

# --- Expanded utility functions ported from .zsh_utils ---

# Find files matching a pattern and execute a command on them
findex() {
    if [[ "$1" == "-h" || "$1" == "--help" || $# -eq 0 ]]; then
        echo "Usage: findex [OPTIONS] [PATH] PATTERN COMMAND [--shift] [ARGS...]"
        echo ""
        echo "Required arguments:"
        echo "  PATTERN       File pattern to search for (e.g., '*.txt')"
        echo "  COMMAND       Command to execute on each matching file"
        echo ""
        echo "Optional arguments:"
        echo "  PATH          Directory path to search in (default: current directory)"
        echo "  -d DEPTH      Maximum directory depth to search (default: unlimited)"
        echo "  -t TYPE       File type: f (files), d (directories), l (symlinks)"
        echo "  --shift       Place all arguments after --shift to the right of the file placeholder"
        echo ""
        echo "Examples:"
        echo "  findex '*.txt' ls -l                         # List all text files in current dir"
        echo "  findex /home '*.pdf' ls -l                   # List all PDF files in /home"
        echo "  findex -d 2 '*.sh' chmod 755                 # Make shell scripts executable (max depth 2)"
        echo "  findex -t f /var/log '*.log' grep 'error'    # Search for 'error' in log files"
        echo "  findex '*.txt' sed -i 's/old/new/g'          # Replace text in all text files"
        echo "  findex /tmp '*.jpg' 'convert {} -resize 50% {}.resized'  # Resize all JPG files in /tmp"
        echo "  findex -d 2 ~/Documents '*.pdf' cp --shift /tmp/     # Copy PDFs to /tmp directory"
        return 0
    fi
    # Try finding files using find command
    local matching_files=$(find "$search_path" $max_depth $file_type -name "$pattern" 2>/dev/null)
    
    if [[ -z "$matching_files" ]]; then
        echo "No files found matching pattern: $pattern"
        echo "Trying with fallback methods..."
        
        # Try without quotes or with different patterns
        if find "$search_path" $max_depth $file_type -name "$pattern" 2>/dev/null | head -1 > /dev/null; then
            echo "Found files with original pattern"
            if [[ ${#post_shift_args[@]} -gt 0 ]]; then
                find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} "${post_shift_args[@]}" \; 2>/dev/null
            else
                find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} \; 2>/dev/null
            fi
            echo "Command execution completed."
        else
            echo "No files found with fallback methods either"
        fi
        return 0
    fi
    
    # Count the number of files
    local file_count=$(echo "$matching_files" | wc -l | tr -d ' ')
    echo "Found $file_count file(s) to process:"
    echo "$matching_files" | sed 's/^/  /'
    
    # Execute the command
    if [[ ${#post_shift_args[@]} -gt 0 ]]; then
        echo "Executing: $command ${pre_shift_args[*]} [FILES] ${post_shift_args[*]}"
        find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} "${post_shift_args[@]}" \; 2>/dev/null
    else
        echo "Executing: $command ${pre_shift_args[*]} [FILES]"
        find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} \; 2>/dev/null
    fi
    
    echo "Command execution completed on $file_count file(s)."
}

# Quick calculator function
calc() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: calc <expression>"
        echo "Quick calculator using bc"
        echo "Examples:"
        echo "  calc '2 + 3'"
        echo "  calc 'sqrt(16)'"
        echo "  calc '3.14 * 2^2'"
        return 0
    fi
    
    if [[ $# -eq 0 ]]; then
        echo "Error: No expression provided"
        return 1
    fi
    
    if command -v bc &> /dev/null; then
        echo "scale=4; $*" | bc -l
    else
        echo "Error: bc calculator not installed"
        echo "Install with: sudo apt install bc"
        return 1
    fi
}

# Extract various archive formats
extract() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: extract <archive_file>"
        echo "Extract various archive formats automatically"
        echo "Supported formats: zip, tar.gz, tar.bz2, tar.xz, rar, 7z, gz, bz2"
        return 0
    fi
    
    if [[ $# -eq 0 ]]; then
        echo "Error: No archive file specified"
        return 1
    fi
    
    for file in "$@"; do
        if [[ ! -f "$file" ]]; then
            echo "Error: File '$file' not found"
            continue
        fi
        
        echo "Extracting: $file"
        case "$file" in
            *.tar.bz2) tar -jxvf "$file" ;;
            *.tar.gz)  tar -zxvf "$file" ;;
            *.tar.xz)  tar -Jxvf "$file" ;;
            *.bz2)     bunzip2 "$file" ;;
            *.rar)     unrar x "$file" ;;
            *.gz)      gunzip "$file" ;;
            *.tar)     tar -xvf "$file" ;;
            *.tbz2)    tar -jxvf "$file" ;;
            *.tgz)     tar -zxvf "$file" ;;
            *.zip)     unzip "$file" ;;
            *.Z)       uncompress "$file" ;;
            *.7z)      7z x "$file" ;;
            *)         echo "Error: '$file' format not supported" ;;
        esac
    done
}

# Create archive
archive() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: archive [-t type] <output_name> <file/directory>..."
        echo "Create archives of various formats"
        echo "Options:"
        echo "  -t type    Archive type: zip, tar, tar.gz (default), tar.bz2, tar.xz, 7z"
        return 0
    fi
    
    local archive_type="tar.gz"
    local output_name=""
    local files=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t)
                archive_type="$2"
                shift 2
                ;;
            *)
                if [[ -z "$output_name" ]]; then
                    output_name="$1"
                else
                    files+=("$1")
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$output_name" || ${#files[@]} -eq 0 ]]; then
        echo "Error: Output name and files required"
        return 1
    fi
    
    echo "Creating $archive_type archive: $output_name"
    case "$archive_type" in
        zip)     zip -r "$output_name.zip" "${files[@]}" ;;
        tar)     tar -cvf "$output_name.tar" "${files[@]}" ;;
        tar.gz)  tar -czvf "$output_name.tar.gz" "${files[@]}" ;;
        tar.bz2) tar -cjvf "$output_name.tar.bz2" "${files[@]}" ;;
        tar.xz)  tar -cJvf "$output_name.tar.xz" "${files[@]}" ;;
        7z)      7z a "$output_name.7z" "${files[@]}" ;;
        *)       echo "Error: Unsupported archive type: $archive_type" ;;
    esac
}

# Find large files
find_large_files() {
    local size="${1:-100M}"
    local path="${2:-.}"
    
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: find_large_files [size] [path]"
        echo "Find files larger than specified size"
        echo "Default size: 100M, default path: current directory"
        echo "Size examples: 50M, 1G, 500K"
        return 0
    fi
    
    echo "Finding files larger than $size in $path..."
    find "$path" -type f -size +$size -exec ls -lh {} \; 2>/dev/null | awk '{ print $9 ": " $5 }'
}

# Process management helpers
psg() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: psg <process_name>"
        echo "Search for processes by name"
        return 0
    fi
    
    if [[ -z "$1" ]]; then
        echo "Error: Process name required"
        return 1
    fi
    
    ps aux | grep -i "$1" | grep -v grep
}

# Kill processes by name
killall_by_name() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: killall_by_name <process_name>"
        echo "Kill all processes matching the given name"
        return 0
    fi
    
    if [[ -z "$1" ]]; then
        echo "Error: Process name required"
        return 1
    fi
    
    local pids=$(pgrep -f "$1")
    if [[ -n "$pids" ]]; then
        echo "Killing processes matching '$1':"
        echo "$pids" | xargs ps -fp
        echo "$pids" | xargs kill
    else
        echo "No processes found matching '$1'"
    fi
}

# System information
sysinfo() {
    echo "=== System Information ==="
    echo "Hostname: $(hostname)"
    echo "Uptime: $(uptime -p 2>/dev/null || uptime)"
    echo "Kernel: $(uname -r)"
    echo "Distribution: $(lsb_release -d 2>/dev/null | cut -f2 || cat /etc/os-release | grep PRETTY_NAME | cut -d'"' -f2)"
    echo "CPU: $(lscpu | grep 'Model name' | cut -d':' -f2 | xargs)"
    echo "Memory: $(free -h | grep '^Mem:' | awk '{print $2 " total, " $3 " used, " $7 " available"}')"
    echo "Disk Usage:"
    df -h | grep -E '^/dev/' | awk '{print "  " $1 ": " $3 "/" $2 " (" $5 ")"}'
}

# Network utilities
myip() {
    echo "Local IP: $(hostname -I | awk '{print $1}')"
    echo "Public IP: $(curl -s https://ipinfo.io/ip || echo "Unable to determine")"
}

# Quick note taking
note() {
    local note_file="$HOME/.notes.txt"
    
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: note [text]"
        echo "Quick note taking utility"
        echo "If no text provided, opens notes file in editor"
        return 0
    fi
    
    if [[ $# -eq 0 ]]; then
        ${EDITOR:-nano} "$note_file"
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S'): $*" >> "$note_file"
        echo "Note added to $note_file"
    fi
}

# Show notes
notes() {
    local note_file="$HOME/.notes.txt"
    if [[ -f "$note_file" ]]; then
        cat "$note_file"
    else
        echo "No notes found. Use 'note <text>' to create your first note."
    fi
}

# Generate a random UUID
uuidgen_util() {
    if command -v uuidgen &> /dev/null; then
        uuidgen
    else
        cat /proc/sys/kernel/random/uuid
    fi
}

# Show disk usage for a directory
show_disk_usage() {
    du -sh "$1"
}

# Convert markdown and office files to PDF (requires pandoc & libreoffice)
convert_to_pdf() {
    if [ $# -eq 0 ]; then
        echo "Usage: convert_to_pdf <file1> [file2 ...]"
        return 1
    fi
    for file in "$@"; do
        if [[ "$file" =~ \.(md|markdown)$ ]]; then
            if ! command -v pandoc &> /dev/null; then
                echo "pandoc not installed. Skipping $file."
                continue
            fi
            pandoc "$file" -o "${file%.*}.pdf"
        elif [[ "$file" =~ \.(docx?|xlsx?|pptx?|odt|ods|odp)$ ]]; then
            if ! command -v soffice &> /dev/null; then
                echo "LibreOffice (soffice) not installed. Skipping $file."
                continue
            fi
            soffice --headless --convert-to pdf "$file"
        else
            echo "Unsupported file type: $file"
        fi
    done
}

alias mdpdf="convert_to_pdf"

# Python server helper (previously in .bashrc)
pyserver() {
  local local_ip=$(hostname -I | awk '{print $1}')
  if [ -n "$1" ]; then
    mkdir -p /tmp/pyserver
    for file in "$@"; do
      ln -s "$file" /tmp/pyserver
    done
    cd /tmp/pyserver
  fi
  echo "Serving files at http://$local_ip:8000"
  python3 -m http.server 8000
}

# --- End expanded ---
