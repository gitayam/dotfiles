# File handling helpers for bash - comprehensive image and file processing
# (ported from .zsh_handle_files)

# Safely move a file to trash (if trash-cli is available)
safe_rm() {
    if command -v trash &> /dev/null; then
        trash "$@"
    else
        rm -i "$@"
    fi
}

# Process a single image: sanitize EXIF, convert, rotate, OCR, etc.
process_single_image() {
    local file="$1"
    local rotate_degrees="${2:-0}"
    local convert_format="${3:-}"
    local sanitize="${4:-true}"
    local keep_original="${5:-false}"
    local random_name="${6:-false}"
    local apply_ocr="${7:-false}"
    
    if [[ ! -e "$file" ]]; then
        echo "‚ùå File does not exist: $file"
        return 1
    fi
    
    if [[ ! -r "$file" ]]; then
        echo "‚ùå File is not readable: $file"
        return 1
    fi
    
    # Check if it's an image or PDF file
    if [[ "$file" =~ \.(jpg|jpeg|png|tiff|gif|bmp|ico|webp)$ ]]; then
        echo "üîç Processing image file: $file"
    elif [[ "$file" =~ \.pdf$ ]]; then
        echo "üîç Processing PDF file: $file"
        convert_format="${convert_format:-png}"
    else
        echo "‚ùå Error: File is not a supported image format: $file"
        return 1
    fi
    
    # Generate output filename
    local dirname="$(dirname "$file")"
    local basename="$(basename "$file")"
    local extension="${basename##*.}"
    local filename="${basename%.*}"
    local output_file=""
    
    # Generate a random name if requested
    if [[ "$random_name" == true ]]; then
        local random_str=$(cat /dev/urandom | LC_ALL=C tr -dc 'a-zA-Z0-9' | fold -w 8 | head -n 1)
        filename="${random_str}"
    fi
    
    # Use different format if converting
    if [[ -n "$convert_format" ]]; then
        extension="$convert_format"
    fi
    
    # Build output filename
    output_file="${dirname}/${filename}.${extension}"
    
    # Don't overwrite input file with same name
    if [[ "$output_file" == "$file" && "$keep_original" == true ]]; then
        output_file="${dirname}/${filename}_processed.${extension}"
    fi
    
    # Create a temporary directory for processing
    local temp_dir=$(mktemp -d)
    trap 'rm -rf "$temp_dir"' EXIT
    
    # Temporary file for processing
    local temp_output="${temp_dir}/processed.${extension}"
    
    # Make a copy of the original file to work with
    cp "$file" "$temp_output"
    
    # Sanitize EXIF data if requested
    if [[ "$sanitize" == true ]]; then
        if command -v exiftool &> /dev/null; then
            echo "üßπ Sanitizing EXIF data..."
            exiftool -overwrite_original -all= -Orientation "$temp_output" &>/dev/null
        else
            echo "‚ö†Ô∏è  exiftool not available, skipping EXIF sanitization"
        fi
    fi
    
    # Rotate image if requested
    if [[ "$rotate_degrees" -ne 0 ]]; then
        if command -v convert &> /dev/null; then
            echo "üîÑ Rotating image by ${rotate_degrees} degrees..."
            convert "$temp_output" -rotate "$rotate_degrees" "$temp_output"
        else
            echo "‚ö†Ô∏è  ImageMagick not available, skipping rotation"
        fi
    fi
    
    # Convert image if requested
    if [[ -n "$convert_format" ]]; then
        if command -v convert &> /dev/null; then
            echo "üîÑ Converting image to format: ${extension}..."
            if [[ "$file" =~ \.pdf$ ]]; then
                convert -density 300 "$temp_output" "${temp_dir}/converted.${extension}"
            else
                convert "$temp_output" "${temp_dir}/converted.${extension}"
            fi
            mv "${temp_dir}/converted.${extension}" "$temp_output"
        else
            echo "‚ö†Ô∏è  ImageMagick not available, skipping conversion"
        fi
    fi
    
    # Apply OCR if requested
    if [[ "$apply_ocr" == true ]]; then
        if command -v tesseract &> /dev/null; then
            echo "üîç Applying OCR..."
            tesseract "$temp_output" "${temp_dir}/ocr_text" &>/dev/null
            echo "üìù OCR text saved to: ${dirname}/${filename}_ocr.txt"
            cp "${temp_dir}/ocr_text.txt" "${dirname}/${filename}_ocr.txt"
        else
            echo "‚ö†Ô∏è  Tesseract not available, skipping OCR"
        fi
    fi
    
    # Copy processed file to output location
    cp "$temp_output" "$output_file"
    
    # Handle original file
    if [[ "$keep_original" == true ]]; then
        echo "üíæ Original file kept: $file"
    else
        if [[ "$file" != "$output_file" ]]; then
            echo "üóëÔ∏è Removing original file: $file"
            rm "$file"
        fi
    fi
    
    echo "‚úÖ Processed: $file -> $output_file"
    return 0
}

# Comprehensive image handler
handle_image() {
    if [[ $# -eq 0 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "üì∑ Image Handler for Linux"
        echo "Usage: handle_image [options] file.jpg|directory [file2.jpg|directory2 ...]"
        echo ""
        echo "Options:"
        echo "  -c, --convert [format]    Convert image to different format (jpg, png, etc.)"
        echo "  -r, --rotate [90|180|270] Rotate image by specified degrees"
        echo "  -s, --sanitize            Sanitize EXIF data (default: true)"
        echo "  -o, --ocr                 Apply OCR to extract text"
        echo "  -n, --name                Rename image with sanitized name"
        echo "  -R, --recursive           Process images in directories recursively"
        echo "  --random                  Generate random name for processed files"
        echo "  -k, --keep                Keep original files"
        echo "  -h, --help                Show this help message"
        echo ""
        echo "Required tools: ImageMagick (convert), exiftool, tesseract (for OCR)"
        echo "Install on Ubuntu/Debian: sudo apt install imagemagick exiftool tesseract-ocr"
        echo "Install on Fedora: sudo dnf install ImageMagick perl-Image-ExifTool tesseract"
        echo "Install on Arch: sudo pacman -S imagemagick perl-image-exiftool tesseract"
        return 0
    fi

    # Check if required tools are installed
    local missing_tools=()
    if ! command -v convert &> /dev/null; then
        missing_tools+=("imagemagick")
    fi
    if ! command -v exiftool &> /dev/null; then
        missing_tools+=("exiftool")
    fi
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        echo "‚ö†Ô∏è  Missing tools: ${missing_tools[*]}"
        echo "Install with your package manager:"
        echo "  Ubuntu/Debian: sudo apt install imagemagick exiftool tesseract-ocr"
        echo "  Fedora: sudo dnf install ImageMagick perl-Image-ExifTool tesseract"
        echo "  Arch: sudo pacman -S imagemagick perl-image-exiftool tesseract"
    fi

    # Parse options
    local convert_format=""
    local rotate_degrees="0"
    local sanitize=true
    local apply_ocr=false
    local recursive=false
    local random_name=false
    local keep_original=false
    local clean_name=false
    local files=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--convert)
                convert_format="${2:-jpg}"
                shift 2
                ;;
            -r|--rotate)
                rotate_degrees="${2:-90}"
                shift 2
                ;;
            -s|--sanitize)
                sanitize=true
                shift
                ;;
            -o|--ocr)
                apply_ocr=true
                shift
                ;;
            -n|--name)
                clean_name=true
                shift
                ;;
            -R|--recursive)
                recursive=true
                shift
                ;;
            --random)
                random_name=true
                shift
                ;;
            -k|--keep)
                keep_original=true
                shift
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#files[@]} -eq 0 ]]; then
        echo "‚ùå Error: No files or directories specified"
        return 1
    fi

    # Process each file or directory
    for item in "${files[@]}"; do
        if [[ -f "$item" ]]; then
            # Single file
            process_single_image "$item" "$rotate_degrees" "$convert_format" "$sanitize" "$keep_original" "$random_name" "$apply_ocr"
        elif [[ -d "$item" ]]; then
            # Directory
            echo "üìÅ Processing directory: $item"
            local find_opts=(-type f)
            if [[ "$recursive" == false ]]; then
                find_opts+=(-maxdepth 1)
            fi
            
            find "$item" "${find_opts[@]}" \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.tiff" -o -iname "*.gif" -o -iname "*.bmp" -o -iname "*.webp" -o -iname "*.pdf" \) | while read -r file; do
                process_single_image "$file" "$rotate_degrees" "$convert_format" "$sanitize" "$keep_original" "$random_name" "$apply_ocr"
            done
        else
            echo "‚ùå Error: '$item' does not exist"
        fi
    done
}

# Batch rename files with a pattern
batch_rename() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: batch_rename <pattern> <replacement> [directory]"
        echo "Batch rename files matching a pattern"
        echo "Example: batch_rename 'IMG_' 'Photo_' ~/Pictures"
        return 0
    fi
    
    if [[ $# -lt 2 ]]; then
        echo "Usage: batch_rename <pattern> <replacement> [directory]"
        return 1
    fi
    
    local pattern="$1"
    local replacement="$2"
    local directory="${3:-.}"
    
    if [[ ! -d "$directory" ]]; then
        echo "Error: Directory '$directory' does not exist"
        return 1
    fi
    
    local count=0
    find "$directory" -maxdepth 1 -name "*${pattern}*" -type f | while read -r file; do
        local newname="${file//$pattern/$replacement}"
        if [[ "$file" != "$newname" ]]; then
            mv "$file" "$newname"
            echo "Renamed: $(basename "$file") -> $(basename "$newname")"
            ((count++))
        fi
    done
    
    echo "Renamed $count files"
}

# PDF utilities
pdf_merge() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pdf_merge output.pdf input1.pdf input2.pdf ..."
        echo "Merge multiple PDF files into one"
        return 0
    fi
    
    if [[ $# -lt 3 ]]; then
        echo "Error: At least output file and two input files required"
        return 1
    fi
    
    local output="$1"
    shift
    
    if command -v pdftk &> /dev/null; then
        pdftk "$@" cat output "$output"
    elif command -v gs &> /dev/null; then
        gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile="$output" "$@"
    else
        echo "Error: Neither pdftk nor ghostscript (gs) is installed"
        echo "Install with: sudo apt install pdftk-java ghostscript"
        return 1
    fi
    
    echo "‚úÖ Merged PDFs into: $output"
}

# Extract images from PDF
pdf_extract_images() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pdf_extract_images input.pdf [output_prefix]"
        echo "Extract images from PDF file"
        return 0
    fi
    
    if [[ $# -eq 0 ]]; then
        echo "Error: PDF file required"
        return 1
    fi
    
    local pdf_file="$1"
    local output_prefix="${2:-extracted_image}"
    
    if [[ ! -f "$pdf_file" ]]; then
        echo "Error: PDF file '$pdf_file' not found"
        return 1
    fi
    
    if command -v pdfimages &> /dev/null; then
        pdfimages -png "$pdf_file" "$output_prefix"
        echo "‚úÖ Images extracted from $pdf_file"
    else
        echo "Error: pdfimages not installed"
        echo "Install with: sudo apt install poppler-utils"
        return 1
    fi
}

# Clean markdown files by handling problematic separators
clean_markdown() {
    if [ $# -eq 0 ]; then
        echo "Usage: clean_markdown <input_file> [output_file]"
        return 1
    fi
    local input_file="$1"
    local output_file="${2:-${input_file%.*}_cleaned.${input_file##*.}}"
    if [ ! -f "$input_file" ]; then
        echo "Error: Input file '$input_file' does not exist"
        return 1
    fi
    awk '
        BEGIN { in_yaml = 0; yaml_count = 0 }
        /^---$/ {
            if (NR == 1) {
                in_yaml = 1
                yaml_count = 1
                print
                next
            }
            if (in_yaml && yaml_count == 1) {
                in_yaml = 0
                print
                next
            }
            print "***"
            next
        }
        { print }
    ' "$input_file" > "$output_file"
    echo "Cleaned markdown file created: $output_file"
}

# create backup of a file or directory
backup() {
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  # take files, dictionaries as arguments get full path as needed many args possible
  
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done

}

# Nano Functions
reset_file() {
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
  # Reset the file content to an empty string
  # use the backup function to create a backup of the file before erasing
  #handle one or multiple files
  # catch escapes and errors to handle prompting user to restore backup or delete
  for file in "$@"; do
    backup "$file"
    echo "" > "$file"
    echo "File content backed up and erased."
    echo "Opening $file in nano editor"
    #echo >> the filename to the file with a # at the beginning
    echo "# $file" >> "$file"
    #sleep half a second
    sleep 0.5
    nano "$file"
    # prompt user to restore backup or delete
    ls $file$backup_name
    # default to no
    see_diff="n"
    read -p "Do you want to see the difference between the original and backup file? (y/n):(default:n) " see_diff
    if [ "$see_diff" == "y" ]; then
      diff "$file" "$file$backup_name"
      restore_backup="n"
      read -p "Do you want to restore the backup file? (y/n):(default:n) " restore_backup
      if [ "$restore_backup" == "y" ]; then
        echo "This will delete any changes made to the original file"
        restore_backup_confirm="n"
        read -p "Are you sure you want to restore the backup file? (y/n):(default:n) " restore_backup_confirm
        if [ "$restore_backup_confirm" == "y" ]; then
          mv "$file$backup_name" "$file"
          echo "Backup file restored."
        fi
      fi
    fi
  done
}
