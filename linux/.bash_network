# Network-related utilities for bash
# (ported from .zsh_network)

# Show all network interfaces and their IPs
show_interfaces() {
    if command -v ip &> /dev/null; then
        ip addr show
    else
        ifconfig -a
    fi
}

# Ping a host with count and summary
ping_summary() {
    if [ -z "$1" ]; then
        echo "Usage: ping_summary <host>"
        return 1
    fi
    ping -c 4 "$1"
}

# --- Expanded functions ported from .zsh_network ---

# List open ports
alias ports='netstat -tulanp'
# Get public IP address
alias myip='curl ifconfig.me'
# Check HTTP headers
alias http="curl -I"

# Scan network ports using nmap
scan_ports() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    if [[ -z "$1" ]]; then
        local_ip=$(hostname -I | awk '{print $1}')
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed."
        echo -n "Do you want to install nmap? (y/n): "
        read install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            if command -v apt &> /dev/null; then
                sudo apt update && sudo apt install -y nmap
            elif command -v yum &> /dev/null; then
                sudo yum install -y nmap
            else
                echo "Please install nmap manually."
                return 1
            fi
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn "$ip_or_host"
}

# Simple Python HTTP server for sharing files
pyserver() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver [file1 file2 ...]"
        return 0
    fi
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed."
        return 1
    fi
    local port=8000
    local_ip=$(hostname -I | awk '{print $1}')
    if [ -n "$1" ]; then
        mkdir -p /tmp/pyserver
        for file in "$@"; do
            ln -s "$PWD/$file" /tmp/pyserver
        done
        cd /tmp/pyserver
        python3 -m http.server $port
    else
        python3 -m http.server $port
    fi
}

# Check public IP via multiple services
check_ip() {
    for svc in ifconfig.me ipinfo.io/ip; do
        echo -n "$svc → " && curl -s "$svc"
    done
}

# Flush DNS cache (Linux version)
flushdns() {
    # Linux DNS cache flushing varies by system
    echo "Flushing DNS cache..."
    
    # systemd-resolved (Ubuntu 18.04+, most modern systems)
    if systemctl is-active --quiet systemd-resolved; then
        sudo systemctl flush-dns systemd-resolved
        echo "✓ Flushed systemd-resolved cache"
    fi
    
    # nscd (older systems)
    if command -v nscd &> /dev/null && systemctl is-active --quiet nscd; then
        sudo systemctl restart nscd
        echo "✓ Restarted nscd"
    fi
    
    # dnsmasq (some systems)
    if systemctl is-active --quiet dnsmasq; then
        sudo systemctl restart dnsmasq
        echo "✓ Restarted dnsmasq"
    fi
    
    # Clear browser DNS cache recommendation
    echo "Note: You may also want to clear your browser's DNS cache"
}

# DNS lookup with caching (Linux version)
digc() {
    # Flush DNS cache first
    flushdns
    
    if [[ -z "$1" ]]; then
        dig @8.8.8.8
    else
        local args=("$@")
        dig "${args[@]}"
    fi
}

# Quick ping summary
pings() {
    if [[ -z "$1" ]]; then
        echo "Usage: pings hostname [count]"
        return 1
    fi
    ping -c "${2:-5}" "$1" | tail -2
}

# Generate random MAC address
gen_mac_addr() {
    local mac
    mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

# Show current MAC address (Linux version)
show_current_mac() {
    local interface="$1"
    
    if [[ -z "$interface" ]]; then
        echo "Usage: show_current_mac <interface_name>"
        echo "Available interfaces:"
        if command -v ip &> /dev/null; then
            ip link show | grep -E '^[0-9]+:' | awk -F': ' '{print "  " $2}' | sed 's/@.*//'
        else
            ifconfig -a | grep -E '^[a-zA-Z0-9]+:' | awk '{print "  " $1}' | sed 's/://'
        fi
        return 1
    fi
    
    # Check if interface exists
    if ! ip link show "$interface" &>/dev/null; then
        echo "Error: Interface '$interface' not found"
        echo "Available interfaces:"
        ip link show | grep -E '^[0-9]+:' | awk -F': ' '{print "  " $2}' | sed 's/@.*//'
        return 1
    fi
    
    # Get MAC address
    local mac
    if command -v ip &> /dev/null; then
        mac=$(ip link show "$interface" | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
    else
        mac=$(ifconfig "$interface" | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}')
    fi
    
    if [[ -n "$mac" ]]; then
        echo "MAC address for $interface: $mac"
    else
        echo "Could not retrieve MAC address for $interface"
        return 1
    fi
}

# Change MAC address (Linux version - enhanced)
change_mac_address() {
    local mac_address="$1"
    local interface="$2"
    local max_retries=3
    local retry_delay=2

    # If no MAC address provided, prompt the user
    if [[ -z "$mac_address" ]]; then
        echo "MAC Address options:"
        echo "  1. Enter a specific MAC address"
        echo "  2. Generate a random MAC address"
        echo -n "Choose option (1/2): "
        read -r choice

        case $choice in
            1)
                echo -n "Enter MAC address (with or without colons): "
                read -r mac_address
                ;;
            2)
                mac_address=$(gen_mac_addr)
                echo "Generated random MAC: $mac_address"
                ;;
            *)
                echo "Invalid choice. Exiting."
                return 1
                ;;
        esac
    fi

    # Normalize MAC address format - handle various input formats
    # Remove all non-hex characters (colons, dots, dashes, spaces)
    local clean_mac=$(echo "$mac_address" | tr -d ':.-' | tr -d '[:space:]')

    # Validate that we have exactly 12 hex characters
    if ! [[ "$clean_mac" =~ ^[0-9a-fA-F]{12}$ ]]; then
        echo "Error: Invalid MAC address. Must contain exactly 12 hexadecimal characters."
        echo "Accepted formats:"
        echo "  - XX:XX:XX:XX:XX:XX"
        echo "  - XX-XX-XX-XX-XX-XX"
        echo "  - XXXXXXXXXXXX"
        echo "  - XXXX.XXXX.XXXX"
        return 1
    fi

    # Convert to standard colon-separated format
    mac_address=$(echo "$clean_mac" | sed 's/../&:/g' | sed 's/:$//')
    echo "Normalized MAC address: $mac_address"

    # Check if interface name is provided
    if [[ -z "$interface" ]]; then
        echo ""
        echo "Available network interfaces:"
        if command -v ip &> /dev/null; then
            ip link show | grep -E '^[0-9]+:' | awk -F': ' '{print "  " $2}' | sed 's/@.*//'
        else
            ifconfig -a | grep -E '^[a-zA-Z0-9]+:' | awk '{print "  " $1}' | sed 's/://'
        fi
        echo ""
        echo -n "Enter interface name (e.g., eth0, wlan0): "
        read -r interface

        if [[ -z "$interface" ]]; then
            echo "Error: No interface specified."
            return 1
        fi
    fi

    # Check if interface exists
    if ! ip link show "$interface" &>/dev/null; then
        echo "Error: Interface '$interface' not found"
        echo "Available interfaces:"
        ip link show | grep -E '^[0-9]+:' | awk -F': ' '{print "  " $2}' | sed 's/@.*//'
        return 1
    fi

    # Get current MAC for backup
    local current_mac
    current_mac=$(ip link show "$interface" | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}' | head -1)

    # Check if MAC is already set to the target
    if [[ "$current_mac" == "$mac_address" ]]; then
        echo "MAC address is already set to $mac_address"
        return 0
    fi

    # Save original MAC if not already saved
    local mac_file="$HOME/.mac_$interface"
    if [[ ! -f "$mac_file" ]]; then
        echo "$current_mac" > "$mac_file"
        echo "Original MAC address saved: $current_mac"
    fi

    # Change MAC address with retry logic
    echo "Changing MAC address for $interface from $current_mac to $mac_address..."
    echo "This operation requires sudo privileges."

    local attempt=0
    local success=false

    while [[ $attempt -lt $max_retries ]]; do
        ((attempt++))

        if [[ $attempt -gt 1 ]]; then
            echo "Retry attempt $attempt/$max_retries..."
        fi

        # Bring interface down
        echo "Disabling interface..."
        if ! sudo ip link set dev "$interface" down 2>/dev/null; then
            echo "Warning: Failed to bring interface down"
        fi

        # Wait for interface to be fully down
        sleep 1

        # Change MAC address
        echo "Setting new MAC address..."
        if ! sudo ip link set dev "$interface" address "$mac_address" 2>/dev/null; then
            echo "Warning: MAC address set command failed"
        fi

        # Wait before bringing interface back up
        sleep 1

        # Bring interface back up
        echo "Re-enabling interface..."
        if ! sudo ip link set dev "$interface" up 2>/dev/null; then
            echo "Warning: Failed to bring interface up"
        fi

        # Wait for interface to be fully up and stable
        echo "Waiting for interface to stabilize..."
        sleep "$retry_delay"

        # Verify the change
        local new_mac
        new_mac=$(ip link show "$interface" 2>/dev/null | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}' | head -1)

        # Check if MAC change was successful
        if [[ -n "$new_mac" && "$new_mac" == "$mac_address" ]]; then
            echo "✓ MAC address successfully changed to $mac_address"
            success=true
            break
        else
            echo "✗ Attempt $attempt failed. Current MAC is: ${new_mac:-unable to determine}"
            if [[ $attempt -lt $max_retries ]]; then
                echo "Waiting before retry..."
                sleep 2
            fi
        fi
    done

    if $success; then
        # For Wi-Fi interfaces, try to restart NetworkManager or wpa_supplicant
        if [[ "$interface" =~ ^wl ]]; then
            echo "Restarting network services..."
            if systemctl is-active --quiet NetworkManager; then
                sudo systemctl restart NetworkManager 2>/dev/null && echo "  ✓ NetworkManager restarted"
            elif systemctl is-active --quiet wpa_supplicant; then
                sudo systemctl restart wpa_supplicant 2>/dev/null && echo "  ✓ wpa_supplicant restarted"
            fi
            sleep 2
        fi

        echo "MAC address change completed. You may need to reconnect to your network."
        return 0
    else
        echo "Failed to change MAC address after $max_retries attempts."
        echo "This may be due to:"
        echo "  1. Driver/hardware restrictions"
        echo "  2. Insufficient permissions"
        echo "  3. Interface in use by network manager"
        echo ""
        echo "Try stopping NetworkManager first:"
        echo "  sudo systemctl stop NetworkManager"
        echo "  # Then retry the MAC change"
        echo "  sudo systemctl start NetworkManager"
        return 1
    fi
}

# Restore original MAC address
restore_mac_address() {
    local interface="$1"
    
    if [[ -z "$interface" ]]; then
        echo "Usage: restore_mac_address <interface_name>"
        return 1
    fi
    
    local mac_file="$HOME/.mac_$interface"
    if [[ ! -f "$mac_file" ]]; then
        echo "Error: No saved MAC address found for $interface"
        echo "Saved MAC files:"
        ls -la "$HOME/.mac_"* 2>/dev/null || echo "  No saved MAC addresses found"
        return 1
    fi
    
    local original_mac
    original_mac=$(cat "$mac_file")
    
    echo "Restoring MAC address for $interface to: $original_mac"
    change_mac_address "$original_mac" "$interface"
}

# MAC address management menu
change_mac_menu() {
    echo "MAC Address Management Menu"
    echo "=========================="
    echo "1. Show current MAC addresses"
    echo "2. Change MAC address"
    echo "3. Generate random MAC address"
    echo "4. Restore original MAC address"
    echo "5. Exit"
    echo ""
    
    while true; do
        read -p "Select an option (1-5): " choice
        case $choice in
            1)
                echo ""
                echo "Current network interfaces:"
                if command -v ip &> /dev/null; then
                    ip link show | grep -E '^[0-9]+:' | while read line; do
                        iface=$(echo "$line" | awk -F': ' '{print $2}' | sed 's/@.*//')
                        mac=$(echo "$line" | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}' || echo "No MAC")
                        echo "  $iface: $mac"
                    done
                else
                    ifconfig -a | grep -E '^[a-zA-Z0-9]+' | while read line; do
                        iface=$(echo "$line" | awk '{print $1}' | sed 's/://')
                        mac=$(ifconfig "$iface" | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}' || echo "No MAC")
                        echo "  $iface: $mac"
                    done
                fi
                echo ""
                ;;
            2)
                echo ""
                read -p "Enter interface name: " iface
                read -p "Enter new MAC address (or press Enter for random): " mac
                if [[ -z "$mac" ]]; then
                    change_mac_address "" "$iface"
                else
                    change_mac_address "$mac" "$iface"
                fi
                echo ""
                ;;
            3)
                echo ""
                echo "Random MAC address: $(gen_mac_addr)"
                echo ""
                ;;
            4)
                echo ""
                read -p "Enter interface name: " iface
                restore_mac_address "$iface"
                echo ""
                ;;
            5)
                echo "Exiting..."
                break
                ;;
            *)
                echo "Invalid option. Please select 1-5."
                ;;
        esac
    done
}

# Network diagnostics
network_info() {
    echo "Network Information Summary"
    echo "=========================="
    echo ""
    
    echo "📡 Network Interfaces:"
    if command -v ip &> /dev/null; then
        ip addr show | grep -E '^[0-9]+:|inet ' | sed 's/^/  /'
    else
        ifconfig | grep -E '^[a-zA-Z0-9]+:|inet ' | sed 's/^/  /'
    fi
    
    echo ""
    echo "🌍 Public IP:"
    echo "  $(curl -s ifconfig.me 2>/dev/null || echo 'Unable to retrieve')"
    
    echo ""
    echo "🔗 Default Route:"
    if command -v ip &> /dev/null; then
        ip route show default | sed 's/^/  /'
    else
        route -n | grep '^0.0.0.0' | sed 's/^/  /'
    fi
    
    echo ""
    echo "📶 DNS Servers:"
    if [[ -f /etc/resolv.conf ]]; then
        grep -E '^nameserver' /etc/resolv.conf | sed 's/^/  /'
    else
        echo "  Unable to retrieve DNS servers"
    fi
    
    echo ""
    echo "🔌 Open Ports (TCP):"
    if command -v ss &> /dev/null; then
        ss -tln | head -10 | sed 's/^/  /'
    elif command -v netstat &> /dev/null; then
        netstat -tln | head -10 | sed 's/^/  /'
    else
        echo "  No suitable command found (ss or netstat needed)"
    fi
}

# Funnel function for sharing local server (Linux version using various tools)
funnel() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: funnel [port] [options]"
        echo "Share a local server on the internet"
        echo "Options:"
        echo "  -p, --port PORT    Port to share (default: 8000)"
        echo "  -h, --help         Show this help"
        echo ""
        echo "This function will try to use available tools in order:"
        echo "  1. Tailscale funnel (if available)"
        echo "  2. ngrok (if available)" 
        echo "  3. localtunnel (if available)"
        echo "  4. serveo.net SSH tunneling"
        return 0
    fi
    
    local port="${1:-8000}"
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--port)
                port="$2"
                shift 2
                ;;
            *)
                port="$1"
                shift
                ;;
        esac
    done
    
    echo "Attempting to share local server on port $port..."
    
    # Try Tailscale funnel first
    if command -v tailscale &> /dev/null; then
        echo "Trying Tailscale funnel..."
        if tailscale funnel --bg "$port"; then
            echo "✅ Tailscale funnel started on port $port"
            echo "Your service is now publicly accessible!"
            return 0
        else
            echo "⚠️ Tailscale funnel failed, trying other methods..."
        fi
    fi
    
    # Try ngrok
    if command -v ngrok &> /dev/null; then
        echo "Trying ngrok..."
        echo "Starting ngrok tunnel on port $port (Ctrl+C to stop)"
        ngrok http "$port"
        return 0
    fi
    
    # Try localtunnel
    if command -v lt &> /dev/null; then
        echo "Trying localtunnel..."
        echo "Starting localtunnel on port $port (Ctrl+C to stop)"
        lt --port "$port"
        return 0
    fi
    
    # Try serveo.net SSH tunneling
    if command -v ssh &> /dev/null; then
        echo "Trying serveo.net SSH tunnel..."
        echo "Starting SSH tunnel on port $port (Ctrl+C to stop)"
        echo "Your service will be available at: https://[random-subdomain].serveo.net"
        ssh -R "80:localhost:$port" serveo.net
        return 0
    fi
    
    echo "❌ No suitable tunneling tools found."
    echo "Please install one of the following:"
    echo "  • Tailscale: https://tailscale.com/download"
    echo "  • ngrok: https://ngrok.com/download"
    echo "  • localtunnel: npm install -g localtunnel"
    echo "  • Or ensure SSH is available for serveo.net"
    return 1
}
