# ----------------------
# Network Functions and Aliases
# ----------------------

# Unalias any existing Cloudflare aliases to prevent conflicts when re-sourcing
for cmd in cftemp cfclean cfhelp cfinfo cfshot cfdev cfsync cfget cfdeploy cfupload cfdownload cffiles cfdelete cfbackup cftunnel funnel; do
  unalias $cmd 2>/dev/null || true
done

# Network diagnostics
alias ports='netstat -tulanp'  # List open ports
alias myip='curl ifconfig.me'  # Check external IP address
alias http="curl -I"           # Check HTTP headers

# lookup your public IP via multiple services
check_ip() {
    for svc in ifconfig.me ipinfo.io/ip; do
        echo -n "$svc → " && curl -s "$svc"
    done
}

# flush DNS cache
flushdns() {
    # flush DNS cache -  can be helpful when you have a new IP address
    sudo killall -HUP mDNSResponder
}

# faster DNS lookup with caching
digc() {
    # flush DNS cache
    flushdns
    
    # if no arg is passed use default google DNS if arg is passed use that arg
    if [[ -z "$1" ]]; then
        dig @8.8.8.8
    else
        # Use array to prevent word splitting issues
        local args=("$@")
        dig "${args[@]}"
    fi
}

# quick ping summary
pings() {
    if [[ -z "$1" ]]; then
        echo "Usage: pings hostname [count]"
        return 1
    fi
    ping -c "${2:-5}" "$1" | tail -2
}

# MAC address management
gen_mac_addr() {
    local mac
    mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

show_current_mac() {
    local interface_input="$1"
    local interface_name
    
    if [[ -z "$interface_input" ]]; then
        echo "Usage: show_current_mac <device_name>"
        echo "Available interfaces:"
        networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
        return 1
    fi
    
    # Convert friendly name to device name if needed
    if [[ "$interface_input" == "Wi-Fi" || "$interface_input" == "wifi" || "$interface_input" == "WIFI" ]]; then
        # Look up the device name for Wi-Fi
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')
        echo "Converting Wi-Fi to device name: $interface_name"
    elif [[ "$interface_input" =~ ^en[0-9]+$ ]]; then
        # Already a device name
        interface_name="$interface_input"
    else
        # Try to find the device name for the given hardware port
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "$interface_input" | grep "Device:" | awk '{print $2}')
        if [[ -z "$interface_name" ]]; then
            echo "Error: Could not find device name for '$interface_input'"
            echo "Available interfaces:"
            networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
            return 1
        fi
        echo "Converting '$interface_input' to device name: $interface_name"
    fi
    
    networksetup -getmacaddress "$interface_name"
}

change_mac_address() {
    local mac_address="$1"
    local interface_input="$2"
    local interface_name
    
    # Generate random MAC if none provided
    if [[ -z "$mac_address" ]]; then
        mac_address=$(gen_mac_addr)
        echo "No MAC address provided. Using generated MAC: $mac_address"
    fi
    
    # Check if interface name is provided
    if [[ -z "$interface_input" ]]; then
        echo "No interface name provided. Available interfaces:"
        networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
        echo "Usage: change_mac_address <mac_address> <interface_name>"
        return 1
    fi
    
    # Convert friendly name to device name if needed
    if [[ "$interface_input" == "Wi-Fi" || "$interface_input" == "wifi" || "$interface_input" == "WIFI" ]]; then
        # Look up the device name for Wi-Fi
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')
        echo "Converting Wi-Fi to device name: $interface_name"
    elif [[ "$interface_input" =~ ^en[0-9]+$ ]]; then
        # Already a device name
        interface_name="$interface_input"
    else
        # Try to find the device name for the given hardware port
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "$interface_input" | grep "Device:" | awk '{print $2}')
        if [[ -z "$interface_name" ]]; then
            echo "Error: Could not find device name for '$interface_input'"
            echo "Available interfaces:"
            networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
            return 1
        fi
        echo "Converting '$interface_input' to device name: $interface_name"
    fi
    
    # Get current MAC for this interface
    local current_info
    current_info=$(networksetup -getmacaddress "$interface_name" 2>/dev/null)
    
    # Check if the interface exists
    if [[ $? -ne 0 || "$current_info" == *"does not exist"* ]]; then
        echo "Error: Interface $interface_name not found."
        return 1
    fi
    
    # Extract current MAC address
    local current_mac
    current_mac=$(echo "$current_info" | awk '{print $3}')
    
    # Save original MAC if not already saved
    local mac_file="$HOME/.mac_$interface_name"
    if [[ ! -f "$mac_file" ]]; then
        echo "$current_mac" > "$mac_file"
        echo "Original MAC address saved: $current_mac"
    fi
    
    # Change MAC address
    echo "Changing MAC address for $interface_name to $mac_address..."
    
    # Turn off the interface
    echo "Disabling interface..."
    sudo ifconfig "$interface_name" down
    
    # Set the new MAC address
    sudo ifconfig "$interface_name" ether "$mac_address"
    
    # Turn the interface back on
    echo "Re-enabling interface..."
    sudo ifconfig "$interface_name" up
    
    # Verify the change
    local new_mac
    new_mac=$(ifconfig "$interface_name" | grep ether | awk '{print $2}')
    
    if [[ "$new_mac" == "$mac_address" ]]; then
        echo "MAC address successfully changed to $mac_address"
        return 0
    else
        echo "Failed to change MAC address. Current MAC is $new_mac"
        return 1
    fi
}

change_mac_menu() {
    local choice mac_address interface_name
    
    # First show available interfaces
    echo "Available network interfaces:"
    networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
    echo ""
    echo "You can use either the device name (e.g., en0) or the friendly name (e.g., Wi-Fi)"
    echo ""
    
    echo "Choose an option:"
    echo "0. Show current MAC address"
    echo "1. Set a specific MAC address"
    echo "2. Set a random MAC address"
    echo "3. Restore original MAC address"
    echo -n "Enter your choice (0/1/2/3): "
    read -r choice

    case $choice in
        0)
            echo -n "Enter interface name (e.g., en0 or Wi-Fi): "
            read -r interface_name
            show_current_mac "$interface_name"
            ;;
        1)
            echo -n "Enter the new MAC address (e.g., E6:B8:BA:D2:41:07): "
            read -r mac_address
            echo -n "Enter the interface name (e.g., en0 or Wi-Fi): "
            read -r interface_name
            change_mac_address "$mac_address" "$interface_name"
            ;;
        2)
            echo -n "Enter the interface name (e.g., en0 or Wi-Fi): "
            read -r interface_name
            mac_address=$(gen_mac_addr)
            change_mac_address "$mac_address" "$interface_name"
            ;;
        3)
            echo -n "Enter the interface name to restore (press enter to see available): "
            read -r interface_name
            restore_original_mac "$interface_name"
            ;;
        *)
            echo "Invalid choice. Exiting."
            return 1
            ;;
    esac
}

analyze_network_traffic() {
    local help=false pcap_file=""
    # Analysis flags
    local want_top=false want_proto=false want_io=false want_http=false
    local want_dns=false want_tls=false want_expert=false want_resp=false
    local export_fields=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)       help=true; shift ;;
            -f|--file)       pcap_file="$2"; shift 2 ;;
            -t|--top-talkers) want_top=true; shift ;;
            -p|--proto-hierarchy) want_proto=true; shift ;;
            -s|--io-stats)   want_io=true; shift ;;
            -H|--http)       want_http=true; shift ;;
            -D|--dns-summary) want_dns=true; shift ;;
            -L|--tls-handshake) want_tls=true; shift ;;
            -E|--expert)     want_expert=true; shift ;;
            -R|--response-times) want_resp=true; shift ;;
            -x|--export-fields) export_fields="$2"; shift 2 ;;
            *) echo "Unknown option: $1"; echo "Try: analyze_network_traffic -h"; return 1 ;;
        esac
    done

    # Help or missing file
    if $help || [[ -z "$pcap_file" ]]; then
        echo "Usage: analyze_network_traffic -f FILE [options]"
        echo
        echo "Options:"
        echo "  -f, --file FILE           PCAP file to analyze (required)"
        echo "  -t, --top-talkers         Show IP conversation stats"
        echo "  -p, --proto-hierarchy     Show protocol hierarchy"
        echo "  -s, --io-stats            Show packet I/O rates"
        echo "  -H, --http                Extract HTTP host/URI list"
        echo "  -D, --dns-summary         Summarize DNS qtypes/qclasses"
        echo "  -L, --tls-handshake       Count TLS handshake packets"
        echo "  -E, --expert              Show expert errors/warnings"
        echo "  -R, --response-times      Show DNS/HTTP response times"
        echo "  -x, --export-fields F1,F2 Export fields F1,F2,... as CSV"
        return 0
    fi

    # Validate file exists
    if [[ ! -f "$pcap_file" ]]; then
        echo "Error: PCAP file '$pcap_file' not found"
        return 1
    fi

    echo "Analyzing $pcap_file..."

    # Top Talkers (IP conversations)
    if $want_top; then
        echo "== Top Talkers =="
        tshark -r "$pcap_file" -q -z conv,ip      #  [oai_citation:11‡Wireshark Q&A](https://osqa-ask.wireshark.org/questions/6430/analyze-per-ip/?utm_source=chatgpt.com)
    fi

    # Protocol Hierarchy
    if $want_proto; then
        echo "== Protocol Hierarchy =="
        tshark -r "$pcap_file" -q -z io,phs        #  [oai_citation:12‡Chris Sanders](https://chrissanders.org/2018/05/large-captures2-proto-hierarchy/?utm_source=chatgpt.com)
    fi

    # I/O Statistics (per-second)
    if $want_io; then
        echo "== I/O Statistics =="
        tshark -r "$pcap_file" -q -z io,stat,1     #  [oai_citation:13‡Stack Overflow](https://stackoverflow.com/questions/14451599/how-to-save-tshark-statistics-in-variables?utm_source=chatgpt.com) [oai_citation:14‡GitHub](https://github.com/Cthfm/Azure/blob/main/packet-analysis/tshark-cheatsheet.md?utm_source=chatgpt.com)
    fi

    # HTTP Requests Extraction
    if $want_http; then
        echo "== HTTP Requests =="
        tshark -r "$pcap_file" -Y http.request \
               -T fields -e http.host -e http.request.uri  #  [oai_citation:15‡CellStream, Inc.](https://www.cellstream.com/2014/05/12/t-shark-usage-examples/?utm_source=chatgpt.com) [oai_citation:16‡Gist](https://gist.github.com/githubfoam/6c9e07f95c2eb03ec4ae9709252c713f?utm_source=chatgpt.com)
    fi

    # DNS Summary
    if $want_dns; then
        echo "== DNS Summary =="
        tshark -r "$pcap_file" -q -z dns,tree      #  [oai_citation:17‡Wireshark](https://www.wireshark.org/docs/man-pages/tshark.html?utm_source=chatgpt.com)
    fi

    # TLS Handshake Count
    if $want_tls; then
        echo "== TLS Handshakes =="
        tshark -r "$pcap_file" -Y tls.handshake \
               -q -z io,stat,0                    #  [oai_citation:18‡CLI Wiki](https://cli.wiki/TShark---Terminal-Wireshark-Network-Analyzer-Guide?utm_source=chatgpt.com)
    fi

    # Expert Info (errors/warnings)
    if $want_expert; then
        echo "== Expert Info =="
        tshark -r "$pcap_file" -q -z "expert,error"  #  [oai_citation:19‡Gist](https://gist.github.com/donovanrodriguez/87dacb99caefa56d98d7e35b7d4a2539?utm_source=chatgpt.com)
    fi

    # Service Response Times (DNS & HTTP)
    if $want_resp; then
        echo "== Response Times =="
        tshark -r "$pcap_file" -q -z srt,dns        #  [oai_citation:20‡Gist](https://gist.github.com/donovanrodriguez/87dacb99caefa56d98d7e35b7d4a2539?utm_source=chatgpt.com)
        tshark -r "$pcap_file" -q -z srt,http
    fi

    # CSV Field Export
    if [[ -n "$export_fields" ]]; then
        echo "== Exporting Fields: $export_fields =="
        # convert comma list to multiple -e args
        IFS=',' read -ra F <<< "$export_fields"
        tshark -r "$pcap_file" -T fields -E header=y -E separator=, "${F[@]/#/-e }"
    fi
}

capture_network_traffic() {
	local iface duration size count prefix filter help=false

	# Default prefix
	prefix="capture"

	# Parse options
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-h|--help)
			help=true; shift
			;;
		-i|--interface)
			iface="$2"; shift 2
			;;
		-d|--duration)
			duration="$2"; shift 2
			;;
		-s|--size)
			size="$2"; shift 2
			;;
		-c|--count)
			count="$2"; shift 2
			;;
		-o|--prefix)
			prefix="$2"; shift 2
			;;
		-p|--filter)
			filter="$2"; shift 2
			;;
		*)
			echo "Unknown option: $1"
			echo "Use: capture_network_traffic --help"
			return 1
			;;
		esac
	done

	# Show help or error if interface missing
	if [[ "$help" == true ]] || [[ -z "$iface" ]]; then
		echo "Usage: capture_network_traffic -i interface [options]"
		echo "	-i, --interface IFACE    (required) e.g. en0"
		echo "	-d, --duration SEC       rotate every SEC seconds"
		echo "	-s, --size MB            rotate after MB megabytes"
		echo "	-c, --count N            keep up to N files"
		echo "	-o, --prefix PREFIX      filename prefix (default: capture)"
		echo "	-p, --filter BPF         e.g. 'port 443 and host 1.2.3.4'"
		echo "	-h, --help               show this message"
		return 0
	fi

	# Build timestamped filename
	local ts file cmd
	ts=$(date +%Y%m%d_%H%M%S)
	file="${prefix}_${ts}.pcap"

	# Assemble tcpdump command
	cmd=( sudo tcpdump -i "$iface" -s 0 -n -w "$file" )
	[[ -n "$size"     ]] && cmd+=( -C "$size" )       # size-based rotate  [oai_citation:8‡Kudithipudi](https://kudithipudi.org/2013/02/14/how-to-configure-tcpdump-to-rotate-capture-files-based-on-size/?utm_source=chatgpt.com)
	[[ -n "$duration" ]] && cmd+=( -G "$duration" )   # time-based rotate  [oai_citation:9‡discoveringsystems.com](https://discoveringsystems.com/how-to-rotate-packet-capture-files-using-tcpdump/?utm_source=chatgpt.com)
	[[ -n "$count"    ]] && cmd+=( -W "$count" )      # limit file count  [oai_citation:10‡Super User](https://superuser.com/questions/904786/tcpdump-rotate-capture-files-using-g-w-and-c?utm_source=chatgpt.com)
	[[ -n "$filter"   ]] && cmd+=( $filter )          # BPF filter  [oai_citation:11‡myF5](https://my.f5.com/manage/s/article/K65251607?utm_source=chatgpt.com)

	# Execute
	echo "Capturing on $iface → $file"
	printf '› %q ' "${cmd[@]}"
	echo
	"${cmd[@]}"
}


# Scan network ports
scan_ports() {
    local ip_or_host local_ip install_nmap
    
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    
    # if no ip_or_host is passed then use the router ip 
    if [[ -z "$1" ]]; then
        local_ip=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -n 1)
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    
    #check if package is installed
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed"
        echo -n "Do you want to install nmap? (y/n): " 
        read -r install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            brew install nmap
            echo "nmap installed, continuing with scan"
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn "$ip_or_host"
}

# Python HTTP server
pyserver() {
    local port=8000 local_ip file original_dir
    
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver file1 file2 ..."
        return 0
    fi
    
    # check if python3 is installed
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed"
        echo "You can install it with:"
        echo 'brew install python'
        return 1
    fi
    
    #get local ip
    local_ip=$(hostname -I | awk '{print $1}')
    original_dir=$(pwd)
    
    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    if [ -n "$1" ]; then
        # create temp dir
        mkdir -p /tmp/pyserver
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/pyserver/
        done
        # change dir to the temp dir
        cd /tmp/pyserver || return 1
    fi
    
    # start the python server
    python3 -m http.server "$port"
    
    # Return to original directory
    cd "$original_dir" || return 1
}

# Tailscale funnel for sharing files or services over the internet
funnel_function() {
    local port=${FUNNEL_PORT:-8080}
    local use_python=true
    local direct_service=false
    local target
    local server_pid
    local original_dir
    
    # Process options
    while [[ "$1" == -* ]]; do
        case "$1" in
            -h|--help)
                cat << 'EOF'
Usage: funnel [OPTIONS] [target]
Funnel enables you to share local files or services over the internet using Tailscale.

Options:
  -h, --help            Show this help message
  -d, --direct          Directly funnel to a port without using Python server
  -p, --port PORT       Specify port (default: 8080 or FUNNEL_PORT env variable)

Examples:
  funnel file.txt              # Share a file using Python HTTP server
  funnel -d -p 3000            # Directly funnel localhost:3000
  funnel -d redis://localhost:6379  # Directly funnel a Redis service
EOF
                return 0
                ;;
            -d|--direct)
                direct_service=true
                use_python=false
                shift
                ;;
            -p|--port)
                port="$2"
                shift 2
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use 'funnel --help' for usage information."
                return 1
                ;;
        esac
    done

    # Check if tailscale is running
    if ! tailscale status &> /dev/null; then
        echo "Tailscale is not running. Attempting to start it with 'tailscale up'..."
        tailscale up
        
        # Check again if tailscale is running after attempting to start it
        if ! tailscale status &> /dev/null; then
            echo "Error: Failed to start Tailscale. Please start it manually."
            return 1
        fi
        echo "Tailscale started successfully. Continuing..."
    fi

    # Use current directory if no target is specified
    if [ -z "$1" ]; then
        echo "No target specified. Using current directory as target."
        target="."
    else
        target="$*"
    fi

    # Kill any existing Python HTTP servers on our port
    local existing_pid
    existing_pid=$(lsof -ti:"$port")
    if [[ -n "$existing_pid" ]]; then
        echo "Killing existing process on port $port (PID: $existing_pid)"
        kill -9 "$existing_pid" 2>/dev/null
        sleep 1
    fi

    # Function to clean up background processes
    cleanup() {
        echo "Cleaning up..."
        # Find and kill the Python HTTP server process
        if [[ -n "$server_pid" ]]; then
            echo "Killing server process (PID: $server_pid)"
            kill -9 "$server_pid" 2>/dev/null
            wait "$server_pid" 2>/dev/null
        fi
        
        # Also try to find any process using our port
        local port_pid
        port_pid=$(lsof -ti:"$port")
        if [[ -n "$port_pid" ]]; then
            echo "Killing process on port $port (PID: $port_pid)"
            kill -9 "$port_pid" 2>/dev/null
        fi
        
        # Clean up temp directory
        if [[ -d "/tmp/funnel" ]]; then
            echo "Removing temporary directory"
            rm -rf /tmp/funnel
        fi
        
        # Return to original directory
        if [[ -n "$original_dir" ]]; then
            cd "$original_dir" || return 1
        fi
        
        return 0
    }

    # Save original directory
    original_dir=$(pwd)

    # Trap SIGINT (Ctrl+C) to run cleanup
    trap cleanup INT TERM EXIT

    # If direct service mode is enabled, funnel directly to the target service
    if $direct_service; then
        echo "Directly funneling to service on port $port..."
        
        # If the target contains a service URL, use it directly
        if [[ "$target" == *://* ]]; then
            echo "Funneling service: $target"
            tailscale funnel "$target"
        else
            echo "Funneling localhost:$port"
            tailscale funnel "localhost:$port"
        fi
        
        # Keep the process alive until Ctrl+C
        echo "Press Ctrl+C to stop the funnel"
        while true; do
            sleep 1
        done
    # if files are passed as arguments and not using direct mode
    elif [ -n "$1" ]; then
        # Clean up any existing temp directory
        if [[ -d "/tmp/funnel" ]]; then
            rm -rf /tmp/funnel
        fi
        
        # Create temp dir
        mkdir -p /tmp/funnel
        
        # Copy (not link) the files to the temp dir
        for file in "$@"; do
            # Use absolute paths for files
            local abs_path
            if [[ "$file" = /* ]]; then
                abs_path="$file"
            else
                abs_path="$original_dir/$file"
            fi
            
            echo "Checking path: $abs_path"
            
            if [[ -f "$abs_path" ]]; then
                cp "$abs_path" "/tmp/funnel/"
                echo "Copied file: $abs_path"
            elif [[ -d "$abs_path" ]]; then
                # For directories, copy the entire directory structure
                cp -r "$abs_path" "/tmp/funnel/"
                echo "Copied directory: $abs_path"
            else
                echo "Warning: $abs_path does not exist, skipping"
            fi
        done
        
        # Change dir to the temp dir
        cd /tmp/funnel || return 1
        
        # List the contents to verify
        echo "Files available for sharing:"
        ls -la
        
        if $use_python; then
            # Start the python server
            python3 -m http.server "$port" &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:"$port" >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel "localhost:$port"
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    else
        # Use current dir
        if $use_python; then
            # Start the python server
            python3 -m http.server "$port" &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:"$port" >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel "localhost:$port"
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    fi
}

alias tsf=funnel
alias postfile=funnel
alias openport="funnel -d -p"

# Cloudflare tunnel for sharing local services
cftunnel_function() {
    local port=${1:-8080}
    local protocol=${2:-http}
    
    # Process options
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        cat << 'EOF'
Usage: cftunnel [PORT] [PROTOCOL]
Share a local service over the internet using Cloudflare Tunnel.

Arguments:
  PORT      Port number to expose (default: 8080)
  PROTOCOL  Protocol to use: http or https (default: http)

Examples:
  cftunnel              # Share localhost:8080 via HTTP
  cftunnel 3000         # Share localhost:3000 via HTTP
  cftunnel 3001 https   # Share localhost:3001 via HTTPS
  cftunnel -h           # Show this help message
EOF
        return 0
    fi
    
    # Check if cloudflared is installed
    if ! command -v cloudflared &> /dev/null; then
        echo "Error: cloudflared is not installed"
        echo "You can install it with:"
        echo "  brew install cloudflared"
        return 1
    fi
    
    local url="${protocol}://localhost:${port}"
    
    echo "Starting Cloudflare tunnel for ${url}..."
    echo "Press Ctrl+C to stop the tunnel"
    echo ""
    
    # Start the cloudflare tunnel
    cloudflared tunnel --url "$url"
}

# Aliases for cloudflare tunnel
alias cftunnel_share=cftunnel  # Tunnel sharing (renamed to avoid conflict)
alias cloudshare=cftunnel
alias cft=cftunnel

# ----------------------
# Cloudflare Wrangler Functions
# ----------------------

# Auto-setup helper function
_cf_ensure_setup() {
    # Find dotfiles directory if not in it
    local dotfiles_dir="$HOME/Git/dotfiles/macos"
    if [[ ! -f package.json ]] || ! grep -q "wrangler" package.json 2>/dev/null; then
        if [[ -f "$dotfiles_dir/package.json" ]]; then
            echo "🔄 Switching to dotfiles directory..."
            cd "$dotfiles_dir"
        else
            echo "❌ Cannot find dotfiles directory with wrangler config"
            echo "Please navigate to your dotfiles directory first"
            return 1
        fi
    fi
    
    # Install dependencies if needed
    if [[ ! -d node_modules ]]; then
        echo "📦 Installing dependencies..."
        npm install --silent
    fi
    
    # Check authentication
    if ! wrangler whoami &>/dev/null 2>&1; then
        echo "🔐 Wrangler not authenticated. Please login..."
        wrangler login
        if ! wrangler whoami &>/dev/null 2>&1; then
            echo "❌ Authentication failed"
            return 1
        fi
    fi
    
    # Check if R2 buckets exist (indicator of setup completion)
    local bucket_check=$(wrangler r2 bucket list 2>/dev/null | grep -E "(files|screenshots|backups)")
    if [[ -z "$bucket_check" ]]; then
        echo "🔧 First-time setup detected. Creating R2 buckets with public access..."
        local buckets=("files" "screenshots" "backups" "images")
        for bucket in "${buckets[@]}"; do
            echo "📦 Creating public bucket: $bucket"
            if wrangler r2 bucket create "$bucket" 2>/dev/null; then
                echo "🌍 Enabling public access for: $bucket"
                # Enable R2 dev URL for public access
                wrangler r2 bucket dev-url enable "$bucket" 2>/dev/null || echo "  ⚠️  Public access needs manual configuration in dashboard"
            else
                echo "  ⚠️  Bucket $bucket may already exist"
            fi
        done
    fi
    
    return 0
}

# Manual setup command (optional)
cfsetup() {
    echo "🔧 Running Cloudflare setup..."
    _cf_ensure_setup && npm run setup:cloudflare
}

# Sync local secrets to Cloudflare
cfsync_function() {
    _cf_ensure_setup || return 1
    echo "🔄 Syncing local secrets to Cloudflare..."
    
    # Check if worker exists first
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "⚠️  Worker not deployed yet. Deploying first..."
        if cfdeploy; then
            echo "✅ Worker deployed, now syncing secrets..."
            npm run secrets:sync
        else
            echo "❌ Worker deployment failed"
            return 1
        fi
    else
        npm run secrets:sync
    fi
}

# Get secrets from Cloudflare 
cfget_function() {
    _cf_ensure_setup || return 1
    echo "📥 Getting secrets from Cloudflare..."
    
    # Check if worker exists first
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "⚠️  Worker not deployed yet. Deploying first..."
        if cfdeploy; then
            echo "✅ Worker deployed, now getting secrets..."
            npm run secrets:get
        else
            echo "❌ Worker deployment failed"
            return 1
        fi
    else
        npm run secrets:get
    fi
}

# List available secrets
_cflist_function() {
    _cf_ensure_setup || return 1
    echo "📋 Listing Cloudflare secrets..."
    
    # Check if worker exists first
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "⚠️  Worker 'macos-dotfiles-secrets' doesn't exist yet"
        echo "🚀 Deploying worker first..."
        if cfdeploy; then
            echo "✅ Worker deployed, now listing secrets..."
            npm run secrets:list
        else
            echo "❌ Worker deployment failed"
            return 1
        fi
    else
        npm run secrets:list
    fi
}

# Deploy worker to Cloudflare
cfdeploy_function() {
    _cf_ensure_setup || return 1
    echo "🚀 Deploying worker to Cloudflare..."
    
    # Check if source files exist
    if [[ ! -f "src/index.js" ]]; then
        echo "❌ Worker source file not found: src/index.js"
        echo "💡 Make sure you're in the dotfiles directory with the worker code"
        return 1
    fi
    
    if [[ ! -f "wrangler.toml" ]]; then
        echo "❌ Wrangler configuration not found: wrangler.toml"
        return 1
    fi
    
    echo "📋 Deploying worker 'macos-dotfiles-secrets'..."
    if wrangler deploy; then
        echo "✅ Worker deployed successfully!"
        echo "🔗 Worker URL will be shown above"
        
        # Test the deployment
        echo "🧪 Testing worker deployment..."
        if wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
            echo "✅ Worker deployment verified"
        else
            echo "⚠️  Worker deployment verification failed"
        fi
    else
        echo "❌ Worker deployment failed"
        echo "💡 Check the error messages above for details"
        return 1
    fi
}

# Test worker locally
cfdev_function() {
    _cf_ensure_setup || return 1
    echo "💻 Starting local development server..."
    
    # Check if source files exist
    if [[ ! -f "src/index.js" ]]; then
        echo "❌ Worker source file not found: src/index.js"
        return 1
    fi
    
    if [[ ! -f "wrangler.toml" ]]; then
        echo "❌ Wrangler configuration not found: wrangler.toml"
        return 1
    fi
    
    echo "🚀 Starting local worker at http://localhost:8787"
    echo "🔄 Press Ctrl+C to stop"
    wrangler dev
}
alias cfdev=cfdev_function

# Upload file to R2 bucket and get shareable link
cfupload_function() {
    _cf_ensure_setup || return 1
    
    local file_path="$1"
    local bucket_name="${2:-files}"
    local custom_name="$3"
    
    if [[ -z "$file_path" ]]; then
        echo "Usage: cfupload FILE_PATH [BUCKET_NAME] [CUSTOM_NAME]"
        echo ""
        echo "Examples:"
        echo "  cfupload ~/screenshot.png"
        echo "  cfupload ~/document.pdf files my-doc.pdf"
        echo "  cfupload ~/image.jpg images"
        return 1
    fi
    
    if [[ ! -f "$file_path" ]]; then
        echo "Error: File not found: $file_path"
        return 1
    fi
    
    # Generate filename if not provided
    if [[ -z "$custom_name" ]]; then
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        local extension="${file_path##*.}"
        local basename=$(basename "$file_path" ".$extension")
        custom_name="${basename}_${timestamp}.${extension}"
    fi
    
    echo "📤 Uploading $(basename "$file_path") to R2 bucket: $bucket_name"
    echo "🏷️  Remote name: $custom_name"
    
    # Try to upload - if bucket doesn't exist, create it
    if ! wrangler r2 object put "$bucket_name/$custom_name" --file="$file_path" 2>/dev/null; then
        echo "📦 Bucket might not exist. Attempting to create..."
        
        # Try to create the bucket
        if wrangler r2 bucket create "$bucket_name" 2>/dev/null; then
            echo "✅ Bucket '$bucket_name' created"
            
            # Check if this should be a public bucket
            if [[ "$bucket_name" == *"-public" ]] || [[ "$bucket_name" == "screenshots" ]] || [[ "$bucket_name" == "files" ]] || [[ "$bucket_name" == "images" ]]; then
                echo "🌍 Enabling public access..."
                wrangler r2 bucket dev-url enable "$bucket_name" 2>/dev/null
            fi
            
            # Retry the upload
            if wrangler r2 object put "$bucket_name/$custom_name" --file="$file_path"; then
                echo "✅ Upload successful after creating bucket!"
            else
                echo "❌ Upload failed even after creating bucket"
                return 1
            fi
        else
            # Bucket exists, retry upload
            if wrangler r2 object put "$bucket_name/$custom_name" --file="$file_path"; then
                echo "✅ Upload successful!"
            else
                echo "❌ Upload failed"
                return 1
            fi
        fi
    else
        echo "✅ Upload successful!"
        
        # Generate R2 public URL
        # Map buckets to their public domains (update as you enable more buckets)
        local r2_domain=""
        case "$bucket_name" in
            "files")
                r2_domain="pub-ef8813e86b494d8e8ff24a6182785ea4.r2.dev"
                ;;
            "screenshots"|"images"|*"-public")
                # These need public access enabled first
                r2_domain=""
                ;;
        esac
        
        # Check if bucket has public access configured
        if [[ -n "$r2_domain" ]]; then
            local public_url="https://${r2_domain}/$custom_name"
            
            echo "🔗 Public URL: $public_url"
            echo "📋 Copying URL to clipboard..."
            echo "$public_url" | pbcopy
            
            # Test if URL is accessible
            local http_status=$(curl -s -o /dev/null -w "%{http_code}" "$public_url" 2>/dev/null)
            if [[ "$http_status" == "200" ]]; then
                echo "✅ URL is publicly accessible!"
            elif [[ "$http_status" == "404" ]]; then
                echo "⚠️  File may not be fully propagated yet"
                echo "💡 Try the URL in a few seconds"
            else
                echo "⚠️  Public access may need configuration (HTTP $http_status)"
                echo "💡 Enable with: wrangler r2 bucket dev-url enable $bucket_name"
            fi
        else
            echo "🔗 File uploaded to: $bucket_name/$custom_name"
            echo "💡 Configure R2 public access:"
            echo "   cfpublic $bucket_name"
            echo "📋 Copying object path to clipboard..."
            echo "$bucket_name/$custom_name" | pbcopy
        fi
    fi
}

# Download file from R2 bucket
cfdownload_function() {
    _cf_ensure_setup || return 1
    
    local remote_path="$1"
    local local_path="$2"
    local bucket_name="${3:-files}"
    
    if [[ -z "$remote_path" ]]; then
        echo "Usage: cfdownload REMOTE_PATH [LOCAL_PATH] [BUCKET_NAME]"
        echo ""
        echo "Examples:"
        echo "  cfdownload image.jpg"
        echo "  cfdownload folder/file.pdf ~/Downloads/"
        echo "  cfdownload doc.txt ~/Documents/doc.txt"
        return 1
    fi
    
    # Set local path if not provided
    if [[ -z "$local_path" ]]; then
        local_path="./$(basename "$remote_path")"
    fi
    
    echo "📥 Downloading $remote_path from R2 bucket: $bucket_name"
    
    if wrangler r2 object get "$bucket_name/$remote_path" --file="$local_path"; then
        echo "✅ Download successful: $local_path"
    else
        echo "❌ Download failed"
        return 1
    fi
}

# List files in R2 bucket
cffiles_function() {
    _cf_ensure_setup || return 1
    
    local bucket_name="${1:-files}"
    local prefix="$2"
    
    echo "📁 Listing files in R2 bucket: $bucket_name"
    
    if [[ -n "$prefix" ]]; then
        echo "🔍 Prefix filter: $prefix"
        wrangler r2 object list "$bucket_name" --prefix="$prefix"
    else
        wrangler r2 object list "$bucket_name"
    fi
}

# Delete file from R2 bucket
cfdelete_function() {
    _cf_ensure_setup || return 1
    
    local remote_path="$1"
    local bucket_name="${2:-files}"
    
    if [[ -z "$remote_path" ]]; then
        echo "Usage: cfdelete REMOTE_PATH [BUCKET_NAME]"
        echo ""
        echo "Examples:"
        echo "  cfdelete image.jpg"
        echo "  cfdelete folder/file.pdf"
        return 1
    fi
    
    echo "🗑️  Deleting $remote_path from R2 bucket: $bucket_name"
    echo "⚠️  This action cannot be undone!"
    echo -n "Continue? (y/N): "
    read -r confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        if wrangler r2 object delete "$bucket_name/$remote_path"; then
            echo "✅ File deleted successfully"
        else
            echo "❌ Delete failed"
            return 1
        fi
    else
        echo "❌ Delete cancelled"
    fi
}

# ============================================
# Cloudflare Pages Functions
# ============================================

# Initialize Cloudflare Pages project for public files
cfpage-init() {
    echo "🚀 Initializing Cloudflare Pages for public file sharing..."
    
    local public_dir="$HOME/public-files"
    
    # Create public files directory if it doesn't exist
    if [[ ! -d "$public_dir" ]]; then
        mkdir -p "$public_dir"
        echo "📁 Created directory: $public_dir"
    fi
    
    cd "$public_dir" || return 1
    
    # Check if Pages project exists
    if ! npx wrangler pages project list 2>/dev/null | grep -q "public-files"; then
        echo "📦 Creating Pages project..."
        npx wrangler pages project create public-files --production-branch main
    else
        echo "✅ Pages project already exists"
    fi
    
    # Deploy current files
    echo "🌐 Deploying to Pages..."
    npx wrangler pages deploy . --project-name public-files
    
    echo ""
    echo "✨ Pages setup complete!"
    echo "📍 Your public URL will be shown after deployment"
    cd - > /dev/null
}

# Upload file to Cloudflare Pages
cfpage-upload() {
    local file="$1"
    
    if [[ -z "$file" ]]; then
        echo "Usage: cfpage-upload FILE"
        echo ""
        echo "Examples:"
        echo "  cfpage-upload document.pdf"
        echo "  cfpage-upload ~/Downloads/image.png"
        return 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo "❌ File not found: $file"
        return 1
    fi
    
    local public_dir="$HOME/public-files"
    local filename=$(basename "$file")
    
    # Copy file to public directory
    cp "$file" "$public_dir/$filename"
    
    # Update files.json
    cd "$public_dir" || return 1
    
    # Create or update files.json
    if [[ -f "files.json" ]]; then
        # Add new file to existing list
        local temp_json=$(mktemp)
        jq --arg name "$filename" --arg size "$(ls -lh "$filename" | awk '{print $5}')" \
           '. + [{"name": $name, "size": $size}] | unique_by(.name) | reverse' \
           files.json > "$temp_json" && mv "$temp_json" files.json
    else
        # Create new files.json
        jq -n --arg name "$filename" --arg size "$(ls -lh "$filename" | awk '{print $5}')" \
           '[{"name": $name, "size": $size}]' > files.json
    fi
    
    # Deploy to Pages
    echo "🚀 Deploying to Cloudflare Pages..."
    local deploy_output=$(npx wrangler pages deploy . --project-name public-files 2>&1)
    local url=$(echo "$deploy_output" | grep -o 'https://[^[:space:]]*pages\.dev' 2>/dev/null | head -1)
    
    if [[ -z "$url" ]]; then
        url="https://public-files-5kg.pages.dev"
    fi
    
    echo ""
    echo "✅ File uploaded successfully!"
    echo "🔗 Public URL: $url/$filename"
    echo ""
    echo "📋 URL copied to clipboard"
    echo "$url/$filename" | pbcopy
    
    cd - > /dev/null
}

# Take screenshot and upload to Pages
cfpage-shot() {
    local public_dir="$HOME/public-files"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local filename="screenshot_${timestamp}.png"
    local temp_file="/tmp/$filename"
    
    echo "📸 Taking screenshot..."
    echo "Press Cmd+Shift+4 and select area to capture"
    
    # Take screenshot
    screencapture -i "$temp_file"
    
    if [[ ! -f "$temp_file" ]]; then
        echo "❌ Screenshot cancelled"
        return 1
    fi
    
    # Upload using cfpage-upload
    cfpage-upload "$temp_file"
    
    # Clean up
    rm "$temp_file"
}

# List files on Pages
cfpage-list() {
    local public_dir="$HOME/public-files"
    
    if [[ -f "$public_dir/files.json" ]]; then
        echo "📁 Files on Cloudflare Pages:"
        echo ""
        jq -r '.[] | "  📄 \(.name) (\(.size))"' "$public_dir/files.json"
        echo ""
        echo "🔗 Public URL: https://public-files-5kg.pages.dev"
    else
        echo "📭 No files uploaded yet"
        echo "Use 'cfpage-upload FILE' to upload files"
    fi
}

# Password-protected file upload
cfprotect_function() {
    local file_path="$1"
    local password="$2"
    
    if [[ -z "$file_path" ]] || [[ -z "$password" ]]; then
        echo "Usage: cfprotect FILE PASSWORD"
        echo "   or: cfpu FILE -p PASSWORD"
        echo ""
        echo "Examples:"
        echo "  cfprotect secret.pdf mypassword123"
        echo "  cfpu confidential.doc -p 'complex pass phrase'"
        return 1
    fi
    
    if [[ ! -f "$file_path" ]]; then
        echo "❌ File not found: $file_path"
        return 1
    fi
    
    echo "🔐 Uploading password-protected file..."
    
    # Ensure protected-files bucket exists
    if ! wrangler r2 bucket list 2>/dev/null | grep -q "protected-files"; then
        echo "📦 Creating protected-files bucket..."
        wrangler r2 bucket create protected-files 2>/dev/null
    fi
    
    # Generate password hash
    local password_hash=$(echo -n "$password" | shasum -a 256 | awk '{print $1}')
    local filename=$(basename "$file_path")
    local timestamp=$(date +%s)
    local protected_name="${timestamp}_${filename}"
    
    # Upload file with password hash in metadata
    echo "📤 Uploading to protected storage..."
    if wrangler r2 object put "protected-files/$protected_name" \
        --file="$file_path" \
        --custom-metadata="passwordHash=$password_hash" 2>/dev/null; then
        
        # Deploy the worker if not already deployed
        if ! wrangler deployments list --name="protected-files" 2>/dev/null | grep -q "protected-files"; then
            echo "🚀 Deploying password protection worker..."
            wrangler deploy --config wrangler-protected.toml 2>/dev/null
        fi
        
        # Get the worker URL
        local worker_url="https://protected-files.${USER}.workers.dev"
        local protected_url="${worker_url}/${protected_name}"
        
        echo ""
        echo "✅ Password-protected file uploaded!"
        echo "🔗 Protected URL: $protected_url"
        echo "🔑 Password: $password"
        echo ""
        echo "📋 URL copied to clipboard"
        echo "$protected_url" | pbcopy
        
        # Save to a local log for reference
        echo "$(date): $protected_name | Password: [hidden] | URL: $protected_url" >> ~/.cf-protected-files.log
        
        echo ""
        echo "💡 Share the URL and password separately for security"
        echo "📝 Upload logged to ~/.cf-protected-files.log"
    else
        echo "❌ Upload failed"
        return 1
    fi
}

# Enhanced cfpage-upload with password protection option
cfpu_enhanced() {
    local file_path=""
    local password=""
    local public=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--password)
                password="$2"
                public=false
                shift 2
                ;;
            *)
                file_path="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$file_path" ]]; then
        echo "Usage: cfpu FILE [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  -p, --password PASSWORD    Password-protect the file"
        echo ""
        echo "Examples:"
        echo "  cfpu document.pdf                    # Public upload"
        echo "  cfpu secret.pdf -p mypassword       # Password-protected"
        return 1
    fi
    
    if [[ "$public" == true ]]; then
        # Regular public upload
        cfpage-upload "$file_path"
    else
        # Password-protected upload
        cfprotect_function "$file_path" "$password"
    fi
}

# Quick screenshot upload to Cloudflare
cfshot_function() {
    _cf_ensure_setup || return 1
    
    local filename="${1:-screenshot_$(date +%Y%m%d_%H%M%S).png}"
    local is_public="${2:-public}"  # Default to public
    local temp_file="/tmp/$filename"
    
    echo "📸 Taking screenshot..."
    
    # Take screenshot and save to temp file
    screencapture -i "$temp_file"
    
    if [[ -f "$temp_file" ]]; then
        echo "✅ Screenshot captured"
        
        # Choose bucket based on privacy setting
        if [[ "$is_public" == "private" ]]; then
            echo "🔒 Uploading as PRIVATE (no public URL)"
            cfupload "$temp_file" "screenshots-private" "$filename"
        else
            echo "🌍 Uploading as PUBLIC (shareable URL)"
            cfupload "$temp_file" "screenshots-public" "$filename"
        fi
        
        # Clean up temp file
        rm "$temp_file"
    else
        echo "❌ Screenshot cancelled or failed"
        return 1
    fi
}

# Public screenshot (default)
cfshot-public() {
    cfshot_function "$1" "public"
}

# Private screenshot
cfshot-private() {
    cfshot_function "$1" "private"
}

# Backup current dotfiles to R2
cfbackup_function() {
    _cf_ensure_setup || return 1
    
    local backup_name="${1:-dotfiles_$(date +%Y%m%d_%H%M%S).tar.gz}"
    local temp_file="/tmp/$backup_name"
    
    echo "💾 Creating dotfiles backup..."
    
    # Create compressed archive of dotfiles
    if tar -czf "$temp_file" -C "$HOME" \
        .zshrc .zsh_* .env .gitconfig .ssh/config \
        2>/dev/null; then
        
        echo "✅ Backup archive created"
        cfupload "$temp_file" "backups" "$backup_name"
        
        # Clean up temp file
        rm "$temp_file"
    else
        echo "❌ Backup creation failed"
        return 1
    fi
}

# Setup public/private bucket structure
cfsetup-buckets() {
    echo "🔧 Setting up public/private bucket structure..."
    echo ""
    
    # Public buckets (with dev URL enabled)
    local public_buckets=("files-public" "screenshots-public" "images-public")
    
    # Private buckets (no public access)
    local private_buckets=("files-private" "screenshots-private" "backups-private" "secrets")
    
    echo "📦 Creating PUBLIC buckets..."
    for bucket in "${public_buckets[@]}"; do
        if wrangler r2 bucket create "$bucket" 2>/dev/null; then
            echo "  ✅ Created: $bucket"
            echo "  🌍 Enabling public access..."
            wrangler r2 bucket dev-url enable "$bucket" 2>/dev/null
        else
            echo "  ⚠️  Bucket $bucket already exists"
        fi
    done
    
    echo ""
    echo "🔒 Creating PRIVATE buckets..."
    for bucket in "${private_buckets[@]}"; do
        if wrangler r2 bucket create "$bucket" 2>/dev/null; then
            echo "  ✅ Created: $bucket (private)"
        else
            echo "  ⚠️  Bucket $bucket already exists"
        fi
    done
    
    echo ""
    echo "✅ Bucket setup complete!"
    echo ""
    echo "📋 Usage:"
    echo "  Public uploads:  cfu file.pdf files-public"
    echo "  Private uploads: cfu file.pdf files-private"
    echo "  Public shots:    cfshot or cfsp"
    echo "  Private shots:   cfshot-private or cfspriv"
}

# Comprehensive Cloudflare status and info
cfinfo_function() {
    _cf_ensure_setup || return 1
    
    echo "📊 Cloudflare Integration Status"
    echo "=================================="
    echo ""
    
    # Authentication status
    echo "🔐 Authentication:"
    local whoami_output=$(wrangler whoami 2>/dev/null)
    if [[ -n "$whoami_output" ]]; then
        echo "  ✅ Authenticated"
        echo "$whoami_output" | sed 's/^/  /'
        
        local account_id=$(echo "$whoami_output" | grep -o "Account ID: [a-f0-9]*" | cut -d' ' -f3)
        if [[ -n "$account_id" ]]; then
            echo ""
            echo "🌐 R2 Public URL Format:"
            echo "  • https://pub-${account_id}.r2.dev/filename"
        fi
    else
        echo "  ❌ Not authenticated"
        echo "  💡 Run: wrangler login"
    fi
    
    echo ""
    echo "🚀 Worker Status:"
    if wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "  ✅ Worker 'macos-dotfiles-secrets' deployed"
        echo "  🔗 Secrets management: Available"
    else
        echo "  ❌ Worker not deployed"
        echo "  💡 Deploy with: cfdeploy"
    fi
    
    echo ""
    echo "📦 R2 Buckets:"
    local buckets=$(wrangler r2 bucket list 2>/dev/null)
    if [[ -n "$buckets" ]]; then
        echo "$buckets" | sed 's/^/  ✅ /'
    else
        echo "  ❌ No buckets found"
        echo "  💡 Buckets will be created automatically when needed"
    fi
    
    echo ""
    echo "⚡ Quick Commands:"
    echo "  cfshot    - Screenshot → upload → share"
    echo "  cfu FILE  - Upload any file"
    echo "  cfbak     - Backup dotfiles"
    echo "  cflist    - List secrets (deploys worker if needed)"
    echo "  cfpublic BUCKET - Enable public access"
}

# Configure R2 bucket for public access
cfpublic_bucket() {
    _cf_ensure_setup || return 1
    
    local bucket_name="${1}"
    
    if [[ -z "$bucket_name" ]]; then
        echo "Usage: cfpublic BUCKET_NAME"
        echo ""
        echo "Available buckets:"
        wrangler r2 bucket list 2>/dev/null | grep "name:" | awk '{print "  - " $2}'
        echo ""
        echo "Examples:"
        echo "  cfpublic screenshots"
        echo "  cfpublic files"
        return 1
    fi
    
    echo "🌍 Enabling public access for bucket: $bucket_name"
    
    # Enable R2 dev URL for public access
    if wrangler r2 bucket dev-url enable "$bucket_name" 2>/dev/null; then
        echo "✅ Public access enabled for: $bucket_name"
        
        # Get account ID and show the public URL format
        local account_id=$(wrangler whoami 2>&1 | sed -n 's/.*│ \([a-f0-9]\{32\}\).*/\1/p')
        if [[ -n "$account_id" ]]; then
            echo "🔗 Public URL format: https://pub-${account_id}.r2.dev/<filename>"
            echo ""
            echo "📋 Example URL for files in this bucket:"
            echo "   https://pub-${account_id}.r2.dev/example.png"
        fi
    else
        echo "❌ Failed to enable public access"
        echo "💡 You may need to configure it manually in the dashboard:"
        echo "   https://dash.cloudflare.com → R2 → $bucket_name → Settings"
    fi
}

# Troubleshoot and fix common issues
cffix() {
    echo "🔧 Cloudflare Integration Troubleshooter"
    echo "========================================"
    echo ""
    
    # Check directory
    echo "📁 Checking directory..."
    if [[ ! -f "package.json" ]] || ! grep -q "wrangler" package.json 2>/dev/null; then
        echo "  ❌ Not in wrangler project directory"
        local dotfiles_dir="$HOME/Git/dotfiles/macos"
        if [[ -f "$dotfiles_dir/package.json" ]]; then
            echo "  🔄 Switching to dotfiles directory..."
            cd "$dotfiles_dir"
            echo "  ✅ Now in: $(pwd)"
        else
            echo "  ❌ Cannot find dotfiles directory"
            return 1
        fi
    else
        echo "  ✅ In correct directory: $(pwd)"
    fi
    
    # Check dependencies
    echo ""
    echo "📦 Checking dependencies..."
    if [[ ! -d "node_modules" ]]; then
        echo "  ❌ Dependencies not installed"
        echo "  🔄 Installing..."
        npm install --silent
        echo "  ✅ Dependencies installed"
    else
        echo "  ✅ Dependencies installed"
    fi
    
    # Check authentication
    echo ""
    echo "🔐 Checking authentication..."
    if ! wrangler whoami &>/dev/null 2>&1; then
        echo "  ❌ Not authenticated"
        echo "  🔄 Starting authentication..."
        wrangler login
    else
        echo "  ✅ Authenticated"
    fi
    
    # Check worker deployment
    echo ""
    echo "🚀 Checking worker deployment..."
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "  ❌ Worker not deployed"
        echo "  🔄 Deploying worker..."
        if wrangler deploy; then
            echo "  ✅ Worker deployed successfully"
        else
            echo "  ❌ Worker deployment failed"
        fi
    else
        echo "  ✅ Worker deployed"
    fi
    
    # Check R2 buckets
    echo ""
    echo "📦 Checking R2 buckets..."
    local bucket_count=$(wrangler r2 bucket list 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$bucket_count" -eq 0 ]]; then
        echo "  ⚠️  No R2 buckets found"
        echo "  💡 Buckets will be created when needed"
    else
        echo "  ✅ Found $bucket_count R2 buckets"
    fi
    
    echo ""
    echo "🎉 Troubleshooting complete!"
    echo "💡 Try: cfinfo to see current status"
}

# Generate temporary signed URL for private files (valid for 1 hour)
cfsign() {
    local file_path="$1"
    local bucket_name="${2:-files-private}"
    local duration="${3:-3600}"  # Default 1 hour
    
    if [[ -z "$file_path" ]]; then
        echo "Usage: cfsign FILE_PATH [BUCKET_NAME] [DURATION_SECONDS]"
        echo ""
        echo "Examples:"
        echo "  cfsign document.pdf                    # 1 hour access"
        echo "  cfsign image.jpg screenshots-private   # From specific bucket"
        echo "  cfsign file.zip files-private 86400    # 24 hour access"
        return 1
    fi
    
    echo "🔐 Generating signed URL for: $bucket_name/$file_path"
    echo "⏱️  Valid for: $duration seconds"
    
    # Generate presigned URL using wrangler (requires Worker implementation)
    local account_id=$(wrangler whoami 2>/dev/null | grep -A1 "Account ID" | tail -1 | awk -F'│' '{print $3}' | xargs)
    
    if [[ -n "$account_id" ]]; then
        # For now, show the private object path
        echo "🔗 Private object: $bucket_name/$file_path"
        echo "💡 Signed URLs require Worker implementation"
        echo "   Alternative: Use cftemp to create temporary public copy"
    fi
}

# Share file temporarily using Cloudflare Pages
cftemp_function() {
    local source_path="$1"
    local duration_hours="${2:-24}"
    
    if [[ -z "$source_path" ]]; then
        echo "Usage: cftemp FILE_PATH [HOURS]"
        echo ""
        echo "Examples:"
        echo "  cftemp document.pdf      # Share for 24 hours"
        echo "  cftemp image.jpg 1       # Share for 1 hour"
        return 1
    fi
    
    if [[ ! -f "$source_path" ]]; then
        echo "❌ File not found: $source_path"
        return 1
    fi
    
    echo "📤 Creating temporary public share..."
    
    # Generate temporary filename with expiry timestamp
    local timestamp=$(date +%s)
    local expiry=$((timestamp + (duration_hours * 3600)))
    local filename=$(basename "$source_path")
    local temp_name="temp_${expiry}_${filename}"
    local public_dir="$HOME/public-files"
    
    # Copy file to public directory with temp name
    cp "$source_path" "$public_dir/$temp_name"
    
    # Update files.json
    cd "$public_dir" || return 1
    if [[ -f "files.json" ]]; then
        local temp_json=$(mktemp)
        jq --arg name "$temp_name" --arg size "$(ls -lh "$temp_name" | awk '{print $5}')" \
           --arg expires "Expires in ${duration_hours}h" \
           '. + [{"name": $name, "size": $size, "expires": $expires}] | unique_by(.name) | reverse' \
           files.json > "$temp_json" && mv "$temp_json" files.json
    else
        jq -n --arg name "$temp_name" --arg size "$(ls -lh "$temp_name" | awk '{print $5}')" \
           --arg expires "Expires in ${duration_hours}h" \
           '[{"name": $name, "size": $size, "expires": $expires}]' > files.json
    fi
    
    # Deploy to Pages
    echo "🚀 Deploying to Cloudflare Pages..."
    npx wrangler pages deploy . --project-name public-files >/dev/null 2>&1
    
    local public_url="https://public-files-5kg.pages.dev/$temp_name"
    
    echo "✅ Temporary share created!"
    echo "🔗 Public URL: $public_url"
    echo "⏰ Expires in: $duration_hours hours"
    echo "📋 URL copied to clipboard"
    echo "$public_url" | pbcopy
    
    echo ""
    echo "💡 Remember to clean up expired shares with: cfclean"
    
    cd - > /dev/null
}

# Clean up expired temporary shares from Pages
cfclean_function() {
    echo "🧹 Cleaning up expired temporary shares..."
    
    local public_dir="$HOME/public-files"
    local current_time=$(date +%s)
    local cleaned=0
    
    cd "$public_dir" || return 1
    
    # Check each temp file
    for file in temp_*; do
        if [[ -f "$file" ]]; then
            # Extract expiry time from filename
            if [[ "$file" =~ temp_([0-9]+)_ ]]; then
                local expiry="${BASH_REMATCH[1]}"
                if [[ "$current_time" -gt "$expiry" ]]; then
                    echo "🗑️  Removing expired: $file"
                    rm "$file"
                    ((cleaned++))
                fi
            fi
        fi
    done
    
    # Update files.json to remove expired entries
    if [[ -f "files.json" ]] && [[ $cleaned -gt 0 ]]; then
        local temp_json=$(mktemp)
        jq '[.[] | select(.name | test("^temp_") | not)]' files.json > "$temp_json" 2>/dev/null || echo "[]" > "$temp_json"
        
        # Add back non-expired temp files
        for file in temp_*; do
            if [[ -f "$file" ]]; then
                jq --arg name "$file" --arg size "$(ls -lh "$file" | awk '{print $5}')" \
                   '. + [{"name": $name, "size": $size}]' "$temp_json" > "${temp_json}.new" && \
                   mv "${temp_json}.new" "$temp_json"
            fi
        done
        
        mv "$temp_json" files.json
        
        # Redeploy if we cleaned anything
        echo "🚀 Redeploying to update Pages..."
        npx wrangler pages deploy . --project-name public-files >/dev/null 2>&1
    fi
    
    echo "✅ Cleanup complete. Removed $cleaned expired files."
    cd - > /dev/null
}

# ============================================
# Cloudflare Aliases - Short Commands
# ============================================

# Core Wrangler functions
alias cfsync=cfsync_function      # Sync secrets from .env
alias cfs=cfsync_function         # Short alias for sync
alias cfget=cfget_function        # Get a secret value  
alias cfg=cfget_function          # Short alias for get
alias cflist=_cflist_function     # List all secrets
alias cfdeploy=cfdeploy_function  # Deploy worker to production
alias cfd=cfdeploy_function       # Short alias for deploy
alias cfinfo=cfinfo_function      # Show Cloudflare setup info

# R2 Storage functions
alias cfupload=cfupload_function      # Upload file to R2 bucket
alias cfu=cfupload_function           # Short: upload
alias cfdownload=cfdownload_function  # Download file from R2 bucket
alias cfdown=cfdownload_function      # Short: download
alias cffiles=cffiles_function        # List files in R2 bucket
alias cfls=cffiles_function           # Short: list files
alias cff=cffiles_function            # Even shorter: files
alias cfdelete=cfdelete_function      # Delete file from R2 bucket
alias cfrm=cfdelete_function          # Short: remove
alias cfbackup=cfbackup_function      # Backup local directory to R2
alias cfbak=cfbackup_function         # Short: backup

# Tunnel functions
alias cftunnel=cftunnel_function      # Cloudflare tunnel
alias funnel=funnel_function          # Tailscale funnel

# Screenshot functions
alias cfshot=cfshot_function      # Main screenshot function
alias cfscreen=cfshot_function    # Alias for cfshot
alias cfss=cfshot_function        # Short alias for screenshot

# Public file sharing (Pages)
alias cfpublic=cfpage-upload    # Upload file for public access
alias cfpu=cfpu_enhanced        # Enhanced upload with password option
alias cfshare=cfpage-upload      # Share file publicly
alias cfprotect=cfprotect_function  # Password-protected upload
alias cfps=cfpage-shot           # Screenshot to public Pages
alias cfpscreen=cfpage-shot      # Public screenshot
alias cfpl=cfpage-list           # List public files
alias cfpls=cfpage-list          # List public files (alt)

# Temporary sharing
alias cftemp=cftemp_function     # Create temporary share link
alias cftmp=cftemp_function      # Short alias for temp share
alias cfclean=cfclean_function   # Clean expired temp shares

# Database functions (when configured)
alias cfdb=cfd1               # D1 database operations
# cfkv would be defined when KV is configured

# Help and setup
cfhelp_function() {
    echo "
🚀 Cloudflare Quick Commands:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📤 UPLOAD & SHARE:
  cfpublic FILE   - Share file publicly via Pages
  cfu FILE        - Upload to private R2 bucket  
  cftemp FILE     - Create temporary share link
  
📸 SCREENSHOTS:
  cfshot          - Screenshot to private R2
  cfps            - Screenshot to public Pages
  
📁 FILE MANAGEMENT:
  cfls            - List files in R2 bucket
  cfpl            - List public files on Pages
  cfdown FILE     - Download from R2 bucket
  cfrm FILE       - Delete from R2 bucket
  
🔐 SECRETS:
  cfs             - Sync secrets from .env
  cfg KEY         - Get secret value
  cflist          - List all secrets
  
🛠️  DEVELOPMENT:
  cfdev           - Start local dev server
  cfd             - Deploy to production
  cflog           - View worker logs
  
💡 Type cfhelp or cf for this help menu
"
}

# Even shorter aliases for most common operations
alias cfhelp=cfhelp_function     # Help function
alias cf=cfhelp_function          # Show help

restore_original_mac() {
    local interface_input="$1"
    local interface_name
    
    # If interface is provided, convert friendly name to device name if needed
    if [[ -n "$interface_input" ]]; then
        if [[ "$interface_input" == "Wi-Fi" || "$interface_input" == "wifi" || "$interface_input" == "WIFI" ]]; then
            # Look up the device name for Wi-Fi
            interface_name=$(networksetup -listallhardwareports | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')
            echo "Converting Wi-Fi to device name: $interface_name"
        elif [[ "$interface_input" =~ ^en[0-9]+$ ]]; then
            # Already a device name
            interface_name="$interface_input"
        else
            # Try to find the device name for the given hardware port
            interface_name=$(networksetup -listallhardwareports | grep -A 1 "$interface_input" | grep "Device:" | awk '{print $2}')
            if [[ -z "$interface_name" ]]; then
                echo "Error: Could not find device name for '$interface_input'"
                echo "Available interfaces:"
                networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
                return 1
            fi
            echo "Converting '$interface_input' to device name: $interface_name"
        fi
    # If no interface specified, show available ones with saved MACs
    else
        local saved_interfaces=()
        for file in "$HOME"/.mac_*; do
            if [[ -f "$file" ]]; then
                saved_interfaces+=($(basename "$file" | sed 's/^.mac_//'))
            fi
        done
        
        if [[ ${#saved_interfaces[@]} -eq 0 ]]; then
            echo "No interfaces found with saved original MAC addresses."
            return 1
        fi
        
        echo "Select an interface to restore original MAC address:"
        select interface_name in "${saved_interfaces[@]}"; do
            if [[ -n "$interface_name" ]]; then
                break
            else
                echo "Invalid selection. Please try again."
            fi
        done
    fi
    
    # Check if we have a saved MAC for this interface
    local mac_file="$HOME/.mac_$interface_name"
    if [[ ! -f "$mac_file" ]]; then
        echo "No saved original MAC address found for $interface_name"
        return 1
    fi
    
    # Get the original MAC address
    local original_mac
    original_mac=$(cat "$mac_file")
    
    echo "Restoring original MAC address ($original_mac) for $interface_name..."
    
    # Use our change_mac_address function to do the actual change
    if change_mac_address "$original_mac" "$interface_name"; then
        echo "Original MAC address successfully restored"
        rm "$mac_file"  # Remove the saved file since we've restored the original
        return 0
    else
        echo "Failed to restore original MAC address"
        return 1
    fi
}