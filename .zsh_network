# ----------------------
# Network Functions and Aliases
# ----------------------

# Unalias any existing Cloudflare aliases to prevent conflicts when re-sourcing
for cmd in cftemp cfclean cfhelp cfinfo cfshot cfdev cfsync cfget cfdeploy cfupload cfdownload cffiles cfdelete cfbackup cftunnel funnel; do
  unalias $cmd 2>/dev/null || true
done

# Network diagnostics
alias ports='netstat -tulanp'  # List open ports
alias myip='curl ifconfig.me'  # Check external IP address
alias http="curl -I"           # Check HTTP headers

# lookup your public IP via multiple services
check_ip() {
    for svc in ifconfig.me ipinfo.io/ip; do
        echo -n "$svc ‚Üí " && curl -s "$svc"
    done
}

# flush DNS cache
flushdns() {
    # flush DNS cache -  can be helpful when you have a new IP address
    sudo killall -HUP mDNSResponder
}

# faster DNS lookup with caching
digc() {
    # flush DNS cache
    flushdns
    
    # if no arg is passed use default google DNS if arg is passed use that arg
    if [[ -z "$1" ]]; then
        dig @8.8.8.8
    else
        # Use array to prevent word splitting issues
        local args=("$@")
        dig "${args[@]}"
    fi
}

# quick ping summary
pings() {
    if [[ -z "$1" ]]; then
        echo "Usage: pings hostname [count]"
        return 1
    fi
    ping -c "${2:-5}" "$1" | tail -2
}

# MAC address management
gen_mac_addr() {
    local mac
    mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

show_current_mac() {
    local interface_input="$1"
    local interface_name
    
    if [[ -z "$interface_input" ]]; then
        echo "Usage: show_current_mac <device_name>"
        echo "Available interfaces:"
        networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
        return 1
    fi
    
    # Convert friendly name to device name if needed
    if [[ "$interface_input" == "Wi-Fi" || "$interface_input" == "wifi" || "$interface_input" == "WIFI" ]]; then
        # Look up the device name for Wi-Fi
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')
        echo "Converting Wi-Fi to device name: $interface_name"
    elif [[ "$interface_input" =~ ^en[0-9]+$ ]]; then
        # Already a device name
        interface_name="$interface_input"
    else
        # Try to find the device name for the given hardware port
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "$interface_input" | grep "Device:" | awk '{print $2}')
        if [[ -z "$interface_name" ]]; then
            echo "Error: Could not find device name for '$interface_input'"
            echo "Available interfaces:"
            networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
            return 1
        fi
        echo "Converting '$interface_input' to device name: $interface_name"
    fi
    
    networksetup -getmacaddress "$interface_name"
}

change_mac_address() {
    local mac_address="$1"
    local interface_input="$2"
    local interface_name
    
    # Generate random MAC if none provided
    if [[ -z "$mac_address" ]]; then
        mac_address=$(gen_mac_addr)
        echo "No MAC address provided. Using generated MAC: $mac_address"
    fi
    
    # Check if interface name is provided
    if [[ -z "$interface_input" ]]; then
        echo "No interface name provided. Available interfaces:"
        networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
        echo "Usage: change_mac_address <mac_address> <interface_name>"
        return 1
    fi
    
    # Convert friendly name to device name if needed
    if [[ "$interface_input" == "Wi-Fi" || "$interface_input" == "wifi" || "$interface_input" == "WIFI" ]]; then
        # Look up the device name for Wi-Fi
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')
        echo "Converting Wi-Fi to device name: $interface_name"
    elif [[ "$interface_input" =~ ^en[0-9]+$ ]]; then
        # Already a device name
        interface_name="$interface_input"
    else
        # Try to find the device name for the given hardware port
        interface_name=$(networksetup -listallhardwareports | grep -A 1 "$interface_input" | grep "Device:" | awk '{print $2}')
        if [[ -z "$interface_name" ]]; then
            echo "Error: Could not find device name for '$interface_input'"
            echo "Available interfaces:"
            networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
            return 1
        fi
        echo "Converting '$interface_input' to device name: $interface_name"
    fi
    
    # Get current MAC for this interface
    local current_info
    current_info=$(networksetup -getmacaddress "$interface_name" 2>/dev/null)
    
    # Check if the interface exists
    if [[ $? -ne 0 || "$current_info" == *"does not exist"* ]]; then
        echo "Error: Interface $interface_name not found."
        return 1
    fi
    
    # Extract current MAC address
    local current_mac
    current_mac=$(echo "$current_info" | awk '{print $3}')
    
    # Save original MAC if not already saved
    local mac_file="$HOME/.mac_$interface_name"
    if [[ ! -f "$mac_file" ]]; then
        echo "$current_mac" > "$mac_file"
        echo "Original MAC address saved: $current_mac"
    fi
    
    # Change MAC address
    echo "Changing MAC address for $interface_name to $mac_address..."
    
    # Turn off the interface
    echo "Disabling interface..."
    sudo ifconfig "$interface_name" down
    
    # Set the new MAC address
    sudo ifconfig "$interface_name" ether "$mac_address"
    
    # Turn the interface back on
    echo "Re-enabling interface..."
    sudo ifconfig "$interface_name" up
    
    # Verify the change
    local new_mac
    new_mac=$(ifconfig "$interface_name" | grep ether | awk '{print $2}')
    
    if [[ "$new_mac" == "$mac_address" ]]; then
        echo "MAC address successfully changed to $mac_address"
        return 0
    else
        echo "Failed to change MAC address. Current MAC is $new_mac"
        return 1
    fi
}

change_mac_menu() {
    local choice mac_address interface_name
    
    # First show available interfaces
    echo "Available network interfaces:"
    networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
    echo ""
    echo "You can use either the device name (e.g., en0) or the friendly name (e.g., Wi-Fi)"
    echo ""
    
    echo "Choose an option:"
    echo "0. Show current MAC address"
    echo "1. Set a specific MAC address"
    echo "2. Set a random MAC address"
    echo "3. Restore original MAC address"
    echo -n "Enter your choice (0/1/2/3): "
    read -r choice

    case $choice in
        0)
            echo -n "Enter interface name (e.g., en0 or Wi-Fi): "
            read -r interface_name
            show_current_mac "$interface_name"
            ;;
        1)
            echo -n "Enter the new MAC address (e.g., E6:B8:BA:D2:41:07): "
            read -r mac_address
            echo -n "Enter the interface name (e.g., en0 or Wi-Fi): "
            read -r interface_name
            change_mac_address "$mac_address" "$interface_name"
            ;;
        2)
            echo -n "Enter the interface name (e.g., en0 or Wi-Fi): "
            read -r interface_name
            mac_address=$(gen_mac_addr)
            change_mac_address "$mac_address" "$interface_name"
            ;;
        3)
            echo -n "Enter the interface name to restore (press enter to see available): "
            read -r interface_name
            restore_original_mac "$interface_name"
            ;;
        *)
            echo "Invalid choice. Exiting."
            return 1
            ;;
    esac
}

analyze_network_traffic() {
    local help=false pcap_file=""
    # Analysis flags
    local want_top=false want_proto=false want_io=false want_http=false
    local want_dns=false want_tls=false want_expert=false want_resp=false
    local export_fields=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)       help=true; shift ;;
            -f|--file)       pcap_file="$2"; shift 2 ;;
            -t|--top-talkers) want_top=true; shift ;;
            -p|--proto-hierarchy) want_proto=true; shift ;;
            -s|--io-stats)   want_io=true; shift ;;
            -H|--http)       want_http=true; shift ;;
            -D|--dns-summary) want_dns=true; shift ;;
            -L|--tls-handshake) want_tls=true; shift ;;
            -E|--expert)     want_expert=true; shift ;;
            -R|--response-times) want_resp=true; shift ;;
            -x|--export-fields) export_fields="$2"; shift 2 ;;
            *) echo "Unknown option: $1"; echo "Try: analyze_network_traffic -h"; return 1 ;;
        esac
    done

    # Help or missing file
    if $help || [[ -z "$pcap_file" ]]; then
        echo "Usage: analyze_network_traffic -f FILE [options]"
        echo
        echo "Options:"
        echo "  -f, --file FILE           PCAP file to analyze (required)"
        echo "  -t, --top-talkers         Show IP conversation stats"
        echo "  -p, --proto-hierarchy     Show protocol hierarchy"
        echo "  -s, --io-stats            Show packet I/O rates"
        echo "  -H, --http                Extract HTTP host/URI list"
        echo "  -D, --dns-summary         Summarize DNS qtypes/qclasses"
        echo "  -L, --tls-handshake       Count TLS handshake packets"
        echo "  -E, --expert              Show expert errors/warnings"
        echo "  -R, --response-times      Show DNS/HTTP response times"
        echo "  -x, --export-fields F1,F2 Export fields F1,F2,... as CSV"
        return 0
    fi

    # Validate file exists
    if [[ ! -f "$pcap_file" ]]; then
        echo "Error: PCAP file '$pcap_file' not found"
        return 1
    fi

    echo "Analyzing $pcap_file..."

    # Top Talkers (IP conversations)
    if $want_top; then
        echo "== Top Talkers =="
        tshark -r "$pcap_file" -q -z conv,ip      #  [oai_citation:11‚Ä°Wireshark Q&A](https://osqa-ask.wireshark.org/questions/6430/analyze-per-ip/?utm_source=chatgpt.com)
    fi

    # Protocol Hierarchy
    if $want_proto; then
        echo "== Protocol Hierarchy =="
        tshark -r "$pcap_file" -q -z io,phs        #  [oai_citation:12‚Ä°Chris Sanders](https://chrissanders.org/2018/05/large-captures2-proto-hierarchy/?utm_source=chatgpt.com)
    fi

    # I/O Statistics (per-second)
    if $want_io; then
        echo "== I/O Statistics =="
        tshark -r "$pcap_file" -q -z io,stat,1     #  [oai_citation:13‚Ä°Stack Overflow](https://stackoverflow.com/questions/14451599/how-to-save-tshark-statistics-in-variables?utm_source=chatgpt.com) [oai_citation:14‚Ä°GitHub](https://github.com/Cthfm/Azure/blob/main/packet-analysis/tshark-cheatsheet.md?utm_source=chatgpt.com)
    fi

    # HTTP Requests Extraction
    if $want_http; then
        echo "== HTTP Requests =="
        tshark -r "$pcap_file" -Y http.request \
               -T fields -e http.host -e http.request.uri  #  [oai_citation:15‚Ä°CellStream, Inc.](https://www.cellstream.com/2014/05/12/t-shark-usage-examples/?utm_source=chatgpt.com) [oai_citation:16‚Ä°Gist](https://gist.github.com/githubfoam/6c9e07f95c2eb03ec4ae9709252c713f?utm_source=chatgpt.com)
    fi

    # DNS Summary
    if $want_dns; then
        echo "== DNS Summary =="
        tshark -r "$pcap_file" -q -z dns,tree      #  [oai_citation:17‚Ä°Wireshark](https://www.wireshark.org/docs/man-pages/tshark.html?utm_source=chatgpt.com)
    fi

    # TLS Handshake Count
    if $want_tls; then
        echo "== TLS Handshakes =="
        tshark -r "$pcap_file" -Y tls.handshake \
               -q -z io,stat,0                    #  [oai_citation:18‚Ä°CLI Wiki](https://cli.wiki/TShark---Terminal-Wireshark-Network-Analyzer-Guide?utm_source=chatgpt.com)
    fi

    # Expert Info (errors/warnings)
    if $want_expert; then
        echo "== Expert Info =="
        tshark -r "$pcap_file" -q -z "expert,error"  #  [oai_citation:19‚Ä°Gist](https://gist.github.com/donovanrodriguez/87dacb99caefa56d98d7e35b7d4a2539?utm_source=chatgpt.com)
    fi

    # Service Response Times (DNS & HTTP)
    if $want_resp; then
        echo "== Response Times =="
        tshark -r "$pcap_file" -q -z srt,dns        #  [oai_citation:20‚Ä°Gist](https://gist.github.com/donovanrodriguez/87dacb99caefa56d98d7e35b7d4a2539?utm_source=chatgpt.com)
        tshark -r "$pcap_file" -q -z srt,http
    fi

    # CSV Field Export
    if [[ -n "$export_fields" ]]; then
        echo "== Exporting Fields: $export_fields =="
        # convert comma list to multiple -e args
        IFS=',' read -ra F <<< "$export_fields"
        tshark -r "$pcap_file" -T fields -E header=y -E separator=, "${F[@]/#/-e }"
    fi
}

capture_network_traffic() {
	local iface duration size count prefix filter help=false

	# Default prefix
	prefix="capture"

	# Parse options
	while [[ $# -gt 0 ]]; do
		case "$1" in
		-h|--help)
			help=true; shift
			;;
		-i|--interface)
			iface="$2"; shift 2
			;;
		-d|--duration)
			duration="$2"; shift 2
			;;
		-s|--size)
			size="$2"; shift 2
			;;
		-c|--count)
			count="$2"; shift 2
			;;
		-o|--prefix)
			prefix="$2"; shift 2
			;;
		-p|--filter)
			filter="$2"; shift 2
			;;
		*)
			echo "Unknown option: $1"
			echo "Use: capture_network_traffic --help"
			return 1
			;;
		esac
	done

	# Show help or error if interface missing
	if [[ "$help" == true ]] || [[ -z "$iface" ]]; then
		echo "Usage: capture_network_traffic -i interface [options]"
		echo "	-i, --interface IFACE    (required) e.g. en0"
		echo "	-d, --duration SEC       rotate every SEC seconds"
		echo "	-s, --size MB            rotate after MB megabytes"
		echo "	-c, --count N            keep up to N files"
		echo "	-o, --prefix PREFIX      filename prefix (default: capture)"
		echo "	-p, --filter BPF         e.g. 'port 443 and host 1.2.3.4'"
		echo "	-h, --help               show this message"
		return 0
	fi

	# Build timestamped filename
	local ts file cmd
	ts=$(date +%Y%m%d_%H%M%S)
	file="${prefix}_${ts}.pcap"

	# Assemble tcpdump command
	cmd=( sudo tcpdump -i "$iface" -s 0 -n -w "$file" )
	[[ -n "$size"     ]] && cmd+=( -C "$size" )       # size-based rotate  [oai_citation:8‚Ä°Kudithipudi](https://kudithipudi.org/2013/02/14/how-to-configure-tcpdump-to-rotate-capture-files-based-on-size/?utm_source=chatgpt.com)
	[[ -n "$duration" ]] && cmd+=( -G "$duration" )   # time-based rotate  [oai_citation:9‚Ä°discoveringsystems.com](https://discoveringsystems.com/how-to-rotate-packet-capture-files-using-tcpdump/?utm_source=chatgpt.com)
	[[ -n "$count"    ]] && cmd+=( -W "$count" )      # limit file count  [oai_citation:10‚Ä°Super User](https://superuser.com/questions/904786/tcpdump-rotate-capture-files-using-g-w-and-c?utm_source=chatgpt.com)
	[[ -n "$filter"   ]] && cmd+=( $filter )          # BPF filter  [oai_citation:11‚Ä°myF5](https://my.f5.com/manage/s/article/K65251607?utm_source=chatgpt.com)

	# Execute
	echo "Capturing on $iface ‚Üí $file"
	printf '‚Ä∫ %q ' "${cmd[@]}"
	echo
	"${cmd[@]}"
}


# Scan network ports
scan_ports() {
    local ip_or_host local_ip install_nmap
    
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    
    # if no ip_or_host is passed then use the router ip 
    if [[ -z "$1" ]]; then
        local_ip=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -n 1)
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    
    #check if package is installed
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed"
        echo -n "Do you want to install nmap? (y/n): " 
        read -r install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            brew install nmap
            echo "nmap installed, continuing with scan"
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn "$ip_or_host"
}

# Python HTTP server
pyserver() {
    local port=8000 local_ip file original_dir
    
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver file1 file2 ..."
        return 0
    fi
    
    # check if python3 is installed
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed"
        echo "You can install it with:"
        echo 'brew install python'
        return 1
    fi
    
    #get local ip
    local_ip=$(hostname -I | awk '{print $1}')
    original_dir=$(pwd)
    
    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    if [ -n "$1" ]; then
        # create temp dir
        mkdir -p /tmp/pyserver
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/pyserver/
        done
        # change dir to the temp dir
        cd /tmp/pyserver || return 1
    fi
    
    # start the python server
    python3 -m http.server "$port"
    
    # Return to original directory
    cd "$original_dir" || return 1
}

# Tailscale funnel for sharing files or services over the internet
funnel_function() {
    local port=${FUNNEL_PORT:-8080}
    local use_python=true
    local direct_service=false
    local target
    local server_pid
    local original_dir
    
    # Process options
    while [[ "$1" == -* ]]; do
        case "$1" in
            -h|--help)
                cat << 'EOF'
Usage: funnel [OPTIONS] [target]
Funnel enables you to share local files or services over the internet using Tailscale.

Options:
  -h, --help            Show this help message
  -d, --direct          Directly funnel to a port without using Python server
  -p, --port PORT       Specify port (default: 8080 or FUNNEL_PORT env variable)

Examples:
  funnel file.txt              # Share a file using Python HTTP server
  funnel -d -p 3000            # Directly funnel localhost:3000
  funnel -d redis://localhost:6379  # Directly funnel a Redis service
EOF
                return 0
                ;;
            -d|--direct)
                direct_service=true
                use_python=false
                shift
                ;;
            -p|--port)
                port="$2"
                shift 2
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use 'funnel --help' for usage information."
                return 1
                ;;
        esac
    done

    # Check if tailscale is running
    if ! tailscale status &> /dev/null; then
        echo "Tailscale is not running. Attempting to start it with 'tailscale up'..."
        tailscale up
        
        # Check again if tailscale is running after attempting to start it
        if ! tailscale status &> /dev/null; then
            echo "Error: Failed to start Tailscale. Please start it manually."
            return 1
        fi
        echo "Tailscale started successfully. Continuing..."
    fi

    # Use current directory if no target is specified
    if [ -z "$1" ]; then
        echo "No target specified. Using current directory as target."
        target="."
    else
        target="$*"
    fi

    # Kill any existing Python HTTP servers on our port
    local existing_pid
    existing_pid=$(lsof -ti:"$port")
    if [[ -n "$existing_pid" ]]; then
        echo "Killing existing process on port $port (PID: $existing_pid)"
        kill -9 "$existing_pid" 2>/dev/null
        sleep 1
    fi

    # Function to clean up background processes
    cleanup() {
        echo "Cleaning up..."
        # Find and kill the Python HTTP server process
        if [[ -n "$server_pid" ]]; then
            echo "Killing server process (PID: $server_pid)"
            kill -9 "$server_pid" 2>/dev/null
            wait "$server_pid" 2>/dev/null
        fi
        
        # Also try to find any process using our port
        local port_pid
        port_pid=$(lsof -ti:"$port")
        if [[ -n "$port_pid" ]]; then
            echo "Killing process on port $port (PID: $port_pid)"
            kill -9 "$port_pid" 2>/dev/null
        fi
        
        # Clean up temp directory
        if [[ -d "/tmp/funnel" ]]; then
            echo "Removing temporary directory"
            rm -rf /tmp/funnel
        fi
        
        # Return to original directory
        if [[ -n "$original_dir" ]]; then
            cd "$original_dir" || return 1
        fi
        
        return 0
    }

    # Save original directory
    original_dir=$(pwd)

    # Trap SIGINT (Ctrl+C) to run cleanup
    trap cleanup INT TERM EXIT

    # If direct service mode is enabled, funnel directly to the target service
    if $direct_service; then
        echo "Directly funneling to service on port $port..."
        
        # If the target contains a service URL, use it directly
        if [[ "$target" == *://* ]]; then
            echo "Funneling service: $target"
            tailscale funnel "$target"
        else
            echo "Funneling localhost:$port"
            tailscale funnel "localhost:$port"
        fi
        
        # Keep the process alive until Ctrl+C
        echo "Press Ctrl+C to stop the funnel"
        while true; do
            sleep 1
        done
    # if files are passed as arguments and not using direct mode
    elif [ -n "$1" ]; then
        # Clean up any existing temp directory
        if [[ -d "/tmp/funnel" ]]; then
            rm -rf /tmp/funnel
        fi
        
        # Create temp dir
        mkdir -p /tmp/funnel
        
        # Copy (not link) the files to the temp dir
        for file in "$@"; do
            # Use absolute paths for files
            local abs_path
            if [[ "$file" = /* ]]; then
                abs_path="$file"
            else
                abs_path="$original_dir/$file"
            fi
            
            echo "Checking path: $abs_path"
            
            if [[ -f "$abs_path" ]]; then
                cp "$abs_path" "/tmp/funnel/"
                echo "Copied file: $abs_path"
            elif [[ -d "$abs_path" ]]; then
                # For directories, copy the entire directory structure
                cp -r "$abs_path" "/tmp/funnel/"
                echo "Copied directory: $abs_path"
            else
                echo "Warning: $abs_path does not exist, skipping"
            fi
        done
        
        # Change dir to the temp dir
        cd /tmp/funnel || return 1
        
        # List the contents to verify
        echo "Files available for sharing:"
        ls -la
        
        if $use_python; then
            # Start the python server
            python3 -m http.server "$port" &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:"$port" >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel "localhost:$port"
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    else
        # Use current dir
        if $use_python; then
            # Start the python server
            python3 -m http.server "$port" &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:"$port" >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel "localhost:$port"
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    fi
}

alias tsf=funnel
alias postfile=funnel
alias openport="funnel -d -p"

# Cloudflare tunnel for sharing local services
cftunnel_function() {
    local port=""
    local password=""
    local description=""
    local use_worker=true
    local legacy_mode=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--password)
                password="$2"
                shift 2
                ;;
            -d|--description)
                description="$2"
                shift 2
                ;;
            --legacy)
                legacy_mode=true
                use_worker=false
                shift
                ;;
            -h|--help)
                cat << 'EOF'
Usage: cftunnel [OPTIONS] PORT

Create secure, password-protected tunnels using Cloudflare Workers.

Arguments:
  PORT                        Port number to expose (required)

Options:
  -p, --password PASS        Password protect the tunnel (required)
  -d, --description DESC     Description for the tunnel (optional)
  --legacy                   Use legacy cloudflared tunnel instead of Worker
  -h, --help                Show this help message

Examples:
  cftunnel -p secret123 8080              # Secure tunnel to port 8080
  cftunnel -p mypass -d "My App" 3000     # Tunnel with custom description
  cftunnel --legacy 8080                  # Use old tunnel method (not recommended)

Features:
  üîê Password authentication required
  üåê Persistent URLs (no temporary links)
  ‚ö° Powered by Cloudflare's global network
  üõ°Ô∏è End-to-end encryption
  üìä Status monitoring and management

Note: Password protection is now mandatory for security.
EOF
                return 0
                ;;
            *)
                if [[ -z "$port" ]]; then
                    port="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$port" ]]; then
        echo "‚ùå Error: Port number is required"
        echo "Usage: cftunnel -p PASSWORD PORT"
        echo "Use 'cftunnel -h' for help"
        return 1
    fi
    
    if [[ "$use_worker" == true && -z "$password" ]]; then
        echo "‚ùå Error: Password is required for secure tunnels"
        echo "Usage: cftunnel -p PASSWORD PORT"
        echo "Use '--legacy' for unprotected tunnels (not recommended)"
        return 1
    fi
    
    # Validate port number
    if ! [[ "$port" =~ ^[0-9]+$ ]] || [[ "$port" -lt 1 ]] || [[ "$port" -gt 65535 ]]; then
        echo "‚ùå Error: Invalid port number '$port'"
        echo "Port must be a number between 1 and 65535"
        return 1
    fi
    
    if [[ "$use_worker" == true ]]; then
        echo "üöÄ Creating secure Worker-based tunnel..."
        echo "üéØ Target: localhost:$port"
        echo "üîë Password: $password"
        if [[ -n "$description" ]]; then
            echo "üìù Description: $description"
        fi
        echo ""
        
        # Check if Node.js is available
        if ! command -v node &> /dev/null; then
            echo "‚ùå Error: Node.js is required for Worker tunnels"
            echo "Install Node.js or use '--legacy' for basic tunnels"
            return 1
        fi
        
        # Check for multi-user client
        if [[ -f "src/multi-user-client.js" ]]; then
            # Use multi-user client for enhanced functionality
            echo "üåü Multi-user tunnel mode available"
            echo "üí° To create a multi-user tunnel, use:"
            echo "   node src/multi-user-client.js create $port admin123 \"user1:pass1;user2:pass2\" \"$description\""
            echo ""
            echo "üîÑ Using single-user mode for now..."
        fi
        
        # Use the tunnel client to register with Worker
        node src/tunnel-client.js "$port" "$password" "$description"
        
    else
        # Legacy mode
        echo "‚ö†Ô∏è  Using legacy tunnel mode (not recommended)"
        echo "üåç Starting public Cloudflare tunnel for localhost:$port..."
        
        # Check if cloudflared is installed
        if ! command -v cloudflared &> /dev/null; then
            echo "‚ùå Error: cloudflared is not installed"
            echo "You can install it with:"
            echo "  brew install cloudflared"
            return 1
        fi
        
        cloudflared tunnel --url "http://localhost:$port"
    fi
}

# Multi-user tunnel function
cfmulti_function() {
    local port=""
    local admin_password=""
    local users=""
    local description=""
    local max_users="10"
    local command="create"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            create|adduser|users)
                command="$1"
                shift
                ;;
            -a|--admin)
                admin_password="$2"
                shift 2
                ;;
            -u|--users)
                users="$2"
                shift 2
                ;;
            -d|--description)
                description="$2"
                shift 2
                ;;
            -m|--max-users)
                max_users="$2"
                shift 2
                ;;
            -h|--help)
                cat << 'EOF'
Usage: cfmulti [COMMAND] [OPTIONS] PORT

Create and manage multi-user secure tunnels with individual credentials.

Commands:
  create              Create a new multi-user tunnel (default)
  adduser TUNNEL_ID   Add user to existing tunnel
  users TUNNEL_ID     List users in tunnel

Options:
  -a, --admin PWD     Admin password for tunnel management
  -u, --users USERS   User credentials (user1:pass1;user2:pass2)
  -d, --description   Description for the tunnel
  -m, --max-users N   Maximum number of users (default: 10)

Examples:
  cfmulti create 8080 -a admin123 -u "alice:secret;bob:pass123" -d "Team App"
  cfmulti adduser swift-eagle-123 -a admin123
  cfmulti users swift-eagle-123 -a admin123

User Format:
  Simple: username:password
  With permissions: username:password:read,write
  Multiple: user1:pass1;user2:pass2:admin
EOF
                return 0
                ;;
            *)
                if [[ -z "$port" ]] && [[ "$1" =~ ^[0-9]+$ ]]; then
                    port="$1"
                else
                    echo "‚ùå Unknown option: $1"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if Node.js is available
    if ! command -v node &> /dev/null; then
        echo "‚ùå Error: Node.js is required for multi-user tunnels"
        return 1
    fi
    
    # Check if multi-user client exists
    if [[ ! -f "src/multi-user-client.js" ]]; then
        echo "‚ùå Error: Multi-user client not found"
        echo "Please ensure src/multi-user-client.js is available"
        return 1
    fi
    
    # Handle different commands
    case "$command" in
        create)
            if [[ -z "$port" ]] || [[ -z "$admin_password" ]] || [[ -z "$users" ]]; then
                echo "‚ùå Missing required arguments for create command"
                echo "Usage: cfmulti create PORT -a admin_password -u \"user1:pass1;user2:pass2\""
                return 1
            fi
            
            echo "üöÄ Creating multi-user tunnel for port $port..."
            node src/multi-user-client.js create "$port" "$admin_password" "$users" "$description" "$max_users"
            ;;
        adduser)
            echo "‚ûï Adding user to tunnel..."
            node src/multi-user-client.js adduser "$@"
            ;;
        users)
            echo "üë• Listing tunnel users..."
            node src/multi-user-client.js users "$@"
            ;;
    esac
}

# Old cffile_function - DEPRECATED - Use cffile instead
# This function is kept for reference but should not be used
# It doesn't actually proxy files through the Worker
cffile_function_old_deprecated() {
    local port=8004
    local password=""
    local description=""
    local use_multi=false
    local admin_password=""
    local users=""
    local original_dir
    local server_pid
    local tunnel_pid
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--password)
                password="$2"
                shift 2
                ;;
            -m|--multi)
                use_multi=true
                shift
                ;;
            -a|--admin)
                admin_password="$2"
                shift 2
                ;;
            -u|--users)
                users="$2"
                shift 2
                ;;
            --port)
                port="$2"
                shift 2
                ;;
            -d|--description)
                description="$2"
                shift 2
                ;;
            -h|--help)
                echo "Usage: cffile [OPTIONS] [files/directories...]"
                echo ""
                echo "Share files via secure Cloudflare tunnel with Python server."
                echo ""
                echo "Options:"
                echo "  -p, --password PWD    Single-user mode: Set tunnel password"
                echo "  -m, --multi          Enable multi-user mode"
                echo "  -a, --admin PWD      Multi-user mode: Admin password"
                echo "  -u, --users USERS    Multi-user mode: User credentials"
                echo "  --port PORT          Local server port (default: 8004)"
                echo "  -d, --description    Description for the tunnel"
                echo "  -h, --help           Show this help"
                echo ""
                echo "Examples:"
                echo "  cffile document.pdf                    # Share single file"
                echo "  cffile -p secret123 document.pdf      # Share with password"
                echo "  cffile -m -a admin123 -u \"user1:pass1;user2:pass2\" files/"
                return 0
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Check Python 3
    if ! command -v python3 &> /dev/null; then
        echo "‚ùå Error: Python 3 is required"
        echo "Install it with: brew install python"
        return 1
    fi
    
    # Store original directory
    original_dir=$(pwd)
    
    # Handle file arguments
    if [ $# -gt 0 ]; then
        echo "üìÅ Preparing files for sharing..."
        mkdir -p "/tmp/cffile-$$"
        
        for item in "$@"; do
            if [[ -e "$item" ]]; then
                if [[ -d "$item" ]]; then
                    # For directories, copy contents instead of symlinking the directory itself
                    if [[ "$item" == "." || "$item" == "./" ]]; then
                        echo "   ‚úì Adding current directory contents..."
                        cp -r ./* "/tmp/cffile-$$/" 2>/dev/null || true
                        cp -r ./.[^.]* "/tmp/cffile-$$/" 2>/dev/null || true
                    else
                        echo "   ‚úì Adding directory: $(basename "$item")"
                        cp -r "$item" "/tmp/cffile-$$/"
                    fi
                else
                    # For files, create symlinks
                    ln -sf "$(realpath "$item")" "/tmp/cffile-$$/"
                    echo "   ‚úì Added file: $(basename "$item")"
                fi
            else
                echo "   ‚ö†Ô∏è  Warning: $item not found"
            fi
        done
        
        cd "/tmp/cffile-$$" || { echo "‚ùå Failed to access temp directory"; return 1; }
    else
        echo "üìÇ Serving current directory: $(pwd)"
    fi
    
    # Set description
    if [[ -z "$description" ]]; then
        description="cffile sharing ($(ls | wc -l | tr -d ' ') items)"
    fi
    
    # Find available port if default is in use
    local attempts=0
    while [[ $attempts -lt 10 ]]; do
        if ! lsof -ti:$port >/dev/null 2>&1; then
            break
        fi
        echo "‚ö†Ô∏è  Port $port is in use, trying $((port + 1))..."
        port=$((port + 1))
        attempts=$((attempts + 1))
    done
    
    if [[ $attempts -eq 10 ]]; then
        echo "‚ùå Could not find available port after 10 attempts"
        cd "$original_dir"
        [[ -d "/tmp/cffile-$$" ]] && rm -rf "/tmp/cffile-$$"
        return 1
    fi
    
    # Start Python server
    echo "üöÄ Starting Python HTTP server on port $port..."
    python3 -m http.server "$port" &
    server_pid=$!
    sleep 2
    
    if ! kill -0 "$server_pid" 2>/dev/null; then
        echo "‚ùå Failed to start Python server on port $port"
        cd "$original_dir"
        [[ -d "/tmp/cffile-$$" ]] && rm -rf "/tmp/cffile-$$"
        return 1
    fi
    
    echo "‚úÖ Server running at http://localhost:$port"
    
    # Cleanup function
    cleanup_cffile() {
        echo ""
        echo "üõë Shutting down cffile..."
        [[ -n "$server_pid" ]] && kill "$server_pid" 2>/dev/null && echo "   ‚úì Python server stopped"
        [[ -n "$tunnel_pid" ]] && kill "$tunnel_pid" 2>/dev/null && echo "   ‚úì Tunnel stopped"
        cd "$original_dir"
        [[ -d "/tmp/cffile-$$" ]] && rm -rf "/tmp/cffile-$$" && echo "   ‚úì Temporary files cleaned"
        echo "‚úÖ cffile stopped"
    }
    
    trap cleanup_cffile SIGINT SIGTERM
    
    # Start tunnel
    if $use_multi; then
        if [[ -z "$admin_password" ]] || [[ -z "$users" ]]; then
            echo "‚ùå Multi-user mode requires -a admin_password and -u users"
            cleanup_cffile
            return 1
        fi
        echo "üåê Creating multi-user tunnel..."
        node "$original_dir/src/multi-user-client.js" create "$port" "$admin_password" "$users" "$description" &
        tunnel_pid=$!
    else
        if [[ -z "$password" ]]; then
            password="cffile-$(date +%s | tail -c 4)"
            echo "üîë Generated password: $password"
        fi
        echo "üåê Creating single-user tunnel..."
        node "$original_dir/src/tunnel-client.js" "$port" "$password" "$description" &
        tunnel_pid=$!
    fi
    
    echo ""
    echo "üéØ File sharing is active!"
    echo "üõë Press Ctrl+C to stop"
    
    wait "$tunnel_pid"
    cleanup_cffile
}

# Unalias cffile if it exists to avoid conflicts
unalias cffile 2>/dev/null || true
unalias cffile_function 2>/dev/null || true

# Main cffile implementation - uses hybrid approach (Worker auth + cloudflared proxy)
cffile() {
    /Users/sac/Git/dotfiles/macos/cffile-hybrid.sh "$@"
}

# Alias cffile_function to use the same hybrid implementation
cffile_function() {
    /Users/sac/Git/dotfiles/macos/cffile-hybrid.sh "$@"
}

# Short aliases for cffile
alias cff=cffile                  # Quick file sharing
alias cfshare=cffile              # Alternative name for file sharing

# Secure file sharing (true end-to-end encryption)
alias cfsecure="/Users/sac/Git/dotfiles/macos/cfsecure-integrated.sh"  # True secure sharing
alias cfs="/Users/sac/Git/dotfiles/macos/cfsecure-integrated.sh"       # Short secure sharing

# Quick secure sharing functions
cfsecure_quick() {
    cfsecure -m openssl "$@"
}

cfsecure_age() {
    cfsecure -m age "$@"
}

cfsecure_gpg() {
    cfsecure -m gpg "$@"
}

# Aliases for cloudflare tunnel
alias cftunnel_share=cftunnel  # Tunnel sharing (renamed to avoid conflict)
alias cloudshare=cftunnel
alias cft=cftunnel
alias cfmulti=cfmulti_function  # Multi-user tunnels
# cffile is now a function that calls the hybrid script

# ----------------------
# Cloudflare Wrangler Functions
# ----------------------

# Auto-setup helper function
_cf_ensure_setup() {
    # Find dotfiles directory if not in it
    local dotfiles_dir="$HOME/Git/dotfiles/macos"
    if [[ ! -f package.json ]] || ! grep -q "wrangler" package.json 2>/dev/null; then
        if [[ -f "$dotfiles_dir/package.json" ]]; then
            echo "üîÑ Switching to dotfiles directory..."
            cd "$dotfiles_dir"
        else
            echo "‚ùå Cannot find dotfiles directory with wrangler config"
            echo "Please navigate to your dotfiles directory first"
            return 1
        fi
    fi
    
    # Install dependencies if needed
    if [[ ! -d node_modules ]]; then
        echo "üì¶ Installing dependencies..."
        npm install --silent
    fi
    
    # Check authentication
    if ! wrangler whoami &>/dev/null 2>&1; then
        echo "üîê Wrangler not authenticated. Please login..."
        wrangler login
        if ! wrangler whoami &>/dev/null 2>&1; then
            echo "‚ùå Authentication failed"
            return 1
        fi
    fi
    
    # Check if R2 buckets exist (indicator of setup completion)
    local bucket_check=$(wrangler r2 bucket list 2>/dev/null | grep -E "(files|screenshots|backups)")
    if [[ -z "$bucket_check" ]]; then
        echo "üîß First-time setup detected. Creating R2 buckets with public access..."
        local buckets=("files" "screenshots" "backups" "images")
        for bucket in "${buckets[@]}"; do
            echo "üì¶ Creating public bucket: $bucket"
            if wrangler r2 bucket create "$bucket" 2>/dev/null; then
                echo "üåç Enabling public access for: $bucket"
                # Enable R2 dev URL for public access
                wrangler r2 bucket dev-url enable "$bucket" 2>/dev/null || echo "  ‚ö†Ô∏è  Public access needs manual configuration in dashboard"
            else
                echo "  ‚ö†Ô∏è  Bucket $bucket may already exist"
            fi
        done
    fi
    
    return 0
}

# Manual setup command (optional)
cfsetup() {
    echo "üîß Running Cloudflare setup..."
    _cf_ensure_setup && npm run setup:cloudflare
}

# Sync local secrets to Cloudflare
cfsync_function() {
    _cf_ensure_setup || return 1
    echo "üîÑ Syncing local secrets to Cloudflare..."
    
    # Check if worker exists first
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "‚ö†Ô∏è  Worker not deployed yet. Deploying first..."
        if cfdeploy; then
            echo "‚úÖ Worker deployed, now syncing secrets..."
            npm run secrets:sync
        else
            echo "‚ùå Worker deployment failed"
            return 1
        fi
    else
        npm run secrets:sync
    fi
}

# Get secrets from Cloudflare 
cfget_function() {
    _cf_ensure_setup || return 1
    echo "üì• Getting secrets from Cloudflare..."
    
    # Check if worker exists first
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "‚ö†Ô∏è  Worker not deployed yet. Deploying first..."
        if cfdeploy; then
            echo "‚úÖ Worker deployed, now getting secrets..."
            npm run secrets:get
        else
            echo "‚ùå Worker deployment failed"
            return 1
        fi
    else
        npm run secrets:get
    fi
}

# List available secrets
_cflist_function() {
    _cf_ensure_setup || return 1
    echo "üìã Listing Cloudflare secrets..."
    
    # Check if worker exists first
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "‚ö†Ô∏è  Worker 'macos-dotfiles-secrets' doesn't exist yet"
        echo "üöÄ Deploying worker first..."
        if cfdeploy; then
            echo "‚úÖ Worker deployed, now listing secrets..."
            npm run secrets:list
        else
            echo "‚ùå Worker deployment failed"
            return 1
        fi
    else
        npm run secrets:list
    fi
}

# Deploy worker to Cloudflare
cfdeploy_function() {
    _cf_ensure_setup || return 1
    echo "üöÄ Deploying worker to Cloudflare..."
    
    # Check if source files exist
    if [[ ! -f "src/index.js" ]]; then
        echo "‚ùå Worker source file not found: src/index.js"
        echo "üí° Make sure you're in the dotfiles directory with the worker code"
        return 1
    fi
    
    if [[ ! -f "wrangler.toml" ]]; then
        echo "‚ùå Wrangler configuration not found: wrangler.toml"
        return 1
    fi
    
    echo "üìã Deploying worker 'macos-dotfiles-secrets'..."
    if wrangler deploy; then
        echo "‚úÖ Worker deployed successfully!"
        echo "üîó Worker URL will be shown above"
        
        # Test the deployment
        echo "üß™ Testing worker deployment..."
        if wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
            echo "‚úÖ Worker deployment verified"
        else
            echo "‚ö†Ô∏è  Worker deployment verification failed"
        fi
    else
        echo "‚ùå Worker deployment failed"
        echo "üí° Check the error messages above for details"
        return 1
    fi
}

# Test worker locally
cfdev_function() {
    _cf_ensure_setup || return 1
    echo "üíª Starting local development server..."
    
    # Check if source files exist
    if [[ ! -f "src/index.js" ]]; then
        echo "‚ùå Worker source file not found: src/index.js"
        return 1
    fi
    
    if [[ ! -f "wrangler.toml" ]]; then
        echo "‚ùå Wrangler configuration not found: wrangler.toml"
        return 1
    fi
    
    echo "üöÄ Starting local worker at http://localhost:8787"
    echo "üîÑ Press Ctrl+C to stop"
    wrangler dev
}
alias cfdev=cfdev_function

# Upload file to R2 bucket and get shareable link
cfupload_function() {
    _cf_ensure_setup || return 1
    
    local file_path="$1"
    local bucket_name="${2:-files}"
    local custom_name="$3"
    
    if [[ -z "$file_path" ]]; then
        echo "Usage: cfupload FILE_PATH [BUCKET_NAME] [CUSTOM_NAME]"
        echo ""
        echo "Examples:"
        echo "  cfupload ~/screenshot.png"
        echo "  cfupload ~/document.pdf files my-doc.pdf"
        echo "  cfupload ~/image.jpg images"
        return 1
    fi
    
    if [[ ! -f "$file_path" ]]; then
        echo "Error: File not found: $file_path"
        return 1
    fi
    
    # Generate filename if not provided
    if [[ -z "$custom_name" ]]; then
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        local extension="${file_path##*.}"
        local basename=$(basename "$file_path" ".$extension")
        custom_name="${basename}_${timestamp}.${extension}"
    fi
    
    echo "üì§ Uploading $(basename "$file_path") to R2 bucket: $bucket_name"
    echo "üè∑Ô∏è  Remote name: $custom_name"
    
    # Try to upload - if bucket doesn't exist, create it
    if ! wrangler r2 object put "$bucket_name/$custom_name" --file="$file_path" 2>/dev/null; then
        echo "üì¶ Bucket might not exist. Attempting to create..."
        
        # Try to create the bucket
        if wrangler r2 bucket create "$bucket_name" 2>/dev/null; then
            echo "‚úÖ Bucket '$bucket_name' created"
            
            # Check if this should be a public bucket
            if [[ "$bucket_name" == *"-public" ]] || [[ "$bucket_name" == "screenshots" ]] || [[ "$bucket_name" == "files" ]] || [[ "$bucket_name" == "images" ]]; then
                echo "üåç Enabling public access..."
                wrangler r2 bucket dev-url enable "$bucket_name" 2>/dev/null
            fi
            
            # Retry the upload
            if wrangler r2 object put "$bucket_name/$custom_name" --file="$file_path"; then
                echo "‚úÖ Upload successful after creating bucket!"
            else
                echo "‚ùå Upload failed even after creating bucket"
                return 1
            fi
        else
            # Bucket exists, retry upload
            if wrangler r2 object put "$bucket_name/$custom_name" --file="$file_path"; then
                echo "‚úÖ Upload successful!"
            else
                echo "‚ùå Upload failed"
                return 1
            fi
        fi
    else
        echo "‚úÖ Upload successful!"
        
        # Generate R2 public URL
        # Map buckets to their public domains (update as you enable more buckets)
        local r2_domain=""
        case "$bucket_name" in
            "files")
                r2_domain="pub-ef8813e86b494d8e8ff24a6182785ea4.r2.dev"
                ;;
            "screenshots"|"images"|*"-public")
                # These need public access enabled first
                r2_domain=""
                ;;
        esac
        
        # Check if bucket has public access configured
        if [[ -n "$r2_domain" ]]; then
            local public_url="https://${r2_domain}/$custom_name"
            
            echo "üîó Public URL: $public_url"
            echo "üìã Copying URL to clipboard..."
            echo "$public_url" | pbcopy
            
            # Test if URL is accessible
            local http_status=$(curl -s -o /dev/null -w "%{http_code}" "$public_url" 2>/dev/null)
            if [[ "$http_status" == "200" ]]; then
                echo "‚úÖ URL is publicly accessible!"
            elif [[ "$http_status" == "404" ]]; then
                echo "‚ö†Ô∏è  File may not be fully propagated yet"
                echo "üí° Try the URL in a few seconds"
            else
                echo "‚ö†Ô∏è  Public access may need configuration (HTTP $http_status)"
                echo "üí° Enable with: wrangler r2 bucket dev-url enable $bucket_name"
            fi
        else
            echo "üîó File uploaded to: $bucket_name/$custom_name"
            echo "üí° Configure R2 public access:"
            echo "   cfpublic $bucket_name"
            echo "üìã Copying object path to clipboard..."
            echo "$bucket_name/$custom_name" | pbcopy
        fi
    fi
}

# Download file from R2 bucket
cfdownload_function() {
    _cf_ensure_setup || return 1
    
    local remote_path="$1"
    local local_path="$2"
    local bucket_name="${3:-files}"
    
    if [[ -z "$remote_path" ]]; then
        echo "Usage: cfdownload REMOTE_PATH [LOCAL_PATH] [BUCKET_NAME]"
        echo ""
        echo "Examples:"
        echo "  cfdownload image.jpg"
        echo "  cfdownload folder/file.pdf ~/Downloads/"
        echo "  cfdownload doc.txt ~/Documents/doc.txt"
        return 1
    fi
    
    # Set local path if not provided
    if [[ -z "$local_path" ]]; then
        local_path="./$(basename "$remote_path")"
    fi
    
    echo "üì• Downloading $remote_path from R2 bucket: $bucket_name"
    
    if wrangler r2 object get "$bucket_name/$remote_path" --file="$local_path"; then
        echo "‚úÖ Download successful: $local_path"
    else
        echo "‚ùå Download failed"
        return 1
    fi
}

# List files in R2 bucket
cffiles_function() {
    _cf_ensure_setup || return 1
    
    local bucket_name="${1:-files}"
    local prefix="$2"
    
    echo "üìÅ Listing available R2 buckets:"
    wrangler r2 bucket list
    
    echo ""
    echo "üí° To list objects in a bucket, Wrangler v4 requires individual object operations."
    echo "   Available buckets shown above."
    echo ""
    echo "üîç To see bucket contents, try:"
    echo "   - cfbackup (to backup and see files)"
    echo "   - Check Cloudflare Dashboard ‚Üí R2 ‚Üí Buckets"
    echo ""
    if [[ -n "$bucket_name" && "$bucket_name" != "files" ]]; then
        echo "üìä Getting info for bucket: $bucket_name"
        wrangler r2 bucket info "$bucket_name" 2>/dev/null || echo "‚ùå Bucket '$bucket_name' not found or inaccessible"
    fi
}

# Delete file from R2 bucket
cfdelete_function() {
    _cf_ensure_setup || return 1
    
    local remote_path="$1"
    local bucket_name="${2:-files}"
    
    if [[ -z "$remote_path" ]]; then
        echo "Usage: cfdelete REMOTE_PATH [BUCKET_NAME]"
        echo ""
        echo "Examples:"
        echo "  cfdelete image.jpg"
        echo "  cfdelete folder/file.pdf"
        return 1
    fi
    
    echo "üóëÔ∏è  Deleting $remote_path from R2 bucket: $bucket_name"
    echo "‚ö†Ô∏è  This action cannot be undone!"
    echo -n "Continue? (y/N): "
    read -r confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        if wrangler r2 object delete "$bucket_name/$remote_path"; then
            echo "‚úÖ File deleted successfully"
        else
            echo "‚ùå Delete failed"
            return 1
        fi
    else
        echo "‚ùå Delete cancelled"
    fi
}

# ============================================
# Cloudflare Pages Functions
# ============================================

# Initialize Cloudflare Pages project for public files
cfpage-init() {
    echo "üöÄ Initializing Cloudflare Pages for public file sharing..."
    
    local public_dir="$HOME/public-files"
    
    # Create public files directory if it doesn't exist
    if [[ ! -d "$public_dir" ]]; then
        mkdir -p "$public_dir"
        echo "üìÅ Created directory: $public_dir"
    fi
    
    cd "$public_dir" || return 1
    
    # Check if Pages project exists
    if ! npx wrangler pages project list 2>/dev/null | grep -q "public-files"; then
        echo "üì¶ Creating Pages project..."
        npx wrangler pages project create public-files --production-branch main
    else
        echo "‚úÖ Pages project already exists"
    fi
    
    # Deploy current files
    echo "üåê Deploying to Pages..."
    npx wrangler pages deploy . --project-name public-files
    
    echo ""
    echo "‚ú® Pages setup complete!"
    echo "üìç Your public URL will be shown after deployment"
    cd - > /dev/null
}

# Upload file to Cloudflare Pages
cfpage-upload() {
    local file="$1"
    
    if [[ -z "$file" ]]; then
        echo "Usage: cfpage-upload FILE"
        echo ""
        echo "Examples:"
        echo "  cfpage-upload document.pdf"
        echo "  cfpage-upload ~/Downloads/image.png"
        return 1
    fi
    
    if [[ ! -f "$file" ]]; then
        echo "‚ùå File not found: $file"
        return 1
    fi
    
    local public_dir="$HOME/public-files"
    local filename=$(basename "$file")
    
    # Copy file to public directory
    cp "$file" "$public_dir/$filename"
    
    # Update files.json
    cd "$public_dir" || return 1
    
    # Create or update files.json
    if [[ -f "files.json" ]]; then
        # Add new file to existing list
        local temp_json=$(mktemp)
        jq --arg name "$filename" --arg size "$(ls -lh "$filename" | awk '{print $5}')" \
           '. + [{"name": $name, "size": $size}] | unique_by(.name) | reverse' \
           files.json > "$temp_json" && mv "$temp_json" files.json
    else
        # Create new files.json
        jq -n --arg name "$filename" --arg size "$(ls -lh "$filename" | awk '{print $5}')" \
           '[{"name": $name, "size": $size}]' > files.json
    fi
    
    # Deploy to Pages
    echo "üöÄ Deploying to Cloudflare Pages..."
    local deploy_output=$(npx wrangler pages deploy . --project-name public-files 2>&1)
    local url=$(echo "$deploy_output" | grep -o 'https://[^[:space:]]*pages\.dev' 2>/dev/null | head -1)
    
    if [[ -z "$url" ]]; then
        url="https://public-files-5kg.pages.dev"
    fi
    
    echo ""
    echo "‚úÖ File uploaded successfully!"
    echo "üîó Public URL: $url/$filename"
    echo ""
    echo "üìã URL copied to clipboard"
    echo "$url/$filename" | pbcopy
    
    cd - > /dev/null
}

# Take screenshot and upload to Pages (or with password protection)
cfpage-shot() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local filename="screenshot_${timestamp}.png"
    local temp_file="/tmp/$filename"
    local password=""
    
    # Parse arguments for password
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--password)
                password="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
    
    echo "üì∏ Taking screenshot..."
    echo "Press Cmd+Shift+4 and select area to capture"
    
    # Take screenshot
    screencapture -i "$temp_file"
    
    if [[ ! -f "$temp_file" ]]; then
        echo "‚ùå Screenshot cancelled"
        return 1
    fi
    
    if [[ -n "$password" ]]; then
        # Use cffile for password-protected sharing
        echo "üîê Creating password-protected share..."
        cffile -p "$password" "$temp_file"
    else
        # Upload publicly using cfpage-upload
        cfpage-upload "$temp_file"
    fi
    
    # Keep temp file if using cffile (it handles cleanup)
    if [[ -z "$password" ]]; then
        rm "$temp_file"
    fi
}

# List files on Pages
cfpage-list() {
    local public_dir="$HOME/public-files"
    
    if [[ -f "$public_dir/files.json" ]]; then
        echo "üìÅ Files on Cloudflare Pages:"
        echo ""
        jq -r '.[] | "  üìÑ \(.name) (\(.size))"' "$public_dir/files.json"
        echo ""
        echo "üîó Public URL: https://public-files-5kg.pages.dev"
    else
        echo "üì≠ No files uploaded yet"
        echo "Use 'cfpage-upload FILE' to upload files"
    fi
}

# Password-protected file upload
cfprotect_function() {
    local file_path="$1"
    local password="$2"
    
    if [[ -z "$file_path" ]] || [[ -z "$password" ]]; then
        echo "Usage: cfprotect FILE PASSWORD"
        echo "   or: cfpu FILE -p PASSWORD"
        echo ""
        echo "Examples:"
        echo "  cfprotect secret.pdf mypassword123"
        echo "  cfpu confidential.doc -p 'complex pass phrase'"
        return 1
    fi
    
    if [[ ! -f "$file_path" ]]; then
        echo "‚ùå File not found: $file_path"
        return 1
    fi
    
    echo "üîê Uploading password-protected file..."
    
    # Ensure protected-files bucket exists  
    if ! wrangler r2 bucket list 2>/dev/null | \grep -q "protected-files"; then
        echo "üì¶ Creating protected-files bucket..."
        wrangler r2 bucket create protected-files 2>/dev/null || echo "Bucket may already exist"
    fi
    
    # Generate password hash
    local password_hash=$(echo -n "$password" | shasum -a 256 | awk '{print $1}')
    local filename=$(basename "$file_path")
    local timestamp=$(date +%s)
    local protected_name="${timestamp}_${filename}"
    
    # Upload file with password hash in metadata
    echo "üì§ Uploading to protected storage..."
    if wrangler r2 object put "protected-files/${protected_name}" \
        --file "$file_path" \
        --content-type "application/octet-stream" \
        --remote 2>/dev/null; then
        
        # Store password hash in KV
        echo "üîë Storing password hash..."
        wrangler kv key put "hash_${protected_name}" "$password_hash" --namespace-id "33eebef30dd54140a0485f4ae6dd9e9d" --remote
        
        # Deploy the worker if not already deployed
        echo "üöÄ Deploying password protection worker..."
        wrangler deploy --config wrangler-protected.toml
        
        # Get the worker URL
        local worker_url="https://protected-files.wemea-5ahhf.workers.dev"
        local protected_url="${worker_url}/${protected_name}"
        
        echo ""
        echo "‚úÖ Password-protected file uploaded!"
        echo "üîó Protected URL: $protected_url"
        echo "üîë Password: $password"
        echo ""
        echo "üìã URL copied to clipboard"
        echo "$protected_url" | pbcopy
        
        # Save to a local log for reference
        echo "$(date): $protected_name | Password: [hidden] | URL: $protected_url" >> ~/.cf-protected-files.log
        
        echo ""
        echo "üí° Share the URL and password separately for security"
        echo "üìù Upload logged to ~/.cf-protected-files.log"
    else
        echo "‚ùå Upload failed"
        return 1
    fi
}

# Enhanced cfpage-upload with password protection option
cfpu_enhanced() {
    local file_path=""
    local password=""
    local public=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--password)
                password="$2"
                public=false
                shift 2
                ;;
            *)
                file_path="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$file_path" ]]; then
        echo "Usage: cfpu FILE [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  -p, --password PASSWORD    Password-protect the file"
        echo ""
        echo "Examples:"
        echo "  cfpu document.pdf                    # Public upload"
        echo "  cfpu secret.pdf -p mypassword       # Password-protected"
        return 1
    fi
    
    if [[ "$public" == true ]]; then
        # Regular public upload
        cfpage-upload "$file_path"
    else
        # Password-protected upload
        cfprotect_function "$file_path" "$password"
    fi
}

# Quick screenshot upload to Cloudflare
cfshot_function() {
    _cf_ensure_setup || return 1
    
    local filename=""
    local password=""
    local is_private=false
    local public=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--password)
                password="$2"
                public=false
                is_private=true
                shift 2
                ;;
            --private)
                is_private=true
                public=false
                shift
                ;;
            *)
                filename="$1"
                shift
                ;;
        esac
    done
    
    # Set default filename if not provided
    if [[ -z "$filename" ]]; then
        filename="screenshot_$(date +%Y%m%d_%H%M%S).png"
    fi
    
    local temp_file="/tmp/$filename"
    
    echo "üì∏ Taking screenshot..."
    
    # Take screenshot and save to temp file
    screencapture -i "$temp_file"
    
    if [[ -f "$temp_file" ]]; then
        echo "‚úÖ Screenshot captured"
        
        # Choose upload method based on protection level
        if [[ "$public" == false && -n "$password" ]]; then
            echo "üîê Uploading with password protection..."
            cfprotect_function "$temp_file" "$password"
        elif [[ "$is_private" == true ]]; then
            echo "üîí Uploading as PRIVATE (no public URL)"
            cfupload "$temp_file" "screenshots" "$filename"
        else
            echo "üåç Uploading as PUBLIC (shareable URL)"
            cfpage-upload "$temp_file" "$filename"
        fi
        
        # Clean up temp file
        rm -f "$temp_file"
    else
        echo "‚ùå Screenshot cancelled or failed"
        return 1
    fi
}

# Public screenshot (default)
cfshot-public() {
    cfshot_function "$1" "public"
}

# Private screenshot
cfshot-private() {
    cfshot_function "$1" "private"
}

# Backup current dotfiles to R2
cfbackup_function() {
    _cf_ensure_setup || return 1
    
    local backup_name="${1:-dotfiles_$(date +%Y%m%d_%H%M%S).tar.gz}"
    local temp_file="/tmp/$backup_name"
    
    echo "üíæ Creating dotfiles backup..."
    
    # Create compressed archive of dotfiles
    if tar -czf "$temp_file" -C "$HOME" \
        .zshrc .zsh_* .env .gitconfig .ssh/config \
        2>/dev/null; then
        
        echo "‚úÖ Backup archive created"
        cfupload "$temp_file" "backups" "$backup_name"
        
        # Clean up temp file
        rm "$temp_file"
    else
        echo "‚ùå Backup creation failed"
        return 1
    fi
}

# Setup public/private bucket structure
cfsetup-buckets() {
    echo "üîß Setting up public/private bucket structure..."
    echo ""
    
    # Public buckets (with dev URL enabled)
    local public_buckets=("files-public" "screenshots-public" "images-public")
    
    # Private buckets (no public access)
    local private_buckets=("files-private" "screenshots-private" "backups-private" "secrets")
    
    echo "üì¶ Creating PUBLIC buckets..."
    for bucket in "${public_buckets[@]}"; do
        if wrangler r2 bucket create "$bucket" 2>/dev/null; then
            echo "  ‚úÖ Created: $bucket"
            echo "  üåç Enabling public access..."
            wrangler r2 bucket dev-url enable "$bucket" 2>/dev/null
        else
            echo "  ‚ö†Ô∏è  Bucket $bucket already exists"
        fi
    done
    
    echo ""
    echo "üîí Creating PRIVATE buckets..."
    for bucket in "${private_buckets[@]}"; do
        if wrangler r2 bucket create "$bucket" 2>/dev/null; then
            echo "  ‚úÖ Created: $bucket (private)"
        else
            echo "  ‚ö†Ô∏è  Bucket $bucket already exists"
        fi
    done
    
    echo ""
    echo "‚úÖ Bucket setup complete!"
    echo ""
    echo "üìã Usage:"
    echo "  Public uploads:  cfu file.pdf files-public"
    echo "  Private uploads: cfu file.pdf files-private"
    echo "  Public shots:    cfshot or cfsp"
    echo "  Private shots:   cfshot-private or cfspriv"
}

# Comprehensive Cloudflare status and info
cfinfo_function() {
    _cf_ensure_setup || return 1
    
    echo "üìä Cloudflare Integration Status"
    echo "=================================="
    echo ""
    
    # Authentication status
    echo "üîê Authentication:"
    local whoami_output=$(wrangler whoami 2>/dev/null)
    if [[ -n "$whoami_output" ]]; then
        echo "  ‚úÖ Authenticated"
        echo "$whoami_output" | sed 's/^/  /'
        
        local account_id=$(echo "$whoami_output" | grep -o "Account ID: [a-f0-9]*" | cut -d' ' -f3)
        if [[ -n "$account_id" ]]; then
            echo ""
            echo "üåê R2 Public URL Format:"
            echo "  ‚Ä¢ https://pub-${account_id}.r2.dev/filename"
        fi
    else
        echo "  ‚ùå Not authenticated"
        echo "  üí° Run: wrangler login"
    fi
    
    echo ""
    echo "üöÄ Worker Status:"
    if wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "  ‚úÖ Worker 'macos-dotfiles-secrets' deployed"
        echo "  üîó Secrets management: Available"
    else
        echo "  ‚ùå Worker not deployed"
        echo "  üí° Deploy with: cfdeploy"
    fi
    
    echo ""
    echo "üì¶ R2 Buckets:"
    local buckets=$(wrangler r2 bucket list 2>/dev/null)
    if [[ -n "$buckets" ]]; then
        echo "$buckets" | sed 's/^/  ‚úÖ /'
    else
        echo "  ‚ùå No buckets found"
        echo "  üí° Buckets will be created automatically when needed"
    fi
    
    echo ""
    echo "‚ö° Quick Commands:"
    echo "  cfshot    - Screenshot ‚Üí upload ‚Üí share"
    echo "  cfu FILE  - Upload any file"
    echo "  cfbak     - Backup dotfiles"
    echo "  cflist    - List secrets (deploys worker if needed)"
    echo "  cfpublic BUCKET - Enable public access"
}

# Configure R2 bucket for public access
cfpublic_bucket() {
    _cf_ensure_setup || return 1
    
    local bucket_name="${1}"
    
    if [[ -z "$bucket_name" ]]; then
        echo "Usage: cfpublic BUCKET_NAME"
        echo ""
        echo "Available buckets:"
        wrangler r2 bucket list 2>/dev/null | grep "name:" | awk '{print "  - " $2}'
        echo ""
        echo "Examples:"
        echo "  cfpublic screenshots"
        echo "  cfpublic files"
        return 1
    fi
    
    echo "üåç Enabling public access for bucket: $bucket_name"
    
    # Enable R2 dev URL for public access
    if wrangler r2 bucket dev-url enable "$bucket_name" 2>/dev/null; then
        echo "‚úÖ Public access enabled for: $bucket_name"
        
        # Get account ID and show the public URL format
        local account_id=$(wrangler whoami 2>&1 | sed -n 's/.*‚îÇ \([a-f0-9]\{32\}\).*/\1/p')
        if [[ -n "$account_id" ]]; then
            echo "üîó Public URL format: https://pub-${account_id}.r2.dev/<filename>"
            echo ""
            echo "üìã Example URL for files in this bucket:"
            echo "   https://pub-${account_id}.r2.dev/example.png"
        fi
    else
        echo "‚ùå Failed to enable public access"
        echo "üí° You may need to configure it manually in the dashboard:"
        echo "   https://dash.cloudflare.com ‚Üí R2 ‚Üí $bucket_name ‚Üí Settings"
    fi
}

# Troubleshoot and fix common issues
cffix() {
    echo "üîß Cloudflare Integration Troubleshooter"
    echo "========================================"
    echo ""
    
    # Check directory
    echo "üìÅ Checking directory..."
    if [[ ! -f "package.json" ]] || ! grep -q "wrangler" package.json 2>/dev/null; then
        echo "  ‚ùå Not in wrangler project directory"
        local dotfiles_dir="$HOME/Git/dotfiles/macos"
        if [[ -f "$dotfiles_dir/package.json" ]]; then
            echo "  üîÑ Switching to dotfiles directory..."
            cd "$dotfiles_dir"
            echo "  ‚úÖ Now in: $(pwd)"
        else
            echo "  ‚ùå Cannot find dotfiles directory"
            return 1
        fi
    else
        echo "  ‚úÖ In correct directory: $(pwd)"
    fi
    
    # Check dependencies
    echo ""
    echo "üì¶ Checking dependencies..."
    if [[ ! -d "node_modules" ]]; then
        echo "  ‚ùå Dependencies not installed"
        echo "  üîÑ Installing..."
        npm install --silent
        echo "  ‚úÖ Dependencies installed"
    else
        echo "  ‚úÖ Dependencies installed"
    fi
    
    # Check authentication
    echo ""
    echo "üîê Checking authentication..."
    if ! wrangler whoami &>/dev/null 2>&1; then
        echo "  ‚ùå Not authenticated"
        echo "  üîÑ Starting authentication..."
        wrangler login
    else
        echo "  ‚úÖ Authenticated"
    fi
    
    # Check worker deployment
    echo ""
    echo "üöÄ Checking worker deployment..."
    if ! wrangler deployments list --name="macos-dotfiles-secrets" &>/dev/null; then
        echo "  ‚ùå Worker not deployed"
        echo "  üîÑ Deploying worker..."
        if wrangler deploy; then
            echo "  ‚úÖ Worker deployed successfully"
        else
            echo "  ‚ùå Worker deployment failed"
        fi
    else
        echo "  ‚úÖ Worker deployed"
    fi
    
    # Check R2 buckets
    echo ""
    echo "üì¶ Checking R2 buckets..."
    local bucket_count=$(wrangler r2 bucket list 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$bucket_count" -eq 0 ]]; then
        echo "  ‚ö†Ô∏è  No R2 buckets found"
        echo "  üí° Buckets will be created when needed"
    else
        echo "  ‚úÖ Found $bucket_count R2 buckets"
    fi
    
    echo ""
    echo "üéâ Troubleshooting complete!"
    echo "üí° Try: cfinfo to see current status"
}

# Generate temporary signed URL for private files (valid for 1 hour)
cfsign() {
    local file_path="$1"
    local bucket_name="${2:-files-private}"
    local duration="${3:-3600}"  # Default 1 hour
    
    if [[ -z "$file_path" ]]; then
        echo "Usage: cfsign FILE_PATH [BUCKET_NAME] [DURATION_SECONDS]"
        echo ""
        echo "Examples:"
        echo "  cfsign document.pdf                    # 1 hour access"
        echo "  cfsign image.jpg screenshots-private   # From specific bucket"
        echo "  cfsign file.zip files-private 86400    # 24 hour access"
        return 1
    fi
    
    echo "üîê Generating signed URL for: $bucket_name/$file_path"
    echo "‚è±Ô∏è  Valid for: $duration seconds"
    
    # Generate presigned URL using wrangler (requires Worker implementation)
    local account_id=$(wrangler whoami 2>/dev/null | grep -A1 "Account ID" | tail -1 | awk -F'‚îÇ' '{print $3}' | xargs)
    
    if [[ -n "$account_id" ]]; then
        # For now, show the private object path
        echo "üîó Private object: $bucket_name/$file_path"
        echo "üí° Signed URLs require Worker implementation"
        echo "   Alternative: Use cftemp to create temporary public copy"
    fi
}

# Share file temporarily using Cloudflare Pages
cftemp_function() {
    local file_path=""
    local duration_hours="24"
    local password=""
    local protected=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--expire)
                duration_hours="$2"
                shift 2
                ;;
            -p|--password)
                password="$2"
                protected=true
                shift 2
                ;;
            -h|--help)
                echo "Usage: cftemp FILE [OPTIONS]"
                echo ""
                echo "Options:"
                echo "  -e, --expire HOURS    Set expiration time in hours (default: 24)"
                echo "  -p, --password PASS   Password protect the temporary share"
                echo "  -h, --help           Show this help message"
                echo ""
                echo "Examples:"
                echo "  cftemp document.pdf                    # Share for 24 hours, public"
                echo "  cftemp image.jpg -e 2                  # Share for 2 hours, public"
                echo "  cftemp secret.txt -p mypassword        # Share for 24 hours, password-protected"
                echo "  cftemp report.pdf -e 4 -p secret123    # Share for 4 hours, password-protected"
                return 0
                ;;
            *)
                file_path="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$file_path" ]]; then
        echo "‚ùå No file specified"
        echo "Usage: cftemp FILE [OPTIONS]"
        echo "Use 'cftemp -h' for help"
        return 1
    fi
    
    if [[ ! -f "$file_path" ]]; then
        echo "‚ùå File not found: $file_path"
        return 1
    fi
    
    echo "üì§ Creating temporary share..."
    
    # Generate temporary filename with expiry timestamp
    local timestamp=$(date +%s)
    local expiry=$((timestamp + (duration_hours * 3600)))
    local filename=$(basename "$file_path")
    local temp_name="temp_${expiry}_${filename}"
    
    if [[ "$protected" == true ]]; then
        echo "üîê Creating password-protected temporary share..."
        # Use password protection via our cfprotect_function
        # Create temp file with the temp name for protected upload
        local temp_file="/tmp/$temp_name"
        cp "$file_path" "$temp_file"
        cfprotect_function "$temp_file" "$password"
        rm -f "$temp_file"
        
        # Store expiry info in a temp log for cleanup
        echo "$temp_name:$expiry:protected" >> ~/.cf-temp-shares.log
        
        echo "‚úÖ Password-protected temporary share created!"
        echo "‚è∞ Expires in: $duration_hours hours"
        echo "üîë Password required for access"
    else
        echo "üåç Creating public temporary share..."
        # Use public Pages upload
        local temp_file="/tmp/$temp_name"
        cp "$file_path" "$temp_file"
        cfpage-upload "$temp_file" "$temp_name"
        rm -f "$temp_file"
        
        # Store expiry info in a temp log for cleanup
        echo "$temp_name:$expiry:public" >> ~/.cf-temp-shares.log
        
        echo "‚úÖ Public temporary share created!"
        echo "‚è∞ Expires in: $duration_hours hours"
    fi
    
    echo ""
    echo "üí° Remember to clean up expired shares with: cfclean"
}

# Clean up expired temporary shares from Pages
cfclean_function() {
    echo "üßπ Cleaning up expired temporary shares..."
    
    local public_dir="$HOME/public-files"
    local current_time=$(date +%s)
    local cleaned=0
    
    cd "$public_dir" || return 1
    
    # Check each temp file
    for file in temp_*; do
        if [[ -f "$file" ]]; then
            # Extract expiry time from filename
            if [[ "$file" =~ temp_([0-9]+)_ ]]; then
                local expiry="${BASH_REMATCH[1]}"
                if [[ "$current_time" -gt "$expiry" ]]; then
                    echo "üóëÔ∏è  Removing expired: $file"
                    rm "$file"
                    ((cleaned++))
                fi
            fi
        fi
    done
    
    # Update files.json to remove expired entries
    if [[ -f "files.json" ]] && [[ $cleaned -gt 0 ]]; then
        local temp_json=$(mktemp)
        jq '[.[] | select(.name | test("^temp_") | not)]' files.json > "$temp_json" 2>/dev/null || echo "[]" > "$temp_json"
        
        # Add back non-expired temp files
        for file in temp_*; do
            if [[ -f "$file" ]]; then
                jq --arg name "$file" --arg size "$(ls -lh "$file" | awk '{print $5}')" \
                   '. + [{"name": $name, "size": $size}]' "$temp_json" > "${temp_json}.new" && \
                   mv "${temp_json}.new" "$temp_json"
            fi
        done
        
        mv "$temp_json" files.json
        
        # Redeploy if we cleaned anything
        echo "üöÄ Redeploying to update Pages..."
        npx wrangler pages deploy . --project-name public-files >/dev/null 2>&1
    fi
    
    echo "‚úÖ Cleanup complete. Removed $cleaned expired files."
    cd - > /dev/null
}

# ============================================
# Cloudflare Aliases - Short Commands
# ============================================

# Core Wrangler functions
alias cfsync=cfsync_function      # Sync secrets from .env
alias cfs=cfsync_function         # Short alias for sync
alias cfget=cfget_function        # Get a secret value  
alias cfg=cfget_function          # Short alias for get
alias cflist=_cflist_function     # List all secrets
alias cfdeploy=cfdeploy_function  # Deploy worker to production
alias cfd=cfdeploy_function       # Short alias for deploy
alias cfinfo=cfinfo_function      # Show Cloudflare setup info

# R2 Storage functions
alias cfupload=cfupload_function      # Upload file to R2 bucket
alias cfu=cfupload_function           # Short: upload
alias cfdownload=cfdownload_function  # Download file from R2 bucket
alias cfdown=cfdownload_function      # Short: download
alias cffiles=cffiles_function        # List files in R2 bucket
alias cfls=cffiles_function           # Short: list files
alias cff=cffiles_function            # Even shorter: files
alias cfdelete=cfdelete_function      # Delete file from R2 bucket
alias cfrm=cfdelete_function          # Short: remove
alias cfbackup=cfbackup_function      # Backup local directory to R2
alias cfbak=cfbackup_function         # Short: backup

# Tunnel functions
alias cftunnel=cftunnel_function      # Cloudflare tunnel
alias funnel=funnel_function          # Tailscale funnel

# Screenshot functions
alias cfshot=cfshot_function      # Main screenshot function
alias cfscreen=cfshot_function    # Alias for cfshot
alias cfss=cfshot_function        # Short alias for screenshot

# Public file sharing (Pages)
alias cfpublic=cfpage-upload    # Upload file for public access
alias cfpu=cfpu_enhanced        # Enhanced upload with password option
alias cfshare=cfpage-upload      # Share file publicly
alias cfprotect=cfprotect_function  # Password-protected upload
alias cfps=cfpage-shot           # Screenshot to public Pages
alias cfpscreen=cfpage-shot      # Public screenshot
alias cfpl=cfpage-list           # List public files
alias cfpls=cfpage-list          # List public files (alt)

# Temporary sharing
alias cftemp=cftemp_function     # Create temporary share link
alias cftmp=cftemp_function      # Short alias for temp share
alias cfclean=cfclean_function   # Clean expired temp shares

# Database functions (when configured)
alias cfdb=cfd1               # D1 database operations
# cfkv would be defined when KV is configured

# Help and setup
cfhelp_function() {
    echo "
üöÄ Cloudflare Quick Commands:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üì§ UPLOAD & SHARE:
  cfpublic FILE   - Share file publicly via Pages
  cfu FILE        - Upload to private R2 bucket  
  cftemp FILE     - Create temporary share link
  
üì∏ SCREENSHOTS:
  cfshot          - Screenshot to private R2
  cfps            - Screenshot to public Pages
  
üìÅ FILE MANAGEMENT:
  cfls            - List files in R2 bucket
  cfpl            - List public files on Pages
  cfdown FILE     - Download from R2 bucket
  cfrm FILE       - Delete from R2 bucket
  
üîê SECRETS:
  cfs             - Sync secrets from .env
  cfg KEY         - Get secret value
  cflist          - List all secrets
  
üõ†Ô∏è  DEVELOPMENT:
  cfdev           - Start local dev server
  cfd             - Deploy to production
  cflog           - View worker logs
  
üí° Type cfhelp or cf for this help menu
"
}

# Even shorter aliases for most common operations
alias cfhelp=cfhelp_function     # Help function
alias cf=cfhelp_function          # Show help

restore_original_mac() {
    local interface_input="$1"
    local interface_name
    
    # If interface is provided, convert friendly name to device name if needed
    if [[ -n "$interface_input" ]]; then
        if [[ "$interface_input" == "Wi-Fi" || "$interface_input" == "wifi" || "$interface_input" == "WIFI" ]]; then
            # Look up the device name for Wi-Fi
            interface_name=$(networksetup -listallhardwareports | grep -A 1 "Wi-Fi" | grep "Device:" | awk '{print $2}')
            echo "Converting Wi-Fi to device name: $interface_name"
        elif [[ "$interface_input" =~ ^en[0-9]+$ ]]; then
            # Already a device name
            interface_name="$interface_input"
        else
            # Try to find the device name for the given hardware port
            interface_name=$(networksetup -listallhardwareports | grep -A 1 "$interface_input" | grep "Device:" | awk '{print $2}')
            if [[ -z "$interface_name" ]]; then
                echo "Error: Could not find device name for '$interface_input'"
                echo "Available interfaces:"
                networksetup -listallhardwareports | grep -E "Hardware Port:|Device:|Ethernet Address:" | sed 's/^/  /'
                return 1
            fi
            echo "Converting '$interface_input' to device name: $interface_name"
        fi
    # If no interface specified, show available ones with saved MACs
    else
        local saved_interfaces=()
        for file in "$HOME"/.mac_*; do
            if [[ -f "$file" ]]; then
                saved_interfaces+=($(basename "$file" | sed 's/^.mac_//'))
            fi
        done
        
        if [[ ${#saved_interfaces[@]} -eq 0 ]]; then
            echo "No interfaces found with saved original MAC addresses."
            return 1
        fi
        
        echo "Select an interface to restore original MAC address:"
        select interface_name in "${saved_interfaces[@]}"; do
            if [[ -n "$interface_name" ]]; then
                break
            else
                echo "Invalid selection. Please try again."
            fi
        done
    fi
    
    # Check if we have a saved MAC for this interface
    local mac_file="$HOME/.mac_$interface_name"
    if [[ ! -f "$mac_file" ]]; then
        echo "No saved original MAC address found for $interface_name"
        return 1
    fi
    
    # Get the original MAC address
    local original_mac
    original_mac=$(cat "$mac_file")
    
    echo "Restoring original MAC address ($original_mac) for $interface_name..."
    
    # Use our change_mac_address function to do the actual change
    if change_mac_address "$original_mac" "$interface_name"; then
        echo "Original MAC address successfully restored"
        rm "$mac_file"  # Remove the saved file since we've restored the original
        return 0
    else
        echo "Failed to restore original MAC address"
        return 1
    fi
}