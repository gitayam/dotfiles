# Debug line to verify file is sourced
echo "Loading encryption functions..."

# ----------------------
# Password and Encryption Functions
# ----------------------

# Generate secure passwords
generate_password() {
    # Default password type is phrases using diceware
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: generate_password [-p type] [-l length] [-m] [-c] [-s] [-q] [-n]"
        echo "Options:"
        echo "  -p type       Password type: phrases (default), chars (random characters), numbers, or hex"
        echo "  -l length     Length of the password (default: 6 words for phrases, 22 chars for others)"
        echo "  -m            Manual mode - prompt for password instead of generating"
        echo "  -c            Copy the generated password to clipboard"
        echo "  -s            Include special characters (for chars type only)"
        echo "  -q            Quiet mode - only output the password (useful for scripting)"
        echo "  -n            No spaces in passphrase (for phrases type only)"
        return 0
    fi
    
    # For macOS, check for brew-installed diceware
    local has_diceware=false
    if command -v diceware &> /dev/null; then
        has_diceware=true
    fi
    
    local password_type="phrases"
    local length=6  # Default 6 words for phrases
    local char_length=22  # Default 22 chars for character passwords
    local manual_mode=false
    local copy_to_clipboard=false
    local include_special=false
    local quiet_mode=false
    local no_spaces=false
    local password=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -p requires a type argument (phrases, chars, numbers, hex)" >&2
                    return 1
                fi
                password_type="$2"
                shift 2
                ;;
            -l)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -l requires a length argument" >&2
                    return 1
                fi
                if [[ ! "$2" =~ ^[0-9]+$ ]]; then
                    echo "Error: Length must be a number" >&2
                    return 1
                fi
                if [[ "$password_type" == "phrases" ]]; then
                    length="$2"
                else
                    char_length="$2"
                fi
                shift 2
                ;;
            -m)
                manual_mode=true
                shift
                ;;
            -c)
                copy_to_clipboard=true
                shift
                ;;
            -s)
                include_special=true
                shift
                ;;
            -q)
                quiet_mode=true
                shift
                ;;
            -n)
                no_spaces=true
                shift
                ;;
            *)
                if ! $quiet_mode; then
                    echo "Unknown option: $1" >&2
                    echo "Use 'generate_password -h' for help." >&2
                fi
                return 1
                ;;
        esac
    done
    
    # If manual mode, prompt for password
    if $manual_mode; then
        if ! $quiet_mode; then
            echo "Enter your password (input will be hidden):" >&2
        fi
        read -s password
        if ! $quiet_mode; then
            echo "Confirm password:" >&2
        fi
        read -s password_confirm
        
        if [[ "$password" != "$password_confirm" ]]; then
            if ! $quiet_mode; then
                echo "Error: Passwords do not match." >&2
            fi
            return 1
        fi
        
        if ! $quiet_mode; then
            echo "Password set manually." >&2
        fi
    else
        # Generate password based on type
        case "$password_type" in
            phrases)
                if ! $has_diceware; then
                    if ! $quiet_mode; then
                        echo "Error: 'diceware' is not installed but required for phrase passwords." >&2
                        echo "You can install it with: brew install diceware" >&2
                        echo -n "Do you want to install diceware now? (y/n): " >&2
                    fi
                    read install_diceware
                    if [[ "$install_diceware" =~ ^[Yy]$ ]]; then
                        brew install diceware
                        has_diceware=true
                    else
                        if ! $quiet_mode; then
                            echo "Falling back to character-based password." >&2
                        fi
                        password_type="chars"
                    fi
                fi
                
                if $has_diceware; then
                    # Use diceware to generate a phrase password
                    password=$(diceware -n "$length" -c -s 2)
                    
                    # Remove spaces if requested
                    if $no_spaces; then
                        password=$(echo "$password" | tr -d ' ')
                    fi
                    
                    if ! $quiet_mode; then
                        echo "Generated passphrase: $password" >&2
                    fi
                else
                    # Use macOS's built-in word list as a fallback if diceware isn't available
                    if [[ -f "/usr/share/dict/words" ]]; then
                        local wordlist="/usr/share/dict/words"
                        local words=()
                        for ((i=1; i<=length; i++)); do
                            # Get a random word from dictionary, filter for appropriate word length (5-8 chars)
                            word=$(cat "$wordlist" | grep -E "^[a-z]{5,8}$" | sort -R | head -n 1)
                            words+=("$word")
                        done
                        
                        # Join words with spaces or nothing based on no_spaces flag
                        if $no_spaces; then
                            password=$(IFS=; echo "${words[*]}")
                        else
                            password=$(IFS=" "; echo "${words[*]}")
                        fi
                    else
                        # If no word list, fall back to random characters
                        password=$(openssl rand -base64 $(($char_length * 2)) | tr -d '/+=' | cut -c1-"$char_length")
                    fi
                    
                    if ! $quiet_mode; then
                        echo "Generated passphrase: $password" >&2
                    fi
                fi
                ;;
                
            chars)
                # Generate a random character password with letters, numbers, and symbols
                if $include_special; then
                    # On macOS, use built-in tools for random generation
                    password=$(LC_ALL=C < /dev/urandom tr -dc 'a-zA-Z0-9!@#$%^&*()_+=-' | head -c "$char_length")
                    
                    # Ensure at least one of each character type for better password strength
                    if [[ ${#password} -ge 4 ]]; then
                        # Get one of each type
                        local lower=$(LC_ALL=C < /dev/urandom tr -dc 'a-z' | head -c 1)
                        local upper=$(LC_ALL=C < /dev/urandom tr -dc 'A-Z' | head -c 1)
                        local number=$(LC_ALL=C < /dev/urandom tr -dc '0-9' | head -c 1)
                        local special=$(LC_ALL=C < /dev/urandom tr -dc '!@#$%^&*()_+=-' | head -c 1)
                        
                        # Replace first 4 characters with our guaranteed types
                        password="${lower}${upper}${number}${special}${password:4}"
                        
                        # Shuffle the password to avoid predictable pattern (macOS compatible)
                        password=$(echo "$password" | fold -w1 | sort -R | tr -d '\n' | head -c "$char_length")
                    fi
                else
                    # Standard character set
                    password=$(LC_ALL=C < /dev/urandom tr -dc 'a-zA-Z0-9' | head -c "$char_length")
                    
                    # Ensure at least one lowercase, one uppercase, and one number
                    if [[ ${#password} -ge 3 ]]; then
                        local lower=$(LC_ALL=C < /dev/urandom tr -dc 'a-z' | head -c 1)
                        local upper=$(LC_ALL=C < /dev/urandom tr -dc 'A-Z' | head -c 1)
                        local number=$(LC_ALL=C < /dev/urandom tr -dc '0-9' | head -c 1)
                        
                        password="${lower}${upper}${number}${password:3}"
                        password=$(echo "$password" | fold -w1 | sort -R | tr -d '\n' | head -c "$char_length")
                    fi
                fi
                
                if ! $quiet_mode; then
                    echo "Generated password: $password" >&2
                fi
                ;;
                
            numbers)
                # Generate a random numeric password
                password=$(LC_ALL=C < /dev/urandom tr -dc '0-9' | head -c "$char_length")
                if ! $quiet_mode; then
                    echo "Generated numeric password: $password" >&2
                fi
                ;;
                
            hex)
                # Generate a random hexadecimal password
                password=$(LC_ALL=C < /dev/urandom tr -dc 'a-f0-9' | head -c "$char_length")
                if ! $quiet_mode; then
                    echo "Generated hex password: $password" >&2
                fi
                ;;
                
            *)
                if ! $quiet_mode; then
                    echo "Error: Invalid password type '$password_type'. Use phrases, chars, numbers, or hex." >&2
                fi
                return 1
                ;;
        esac
    fi
    
    # Copy to clipboard if requested - use pbcopy on macOS
    if $copy_to_clipboard && [[ -n "$password" ]]; then
        echo -n "$password" | pbcopy
        if ! $quiet_mode; then
            echo "Password copied to clipboard." >&2
        fi
    fi
    
    if ! $quiet_mode; then
        echo "Save this password securely!" >&2
    fi
    
    # Return the password as the function result
    echo "$password"
}

# Common aliases for password generation
alias genpass="generate_password -c"
alias genpassphrase="generate_password -p phrases -c"
alias genpin="generate_password -p numbers -l 6 -c"

# Encryption/Decryption aliases
alias encrypt="encrypt_file"
alias decrypt="decrypt_file"
alias encrypt_simple="encrypt_file_simple"
alias decrypt_simple="decrypt_file_simple"

# Quick encryption with deletion of original
alias encrypt_delete="encrypt_file -d"
alias encrypt_simple_delete="encrypt_file_simple -d"

# Batch operations
alias batch_enc="batch_encrypt"
alias batch_enc_simple="batch_encrypt -s"
alias batch_enc_github="batch_encrypt -g"

# Security aliases
alias secure_rm="secure_delete"
alias secure_del="secure_delete"
alias wipe="secure_delete -p 7 -r"  # More thorough deletion

# GPG helpers
alias gpg_keys="gpg_key_info"
alias gpg_list="gpg --list-keys --keyid-format SHORT"
alias gpg_list_secret="gpg --list-secret-keys --keyid-format SHORT"
alias gpg_import="import_gpg_key"
alias gpg_import_github="import_gpg_key -g"

# Quick GitHub key operations
alias encrypt_github="encrypt_for_github" # Use like: encrypt_github file.txt github_username
alias github_key="import_gpg_key -g"
alias github_encrypt="encrypt_for_github"

# Function to encrypt a file using GPG
encrypt_file() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: encrypt_file [options] [file] [recipient]"
        echo "  Encrypts a file using GPG."
        echo ""
        echo "Options:"
        echo "  -o, --output FILE    Specify output filename"
        echo "  -a, --armor          Create ASCII-armored output"
        echo "  -c, --compress       Compress before encrypting"
        echo "  -d, --delete         Delete original file after encryption"
        echo "  -v, --verbose        Verbose output"
        echo "  -z, --zip LEVEL      Compression level (0-9, default: 6)"
        echo "  -g, --github         Treat recipient as GitHub username"
        echo ""
        echo "Arguments:"
        echo "  file                 File to encrypt"
        echo "  recipient            GPG recipient email/key or GitHub username (optional, uses symmetric if not provided)"
        echo ""
        echo "Examples:"
        echo "  encrypt_file document.txt                    # Symmetric encryption"
        echo "  encrypt_file document.txt user@example.com  # Public key encryption"
        echo "  encrypt_file -g document.txt username       # GitHub username encryption"
        echo "  encrypt_file -a -o secret.asc data.txt      # ASCII armor output"
        return 0
    fi
    
    local output_file=""
    local use_armor=false
    local use_compression=false
    local delete_original=false
    local verbose=false
    local compression_level=6
    local use_github=false
    local file=""
    local recipient=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -a|--armor)
                use_armor=true
                shift
                ;;
            -c|--compress)
                use_compression=true
                shift
                ;;
            -d|--delete)
                delete_original=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -z|--zip)
                compression_level="$2"
                use_compression=true
                shift 2
                ;;
            -g|--github)
                use_github=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                elif [[ -z "$recipient" ]]; then
                    recipient="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if file exists
    if [[ ! -f "$file" ]]; then
        echo "Error: File '$file' not found."
        return 1
    fi
    
    # Check if GPG is installed
    if ! command -v gpg &> /dev/null; then
        echo "Error: GPG is not installed."
        echo "Install it with: brew install gnupg"
        return 1
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" ]]; then
        if $use_armor; then
            output_file="${file}.asc"
        else
            output_file="${file}.gpg"
        fi
    fi
    
    # Check if output file already exists
    if [[ -f "$output_file" ]]; then
        echo -n "Output file '$output_file' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Encryption cancelled."
            return 1
        fi
    fi
    
    # Build GPG command
    local gpg_cmd="gpg"
    local gpg_args=()
    
    if $use_armor; then
        gpg_args+=(--armor)
    fi
    
    if $use_compression; then
        gpg_args+=(--compress-algo 2 --compress-level "$compression_level")
    fi
    
    if $verbose; then
        gpg_args+=(--verbose)
    fi
    
    gpg_args+=(--output "$output_file")
    
    # Encrypt with recipient's public key or use symmetric encryption
    if [[ -n "$recipient" ]]; then
        # If GitHub flag is set, try to import key from GitHub first
        if $use_github; then
            echo "Looking up GPG key for GitHub user: $recipient"
            if ! import_gpg_key -g "$recipient"; then
                echo "Error: Could not import GPG key for GitHub user: $recipient"
                return 1
            fi
        fi
        
        # Try to find and import recipient key if not found locally
        if ! gpg --list-keys "$recipient" &>/dev/null; then
            if ! $use_github; then
                echo "Public key for '$recipient' not found locally."
                
                # Try to import from key servers or GitHub
                if ! import_gpg_key "$recipient"; then
                    echo "Error: Could not find or import public key for '$recipient'"
                    echo "Available local keys:"
                    gpg --list-keys --keyid-format SHORT
                    return 1
                fi
            fi
        fi
        
        # Check key trust level
        local trust_level=$(gpg --list-keys --with-colons "$recipient" | awk -F: '/^pub:/ {print $2}')
        if [[ "$trust_level" == "q" || "$trust_level" == "n" ]]; then
            echo "Warning: The key for '$recipient' is not trusted."
            echo "You may want to verify the key fingerprint and sign it with: gpg --sign-key '$recipient'"
            echo -n "Continue anyway? (y/N): "
            read response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                echo "Encryption cancelled."
                return 1
            fi
        fi
        
        # Public key encryption
        gpg_args+=(--encrypt --recipient "$recipient")
        $verbose && echo "Encrypting for recipient: $recipient"
    else
        # Symmetric encryption (password-based)
        gpg_args+=(--symmetric --cipher-algo AES256)
        $verbose && echo "Using symmetric encryption with AES256"
    fi
    
    gpg_args+=("$file")
    
    # Execute encryption
    if $verbose; then
        echo "Executing: $gpg_cmd ${gpg_args[*]}"
    fi
    
    if "$gpg_cmd" "${gpg_args[@]}"; then
        # Set restrictive permissions on encrypted file
        chmod 600 "$output_file"
        
        echo "File encrypted successfully: $output_file"
        
        # Delete original file if requested
        if $delete_original; then
            if secure_delete "$file"; then
                echo "Original file securely deleted."
            else
                echo "Warning: Failed to securely delete original file."
            fi
        fi
        
        return 0
    else
        echo "Error: Encryption failed."
        return 1
    fi
}

# Function to decrypt a GPG-encrypted file
# Enhanced file decryption with multiple backends
decrypt_file() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: decrypt_file [options] [encrypted_file] [output_file]"
        echo "  Auto-detects encryption type and decrypts files."
        echo ""
        echo "Options:"
        echo "  -m, --method TYPE    Force decryption method (gpg, openssl, age)"
        echo "  -o, --output FILE    Specify output filename"
        echo "  -d, --delete         Delete encrypted file after decryption"
        echo "  -v, --verbose        Verbose output"
        echo "  -k, --key FILE       Use specific key file (for AGE)"
        echo "  -f, --force          Overwrite output file if it exists"
        echo "  -t, --test           Test decryption without writing output"
        echo ""
        echo "Examples:"
        echo "  decrypt_file document.txt.gpg"
        echo "  decrypt_file -m age -k ~/.age/keys.txt file.age"
        echo "  decrypt_file -o original.txt file.enc"
        return 0
    fi
    
    local method=""
    local output_file=""
    local delete_encrypted=false
    local verbose=false
    local key_file=""
    local force_overwrite=false
    local test_only=false
    local encrypted_file=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -m|--method)
                method="$2"
                shift 2
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -d|--delete)
                delete_encrypted=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -k|--key)
                key_file="$2"
                shift 2
                ;;
            -f|--force)
                force_overwrite=true
                shift
                ;;
            -t|--test)
                test_only=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$encrypted_file" ]]; then
                    encrypted_file="$1"
                elif [[ -z "$output_file" ]]; then
                    output_file="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if encrypted file exists
    if [[ ! -f "$encrypted_file" ]]; then
        echo "Error: Encrypted file '$encrypted_file' not found."
        return 1
    fi
    
    # Auto-detect method if not specified
    if [[ -z "$method" ]]; then
        case "$encrypted_file" in
            *.gpg|*.asc)
                method="gpg"
                ;;
            *.age|*.age.txt)
                method="age"
                ;;
            *.enc|*.enc.b64)
                method="openssl"
                ;;
            *)
                # Try to detect by file content
                if gpg --list-packets "$encrypted_file" &>/dev/null; then
                    method="gpg"
                elif head -c 50 "$encrypted_file" | grep -q "age-encryption"; then
                    method="age"
                else
                    method="openssl"
                fi
                ;;
        esac
        $verbose && echo "Auto-detected method: $method"
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" ]]; then
        case "$method" in
            gpg)
                output_file="${encrypted_file%.gpg}"
                output_file="${output_file%.asc}"
                ;;
            age)
                output_file="${encrypted_file%.age}"
                output_file="${output_file%.age.txt}"
                ;;
            openssl)
                output_file="${encrypted_file%.enc}"
                output_file="${output_file%.enc.b64}"
                ;;
        esac
        
        # If the file didn't have a recognized extension, add .decrypted
        if [[ "$output_file" == "$encrypted_file" ]]; then
            output_file="${encrypted_file}.decrypted"
        fi
    fi
    
    # Check if output file already exists
    if [[ -f "$output_file" ]] && ! $force_overwrite && ! $test_only; then
        echo -n "Output file '$output_file' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Decryption cancelled."
            return 1
        fi
    fi
    
    $verbose && echo "Decrypting '$encrypted_file' to '$output_file' using $method"
    
    # Decrypt based on method
    case "$method" in
        gpg)
            if ! command -v gpg &>/dev/null; then
                echo "Error: GPG is not installed."
                echo "Install it with: brew install gnupg"
                return 1
            fi
            
            local gpg_args=(--decrypt)
            
            if $verbose; then
                gpg_args+=(--verbose)
            fi
            
            if ! $test_only; then
                gpg_args+=(--output "$output_file")
            fi
            
            gpg_args+=("$encrypted_file")
            
            if $test_only; then
                echo "Testing GPG decryption of '$encrypted_file'..."
                if gpg "${gpg_args[@]}" >/dev/null 2>&1; then
                    echo "Decryption test successful - file can be decrypted."
                    return 0
                else
                    echo "Decryption test failed."
                    return 1
                fi
            else
                if gpg "${gpg_args[@]}"; then
                    echo "File decrypted successfully: $output_file"
                    # Set secure permissions
                    chmod 600 "$output_file"
                else
                    echo "Error: GPG decryption failed."
                    return 1
                fi
            fi
            ;;
            
        age)
            if ! command -v age &>/dev/null; then
                echo "Error: AGE is not installed."
                echo "Install it with: brew install age"
                return 1
            fi
            
            local age_args=(--decrypt)
            
            # Add key file if specified
            if [[ -n "$key_file" ]]; then
                if [[ ! -f "$key_file" ]]; then
                    echo "Error: Key file '$key_file' not found."
                    return 1
                fi
                age_args+=(-i "$key_file")
            else
                # Try default key locations
                local default_keys=(
                    "$HOME/.age/keys.txt"
                    "$HOME/.config/age/keys.txt"
                )
                
                for key_path in "${default_keys[@]}"; do
                    if [[ -f "$key_path" ]]; then
                        age_args+=(-i "$key_path")
                        $verbose && echo "Using key file: $key_path"
                        break
                    fi
                done
            fi
            
            age_args+=("$encrypted_file")
            
            if $test_only; then
                echo "Testing AGE decryption of '$encrypted_file'..."
                if age "${age_args[@]}" >/dev/null 2>&1; then
                    echo "Decryption test successful - file can be decrypted."
                    return 0
                else
                    echo "Decryption test failed."
                    return 1
                fi
            else
                if $verbose; then
                    echo "Executing: age ${age_args[*]} > $output_file"
                fi
                
                if age "${age_args[@]}" > "$output_file"; then
                    echo "File decrypted successfully: $output_file"
                    # Set secure permissions
                    chmod 600 "$output_file"
                else
                    echo "Error: AGE decryption failed."
                    [[ -f "$output_file" ]] && rm -f "$output_file"
                    return 1
                fi
            fi
            ;;
            
        openssl)
            # Detect if file is base64 encoded
            local is_base64=false
            if [[ "$encrypted_file" == *.b64 ]] || file "$encrypted_file" | grep -q "ASCII text"; then
                is_base64=true
            fi
            
            # Try different ciphers
            local ciphers=("aes-256-gcm" "aes-256-cbc")
            local success=false
            
            for cipher in "${ciphers[@]}"; do
                $verbose && echo "Trying cipher: $cipher"
                
                local openssl_args=(enc "-d" "-$cipher" -pbkdf2)
                
                if $is_base64; then
                    openssl_args+=(-a)
                fi
                
                openssl_args+=(-in "$encrypted_file")
                
                if $test_only; then
                    echo "Testing OpenSSL decryption of '$encrypted_file' with $cipher..."
                    if openssl "${openssl_args[@]}" >/dev/null 2>&1; then
                        echo "Decryption test successful - file can be decrypted with $cipher."
                        return 0
                    fi
                else
                    openssl_args+=(-out "$output_file")
                    
                    if openssl "${openssl_args[@]}" 2>/dev/null; then
                        echo "File decrypted successfully: $output_file (using $cipher)"
                        # Set secure permissions
                        chmod 600 "$output_file"
                        success=true
                        break
                    fi
                fi
            done
            
            if $test_only; then
                echo "Decryption test failed with all ciphers."
                return 1
            elif ! $success; then
                echo "Error: OpenSSL decryption failed with all ciphers."
                [[ -f "$output_file" ]] && rm -f "$output_file"
                return 1
            fi
            ;;
            
        *)
            echo "Error: Unknown decryption method '$method'."
            echo "Supported methods: gpg, openssl, age"
            return 1
            ;;
    esac
    
    # Delete encrypted file if requested (only for successful decryption)
    if $delete_encrypted && ! $test_only; then
        if secure_delete "$encrypted_file"; then
            echo "Encrypted file securely deleted."
        else
            echo "Warning: Failed to securely delete encrypted file."
        fi
    fi
    
    return 0
}

# Quick file encryption with OpenSSL (for when GPG is not needed)
encrypt_file_simple() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: encrypt_file_simple [options] [file]"
        echo "  Simple encryption using OpenSSL AES-256-GCM (authenticated encryption)."
        echo ""
        echo "Options:"
        echo "  -o, --output FILE    Specify output filename"
        echo "  -b, --base64         Create base64-encoded output"
        echo "  -d, --delete         Delete original file after encryption"
        echo "  -v, --verbose        Verbose output"
        echo "  -i, --iterations N   Key derivation iterations (default: 100000)"
        echo ""
        echo "Examples:"
        echo "  encrypt_file_simple document.txt"
        echo "  encrypt_file_simple -b -o secret.txt.b64 data.txt"
        return 0
    fi
    
    local output_file=""
    local use_base64=false
    local delete_original=false
    local verbose=false
    local iterations=100000
    local file=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -b|--base64)
                use_base64=true
                shift
                ;;
            -d|--delete)
                delete_original=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -i|--iterations)
                iterations="$2"
                shift 2
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if file exists
    if [[ ! -f "$file" ]]; then
        echo "Error: File '$file' not found."
        return 1
    fi
    
    # Check if OpenSSL supports AES-256-GCM
    if ! openssl enc -list | grep -q "aes-256-gcm"; then
        echo "Error: OpenSSL doesn't support AES-256-GCM. Falling back to AES-256-CBC."
        local cipher="aes-256-cbc"
    else
        local cipher="aes-256-gcm"
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" ]]; then
        if $use_base64; then
            output_file="${file}.enc.b64"
        else
            output_file="${file}.enc"
        fi
    fi
    
    # Check if output file already exists
    if [[ -f "$output_file" ]]; then
        echo -n "Output file '$output_file' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Encryption cancelled."
            return 1
        fi
    fi
    
    $verbose && echo "Using cipher: $cipher with $iterations iterations"
    
    # Encrypt using OpenSSL with improved settings
    local openssl_args=(enc "-$cipher" -salt -pbkdf2 -iter "$iterations" -in "$file")
    
    if $use_base64; then
        openssl_args+=(-a -out "$output_file")
    else
        openssl_args+=(-out "$output_file")
    fi
    
    if $verbose; then
        echo "Executing: openssl ${openssl_args[*]}"
    fi
    
    if openssl "${openssl_args[@]}"; then
        # Set restrictive permissions
        chmod 600 "$output_file"
        echo "File encrypted successfully: $output_file"
        echo "Cipher: $cipher, Key derivation: PBKDF2 with $iterations iterations"
        
        # Delete original file if requested
        if $delete_original; then
            if secure_delete "$file"; then
                echo "Original file securely deleted."
            else
                echo "Warning: Failed to securely delete original file."
            fi
        fi
        
        return 0
    else
        echo "Error: Encryption failed."
        return 1
    fi
}

# Modern file encryption with AGE
encrypt_file_age() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: encrypt_file_age [options] [file] [recipient_or_key]"
        echo "  Modern encryption using AGE (simple, secure, modern)."
        echo ""
        echo "Options:"
        echo "  -p, --passphrase     Use passphrase encryption (default)"
        echo "  -r, --recipient KEY  Use public key encryption with recipient"
        echo "  -k, --key FILE       Use key file for encryption"
        echo "  -o, --output FILE    Specify output filename"
        echo "  -d, --delete         Delete original file after encryption"
        echo "  -v, --verbose        Verbose output"
        echo "  -a, --armor          Create ASCII-armored output"
        echo ""
        echo "Arguments:"
        echo "  file                 File to encrypt"
        echo "  recipient_or_key     Recipient public key or path to key file (optional)"
        echo ""
        echo "Examples:"
        echo "  encrypt_file_age document.txt                           # Passphrase encryption"
        echo "  encrypt_file_age -r age1abc123... document.txt          # Public key encryption"
        echo "  encrypt_file_age -k ~/.age/recipient.pub document.txt   # Key file encryption"
        echo "  encrypt_file_age -a -o secret.age.txt data.txt          # ASCII armor"
        echo ""
        echo "Note: Install AGE with: brew install age"
        return 0
    fi
    
    local use_passphrase=true
    local recipient=""
    local key_file=""
    local output_file=""
    local delete_original=false
    local verbose=false
    local use_armor=false
    local file=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--passphrase)
                use_passphrase=true
                shift
                ;;
            -r|--recipient)
                recipient="$2"
                use_passphrase=false
                shift 2
                ;;
            -k|--key)
                key_file="$2"
                use_passphrase=false
                shift 2
                ;;
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -d|--delete)
                delete_original=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -a|--armor)
                use_armor=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                elif [[ -z "$recipient" && -z "$key_file" ]]; then
                    # Auto-detect if it's a key file or recipient
                    if [[ -f "$1" ]]; then
                        key_file="$1"
                        use_passphrase=false
                    else
                        recipient="$1"
                        use_passphrase=false
                    fi
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if file exists
    if [[ ! -f "$file" ]]; then
        echo "Error: File '$file' not found."
        return 1
    fi
    
    # Check if AGE is installed
    if ! command -v age &>/dev/null; then
        echo "Error: AGE is not installed."
        echo "Install it with: brew install age"
        echo ""
        echo "Or visit: https://github.com/FiloSottile/age"
        return 1
    fi
    
    # Validate key file if specified
    if [[ -n "$key_file" && ! -f "$key_file" ]]; then
        echo "Error: Key file '$key_file' not found."
        return 1
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" ]]; then
        if $use_armor; then
            output_file="${file}.age.txt"
        else
            output_file="${file}.age"
        fi
    fi
    
    # Check if output file already exists
    if [[ -f "$output_file" ]]; then
        echo -n "Output file '$output_file' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Encryption cancelled."
            return 1
        fi
    fi
    
    # Build AGE command
    local age_args=()
    
    if $use_armor; then
        age_args+=(-a)
    fi
    
    age_args+=(-o "$output_file")
    
    if $use_passphrase; then
        age_args+=(-p)
        $verbose && echo "Using passphrase encryption"
    elif [[ -n "$recipient" ]]; then
        age_args+=(-r "$recipient")
        $verbose && echo "Using recipient public key: $recipient"
    elif [[ -n "$key_file" ]]; then
        # Read recipients from key file
        while IFS= read -r key || [[ -n "$key" ]]; do
            # Skip empty lines and comments
            [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
            age_args+=(-r "$key")
        done < "$key_file"
        $verbose && echo "Using key file: $key_file"
    fi
    
    age_args+=("$file")
    
    # Execute encryption
    if $verbose; then
        echo "Executing: age ${age_args[*]}"
    fi
    
    local age_output
    if $use_passphrase; then
        # Capture output to extract generated passphrase
        age_output=$(age "${age_args[@]}" 2>&1)
        local exit_code=$?
        
        if [[ $exit_code -eq 0 ]]; then
            # Try to extract passphrase from output
            local passphrase=$(echo "$age_output" | grep -o 'passphrase: "[^"]*"' | cut -d '"' -f 2)
            if [[ -z "$passphrase" ]]; then
                passphrase=$(echo "$age_output" | grep -o 'passphrase "[^"]*"' | cut -d '"' -f 2)
            fi
            
            if [[ -n "$passphrase" ]]; then
                echo ""
                echo "Generated passphrase: $passphrase"
                echo "Save this passphrase securely - you'll need it to decrypt the file."
                
                # Copy to clipboard if available
                if command -v pbcopy &>/dev/null; then
                    echo -n "$passphrase" | pbcopy
                    echo "Passphrase copied to clipboard."
                fi
            fi
        else
            echo "Error: AGE encryption failed."
            echo "$age_output"
            return 1
        fi
    else
        if ! age "${age_args[@]}"; then
            echo "Error: AGE encryption failed."
            return 1
        fi
    fi
    
    # Set restrictive permissions on encrypted file
    chmod 600 "$output_file"
    
    echo "File encrypted successfully: $output_file"
    
    # Show decryption command
    echo ""
    echo "To decrypt:"
    if $use_passphrase; then
        echo "  age --decrypt $output_file > ${file}"
    elif [[ -n "$recipient" ]]; then
        echo "  age --decrypt -i ~/.age/keys.txt $output_file > ${file}"
    elif [[ -n "$key_file" ]]; then
        echo "  age --decrypt -i ~/.age/keys.txt $output_file > ${file}"
    fi
    
    # Delete original file if requested
    if $delete_original; then
        if secure_delete "$file"; then
            echo "Original file securely deleted."
        else
            echo "Warning: Failed to securely delete original file."
        fi
    fi
    
    return 0
}

# Quick file decryption with OpenSSL
decrypt_file_simple() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: decrypt_file_simple [options] [encrypted_file] [output_file]"
        echo "  Decrypts a file encrypted with encrypt_file_simple."
        echo ""
        echo "Options:"
        echo "  -d, --delete         Delete encrypted file after successful decryption"
        echo "  -v, --verbose        Verbose output"
        echo "  -f, --force          Overwrite output file if it exists"
        echo "  -c, --cipher CIPHER  Specify cipher (auto-detected if not provided)"
        echo "  -i, --iterations N   Key derivation iterations (default: 100000)"
        echo ""
        echo "Examples:"
        echo "  decrypt_file_simple document.txt.enc"
        echo "  decrypt_file_simple -d secret.enc plaintext.txt"
        return 0
    fi
    
    local delete_encrypted=false
    local verbose=false
    local force_overwrite=false
    local cipher=""
    local iterations=100000
    local encrypted_file=""
    local output_file=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -d|--delete)
                delete_encrypted=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -f|--force)
                force_overwrite=true
                shift
                ;;
            -c|--cipher)
                cipher="$2"
                shift 2
                ;;
            -i|--iterations)
                iterations="$2"
                shift 2
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$encrypted_file" ]]; then
                    encrypted_file="$1"
                elif [[ -z "$output_file" ]]; then
                    output_file="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    # Check if file exists
    if [[ ! -f "$encrypted_file" ]]; then
        echo "Error: File '$encrypted_file' not found."
        return 1
    fi
    
    # Auto-detect cipher if not specified
    if [[ -z "$cipher" ]]; then
        # Try to detect if it's base64 encoded
        if [[ "$encrypted_file" =~ \.b64$ ]] || file "$encrypted_file" | grep -q "ASCII text"; then
            local is_base64=true
        else
            local is_base64=false
        fi
        
        # Default to AES-256-GCM if available, otherwise CBC
        if openssl enc -list | grep -q "aes-256-gcm"; then
            cipher="aes-256-gcm"
        else
            cipher="aes-256-cbc"
            echo "Warning: Using AES-256-CBC (GCM not available)"
        fi
    fi
    
    # Set default output file if not specified
    if [[ -z "$output_file" ]]; then
        if [[ "$encrypted_file" =~ \.enc\.b64$ ]]; then
            output_file="${encrypted_file%.enc.b64}"
        elif [[ "$encrypted_file" =~ \.enc$ ]]; then
            output_file="${encrypted_file%.enc}"
        elif [[ "$encrypted_file" =~ \.b64$ ]]; then
            output_file="${encrypted_file%.b64}"
        else
            output_file="${encrypted_file}.decrypted"
        fi
    fi
    
    # Check if output file exists and handle appropriately
    if [[ -f "$output_file" ]] && ! $force_overwrite; then
        echo -n "Output file '$output_file' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Decryption cancelled."
            return 1
        fi
    fi
    
    $verbose && echo "Using cipher: $cipher with $iterations iterations"
    
    # Determine if input is base64 encoded
    local is_base64=false
    if [[ "$encrypted_file" =~ \.b64$ ]] || file "$encrypted_file" | grep -q "ASCII text"; then
        is_base64=true
    fi
    
    # Build OpenSSL command
    local openssl_args=(enc -d "-$cipher" -pbkdf2 -iter "$iterations" -in "$encrypted_file" -out "$output_file")
    
    if $is_base64; then
        openssl_args+=(-a)
    fi
    
    if $verbose; then
        echo "Executing: openssl ${openssl_args[*]}"
    fi
    
    # Decrypt using OpenSSL
    if openssl "${openssl_args[@]}"; then
        # Verify file was created and has content
        if [[ -f "$output_file" && -s "$output_file" ]]; then
            # Set secure permissions on decrypted file
            chmod 600 "$output_file"
            echo "File decrypted successfully: $output_file"
            
            # Delete encrypted file if requested
            if $delete_encrypted; then
                if secure_delete "$encrypted_file"; then
                    echo "Encrypted file securely deleted."
                else
                    echo "Warning: Failed to securely delete encrypted file."
                fi
            fi
            
            return 0
        else
            echo "Error: Decryption appeared to succeed but output file is missing or empty."
            return 1
        fi
    else
        echo "Error: Decryption failed."
        echo "Note: Make sure you're using the correct cipher. Try -c aes-256-cbc for older encrypted files."
        return 1
    fi
}

# Securely delete a file (macOS-compatible)
secure_delete() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: secure_delete [options] [file1] [file2] ..."
        echo "  Securely delete files with multiple overwrite passes."
        echo ""
        echo "Options:"
        echo "  -p, --passes N       Number of overwrite passes (default: 3)"
        echo "  -v, --verbose        Verbose output"
        echo "  -f, --force          Don't prompt for confirmation"
        echo "  -r, --random         Use random data for overwrites"
        echo ""
        echo "Note: On SSDs, secure deletion is less effective due to wear leveling."
        echo "      Consider full-disk encryption for sensitive data on SSDs."
        return 0
    fi
    
    local passes=3
    local verbose=false
    local force=false
    local use_random=false
    local files=()
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--passes)
                passes="$2"
                if ! [[ "$passes" =~ ^[0-9]+$ ]] || [[ "$passes" -lt 1 ]]; then
                    echo "Error: Passes must be a positive number"
                    return 1
                fi
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -f|--force)
                force=true
                shift
                ;;
            -r|--random)
                use_random=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Error: No files specified"
        return 1
    fi
    
    # Check if we're on an SSD (warn user)
    local disk_type=""
    if command -v system_profiler &>/dev/null; then
        disk_type=$(system_profiler SPStorageDataType 2>/dev/null | grep -i "solid state\|ssd" | head -1)
        if [[ -n "$disk_type" ]] && ! $force; then
            echo "Warning: SSD detected. Secure deletion may not be fully effective on SSDs."
            echo -n "Continue anyway? (y/N): "
            read response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                echo "Secure deletion cancelled."
                return 1
            fi
        fi
    fi
    
    # Confirm deletion if not forced
    if ! $force; then
        echo "Files to be securely deleted:"
        printf '  %s\n' "${files[@]}"
        echo -n "Are you sure? This cannot be undone. (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Secure deletion cancelled."
            return 1
        fi
    fi
    
    # Process all files
    local exit_code=0
    for file in "${files[@]}"; do
        # Check if file exists
        if [[ ! -f "$file" ]]; then
            echo "Error: File '$file' not found."
            exit_code=1
            continue
        fi
        
        $verbose && echo "Securely deleting: $file"
        
        # Get file size for progress indication
        local filesize
        if command -v stat &>/dev/null; then
            filesize=$(stat -f "%z" "$file" 2>/dev/null) || filesize=0
        else
            filesize=$(wc -c < "$file" 2>/dev/null) || filesize=0
        fi
        
        # Perform multiple overwrite passes
        local pass_success=true
        for ((pass=1; pass<=passes; pass++)); do
            $verbose && echo "  Pass $pass/$passes..."
            
            if $use_random; then
                # Use random data
                if ! dd if=/dev/urandom of="$file" bs=1024 count=$((filesize/1024 + 1)) conv=notrunc status=none 2>/dev/null; then
                    pass_success=false
                    break
                fi
            else
                # Use zeros (faster and often sufficient)
                if ! dd if=/dev/zero of="$file" bs=1024 count=$((filesize/1024 + 1)) conv=notrunc status=none 2>/dev/null; then
                    pass_success=false
                    break
                fi
            fi
            
            # Sync to ensure data is written
            sync
        done
        
        if $pass_success; then
            # Final deletion
            if rm -f "$file" 2>/dev/null; then
                $verbose && echo "  File securely deleted: $file"
            else
                echo "Error: Failed to remove file: $file"
                exit_code=1
            fi
        else
            echo "Error: Failed to overwrite file: $file"
            exit_code=1
        fi
    done
    
    return $exit_code
}

# Create a password-protected zip archive
secure_zip() {
    if [[ $# -lt 2 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: secure_zip [options] [zipfile] [files/directories...]"
        echo "  Creates a password-protected ZIP archive."
        echo ""
        echo "Options:"
        echo "  -l, --level N        Compression level (0-9, default: 6)"
        echo "  -v, --verbose        Verbose output"
        echo "  -r, --recursive      Include directories recursively"
        echo "  -x, --exclude PATTERN Exclude files matching pattern"
        echo ""
        echo "Examples:"
        echo "  secure_zip backup.zip documents/ photos/"
        echo "  secure_zip -l 9 -r archive.zip /path/to/data"
        return 0
    fi
    
    local compression_level=6
    local verbose=false
    local recursive=false
    local exclude_patterns=()
    local zipfile=""
    local files=()
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -l|--level)
                compression_level="$2"
                if ! [[ "$compression_level" =~ ^[0-9]$ ]]; then
                    echo "Error: Compression level must be 0-9"
                    return 1
                fi
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -r|--recursive)
                recursive=true
                shift
                ;;
            -x|--exclude)
                exclude_patterns+=("$2")
                shift 2
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$zipfile" ]]; then
                    zipfile="$1"
                else
                    files+=("$1")
                fi
                shift
                ;;
        esac
    done
    
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Error: No files specified to archive"
        return 1
    fi
    
    # Add .zip extension if not present
    if [[ ! "$zipfile" =~ \.zip$ ]]; then
        zipfile="${zipfile}.zip"
    fi
    
    # Check if zipfile already exists
    if [[ -f "$zipfile" ]]; then
        echo -n "Archive '$zipfile' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Archive creation cancelled."
            return 1
        fi
    fi
    
    # Build zip command
    local zip_args=("-e" "-$compression_level")
    
    if $recursive; then
        zip_args+=("-r")
    fi
    
    if $verbose; then
        zip_args+=("-v")
    fi
    
    # Add exclude patterns
    for pattern in "${exclude_patterns[@]}"; do
        zip_args+=("-x" "$pattern")
    done
    
    zip_args+=("$zipfile")
    zip_args+=("${files[@]}")
    
    # Create archive
    if $verbose; then
        echo "Creating encrypted ZIP archive..."
        echo "Command: zip ${zip_args[*]}"
    fi
    
    if zip "${zip_args[@]}"; then
        # Set restrictive permissions
        chmod 600 "$zipfile"
        echo "Created encrypted ZIP archive: $zipfile"
        
        # Display archive info
        if $verbose && command -v unzip &>/dev/null; then
            echo ""
            echo "Archive contents:"
            unzip -l "$zipfile"
        fi
        
        return 0
    else
        echo "Error: Failed to create archive"
        return 1
    fi
}

# Batch encrypt multiple files
batch_encrypt() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: batch_encrypt [options] [files...]"
        echo "  Encrypt multiple files in batch."
        echo ""
        echo "Options:"
        echo "  -r, --recipient EMAIL Use GPG public key encryption"
        echo "  -g, --github USER    Use GitHub username for GPG key lookup"
        echo "  -s, --simple         Use OpenSSL simple encryption"
        echo "  -d, --delete         Delete original files after encryption"
        echo "  -v, --verbose        Verbose output"
        echo "  -o, --output-dir DIR Output directory for encrypted files"
        echo ""
        echo "Examples:"
        echo "  batch_encrypt *.txt"
        echo "  batch_encrypt -r user@example.com -d documents/*"
        echo "  batch_encrypt -g username -d documents/*"
        echo "  batch_encrypt -s -o ./encrypted/ *.pdf"
        return 0
    fi
    
    local recipient=""
    local github_user=""
    local use_simple=false
    local delete_original=false
    local verbose=false
    local output_dir=""
    local files=()
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -r|--recipient)
                recipient="$2"
                shift 2
                ;;
            -g|--github)
                github_user="$2"
                shift 2
                ;;
            -s|--simple)
                use_simple=true
                shift
                ;;
            -d|--delete)
                delete_original=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -o|--output-dir)
                output_dir="$2"
                shift 2
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done
    
    # Validate options
    if [[ -n "$recipient" && -n "$github_user" ]]; then
        echo "Error: Cannot specify both --recipient and --github"
        return 1
    fi
    
    if [[ -n "$github_user" && $use_simple == true ]]; then
        echo "Error: GitHub username requires GPG encryption (cannot use with --simple)"
        return 1
    fi
    
    # If GitHub user specified, try to import their key
    if [[ -n "$github_user" ]]; then
        echo "Looking up GPG key for GitHub user: $github_user"
        if import_gpg_key -g "$github_user"; then
            # Use the GitHub user as recipient (GPG will find the right key)
            recipient="$github_user"
        else
            echo "Error: Could not import GPG key for GitHub user: $github_user"
            return 1
        fi
    fi
    
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Error: No files specified"
        return 1
    fi
    
    # Create output directory if specified
    if [[ -n "$output_dir" ]]; then
        if ! mkdir -p "$output_dir"; then
            echo "Error: Cannot create output directory '$output_dir'"
            return 1
        fi
    fi
    
    # Process files
    local success_count=0
    local total_count=${#files[@]}
    
    echo "Encrypting $total_count files..."
    
    for file in "${files[@]}"; do
        if [[ ! -f "$file" ]]; then
            echo "Warning: File '$file' not found, skipping."
            continue
        fi
        
        $verbose && echo "Processing: $file"
        
        # Determine output file path
        local output_file=""
        if [[ -n "$output_dir" ]]; then
            local basename=$(basename "$file")
            if $use_simple; then
                output_file="$output_dir/${basename}.enc"
            else
                output_file="$output_dir/${basename}.gpg"
            fi
        fi
        
        # Encrypt the file
        local encrypt_args=()
        if $verbose; then
            encrypt_args+=("-v")
        fi
        if $delete_original; then
            encrypt_args+=("-d")
        fi
        if [[ -n "$output_file" ]]; then
            encrypt_args+=("-o" "$output_file")
        fi
        encrypt_args+=("$file")
        
        if $use_simple; then
            if [[ -n "$recipient" ]]; then
                echo "Warning: Recipient specified but using simple encryption (ignoring recipient)"
            fi
            if encrypt_file_simple "${encrypt_args[@]}"; then
                ((success_count++))
            fi
        else
            if [[ -n "$recipient" ]]; then
                encrypt_args+=("$recipient")
            fi
            if encrypt_file "${encrypt_args[@]}"; then
                ((success_count++))
            fi
        fi
    done
    
    echo "Batch encryption complete: $success_count/$total_count files processed successfully."
    
    if [[ $success_count -eq $total_count ]]; then
        return 0
    else
        return 1
    fi
}

# GPG key import helper with key server and GitHub support
import_gpg_key() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: import_gpg_key [options] [identifier]"
        echo "  Import a GPG key from key servers or GitHub."
        echo ""
        echo "Options:"
        echo "  -s, --server SERVER  Specify key server (default: keys.openpgp.org)"
        echo "  -g, --github         Treat identifier as GitHub username"
        echo "  -v, --verbose        Verbose output"
        echo "  -t, --timeout N      Timeout in seconds (default: 10)"
        echo ""
        echo "Arguments:"
        echo "  identifier           Email address, key ID, or GitHub username"
        echo ""
        echo "Examples:"
        echo "  import_gpg_key user@example.com"
        echo "  import_gpg_key -g username"
        echo "  import_gpg_key --server hkps://keyserver.ubuntu.com user@example.com"
        return 0
    fi
    
    local keyserver="keys.openpgp.org"
    local use_github=false
    local verbose=false
    local timeout=10
    local identifier=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s|--server)
                keyserver="$2"
                shift 2
                ;;
            -g|--github)
                use_github=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -t|--timeout)
                timeout="$2"
                if ! [[ "$timeout" =~ ^[0-9]+$ ]]; then
                    echo "Error: Timeout must be a number"
                    return 1
                fi
                shift 2
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$identifier" ]]; then
                    identifier="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$identifier" ]]; then
        echo "Error: No identifier provided"
        return 1
    fi
    
    if ! command -v gpg &>/dev/null; then
        echo "Error: GPG is not installed."
        return 1
    fi
    
    $verbose && echo "Searching for GPG key: $identifier"
    
    # Function to try importing from a key server
    try_keyserver_import() {
        local server="$1"
        local id="$2"
        
        $verbose && echo "Trying key server: $server"
        
        # Set timeout for GPG operations
        export GPG_AGENT_INFO=""
        
        # Try to import the key
        if timeout "$timeout" gpg --keyserver "$server" --recv-keys "$id" 2>/dev/null; then
            return 0
        elif timeout "$timeout" gpg --keyserver "$server" --search-keys "$id" </dev/null 2>/dev/null | head -20; then
            echo -n "Found keys on $server. Import the first one? (y/N): "
            read response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                if timeout "$timeout" gpg --keyserver "$server" --recv-keys "$id" 2>/dev/null; then
                    return 0
                fi
            fi
        fi
        return 1
    }
    
    # Function to try importing from GitHub
    try_github_import() {
        local username="$1"
        
        $verbose && echo "Trying GitHub for user: $username"
        
        # Check if curl is available
        if ! command -v curl &>/dev/null; then
            echo "Error: curl is required for GitHub key import"
            return 1
        fi
        
        # Try to get GPG keys from GitHub
        local github_url="https://github.com/${username}.gpg"
        local temp_file=$(mktemp)
        
        if curl -s --max-time "$timeout" --fail "$github_url" -o "$temp_file" 2>/dev/null; then
            # Check if the file contains a valid GPG key
            if grep -q "BEGIN PGP PUBLIC KEY BLOCK" "$temp_file"; then
                echo "Found GPG key on GitHub for user: $username"
                echo -n "Import this key? (y/N): "
                read response
                if [[ "$response" =~ ^[Yy]$ ]]; then
                    if gpg --import "$temp_file" 2>/dev/null; then
                        rm -f "$temp_file"
                        return 0
                    fi
                fi
            else
                $verbose && echo "No valid GPG key found on GitHub for user: $username"
            fi
        else
            $verbose && echo "Could not fetch GPG key from GitHub for user: $username"
        fi
        
        rm -f "$temp_file"
        return 1
    }
    
    # Main import logic
    local import_success=false
    
    if $use_github; then
        # GitHub username provided
        if try_github_import "$identifier"; then
            import_success=true
            echo "Successfully imported GPG key from GitHub for: $identifier"
        fi
    else
        # Email or key ID provided - try key servers first
        local servers=("$keyserver")
        
        # Add common fallback servers if using default
        if [[ "$keyserver" == "keys.openpgp.org" ]]; then
            servers+=("hkps://keyserver.ubuntu.com" "hkps://pgp.mit.edu")
        fi
        
        for server in "${servers[@]}"; do
            if try_keyserver_import "$server" "$identifier"; then
                import_success=true
                echo "Successfully imported GPG key from $server for: $identifier"
                break
            fi
        done
        
        # If key servers failed and identifier looks like it could be a username, try GitHub
        if ! $import_success && [[ "$identifier" =~ ^[a-zA-Z0-9._-]+$ ]] && [[ ! "$identifier" =~ @ ]]; then
            echo "Key servers failed. Trying GitHub as username..."
            if try_github_import "$identifier"; then
                import_success=true
                echo "Successfully imported GPG key from GitHub for: $identifier"
            fi
        fi
    fi
    
    if $import_success; then
        # Display imported key info
        echo ""
        echo "Imported key details:"
        gpg --list-keys --keyid-format LONG "$identifier" 2>/dev/null || {
            # Try to find the key by searching all keys (in case email doesn't match exactly)
            echo "Key imported but may have different identifier. Recent imports:"
            gpg --list-keys --keyid-format LONG | tail -10
        }
        
        echo ""
        echo "Note: You may want to verify and sign this key with: gpg --sign-key [key-id]"
        return 0
    else
        echo "Failed to import GPG key for: $identifier"
        echo ""
        echo "You can try:"
        echo "  1. Manual import: gpg --keyserver $keyserver --search-keys $identifier"
        echo "  2. GitHub import: import_gpg_key -g $identifier"
        echo "  3. Different key server: import_gpg_key -s hkps://keyserver.ubuntu.com $identifier"
        return 1
    fi
}

# GPG key management helper
gpg_key_info() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: gpg_key_info [email]"
        echo "  Display GPG key information."
        echo "  If email is provided, shows info for that specific key."
        echo "  Otherwise, lists all available keys."
        return 0
    fi
    
    if ! command -v gpg &>/dev/null; then
        echo "Error: GPG is not installed."
        return 1
    fi
    
    local email="$1"
    
    if [[ -n "$email" ]]; then
        echo "Key information for: $email"
        echo "================================"
        
        if gpg --list-keys "$email" &>/dev/null; then
            gpg --list-keys --keyid-format LONG "$email"
            echo ""
            echo "Trust level:"
            gpg --list-keys --with-colons "$email" | awk -F: '/^pub:/ {
                trust=$2
                if (trust == "u") print "Ultimate trust"
                else if (trust == "f") print "Full trust"
                else if (trust == "m") print "Marginal trust"
                else if (trust == "n") print "No trust"
                else if (trust == "q") print "Unknown trust"
                else print "Trust level: " trust
            }'
        else
            echo "No key found for: $email"
            return 1
        fi
    else
        echo "Available GPG keys:"
        echo "=================="
        gpg --list-keys --keyid-format SHORT
        
        echo ""
        echo "Secret keys:"
        echo "============"
        gpg --list-secret-keys --keyid-format SHORT
    fi
}

# Convenient wrapper for GitHub GPG encryption
encrypt_for_github() {
    if [[ $# -lt 2 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: encrypt_for_github [options] [file] [github_username]"
        echo "  Quick encryption for GitHub users using their public GPG key."
        echo ""
        echo "Options:"
        echo "  -a, --armor          Create ASCII-armored output"
        echo "  -d, --delete         Delete original file after encryption"
        echo "  -v, --verbose        Verbose output"
        echo ""
        echo "Examples:"
        echo "  encrypt_for_github document.txt username"
        echo "  encrypt_for_github -a -d secret.txt username"
        return 0
    fi
    
    local armor_flag=""
    local delete_flag=""
    local verbose_flag=""
    local file=""
    local github_user=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -a|--armor)
                armor_flag="-a"
                shift
                ;;
            -d|--delete)
                delete_flag="-d"
                shift
                ;;
            -v|--verbose)
                verbose_flag="-v"
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                elif [[ -z "$github_user" ]]; then
                    github_user="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$file" || -z "$github_user" ]]; then
        echo "Error: Both file and GitHub username are required"
        return 1
    fi
    
    # Call encrypt_file with GitHub flag
    encrypt_file $armor_flag $delete_flag $verbose_flag -g "$file" "$github_user"
}

# Generate AGE key pair
generate_age_key() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: generate_age_key [options]"
        echo "  Generate a new AGE key pair for encryption/decryption."
        echo ""
        echo "Options:"
        echo "  -o, --output FILE    Output key file (default: ~/.age/keys.txt)"
        echo "  -p, --public FILE    Output public key file (default: ~/.age/public.txt)"
        echo "  -v, --verbose        Verbose output"
        echo ""
        echo "Examples:"
        echo "  generate_age_key"
        echo "  generate_age_key -o ~/.config/age/my-key.txt"
        return 0
    fi
    
    local key_file="$HOME/.age/keys.txt"
    local public_file="$HOME/.age/public.txt"
    local verbose=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output)
                key_file="$2"
                shift 2
                ;;
            -p|--public)
                public_file="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                echo "Error: Unexpected argument $1"
                return 1
                ;;
        esac
    done
    
    # Check if AGE is installed
    if ! command -v age-keygen &>/dev/null; then
        echo "Error: AGE is not installed."
        echo "Install it with: brew install age"
        return 1
    fi
    
    # Create directories if needed
    mkdir -p "$(dirname "$key_file")"
    mkdir -p "$(dirname "$public_file")"
    
    # Check if key file already exists
    if [[ -f "$key_file" ]]; then
        echo -n "Key file '$key_file' already exists. Overwrite? (y/N): "
        read response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Key generation cancelled."
            return 1
        fi
    fi
    
    $verbose && echo "Generating AGE key pair..."
    
    # Generate key pair
    local output
    output=$(age-keygen 2>&1)
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        # Extract private key and public key
        local private_key=$(echo "$output" | grep "^AGE-SECRET-KEY")
        local public_key=$(echo "$output" | grep "^# public key:" | sed 's/# public key: //')
        
        if [[ -n "$private_key" && -n "$public_key" ]]; then
            # Save private key
            echo "$private_key" > "$key_file"
            chmod 600 "$key_file"
            
            # Save public key
            echo "$public_key" > "$public_file"
            chmod 644 "$public_file"
            
            echo "AGE key pair generated successfully!"
            echo "Private key: $key_file"
            echo "Public key:  $public_file"
            echo ""
            echo "Your public key is: $public_key"
            
            # Copy public key to clipboard if available
            if command -v pbcopy &>/dev/null; then
                echo -n "$public_key" | pbcopy
                echo "Public key copied to clipboard."
            fi
            
            return 0
        else
            echo "Error: Failed to parse key generation output."
            return 1
        fi
    else
        echo "Error: AGE key generation failed."
        echo "$output"
        return 1
    fi
}

# List AGE keys
list_age_keys() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: list_age_keys [options]"
        echo "  List AGE keys from key files."
        echo ""
        echo "Options:"
        echo "  -k, --key-file FILE  Key file to read (default: ~/.age/keys.txt)"
        echo "  -a, --all            List all keys from common locations"
        echo "  -v, --verbose        Verbose output"
        echo ""
        echo "Examples:"
        echo "  list_age_keys"
        echo "  list_age_keys -a"
        return 0
    fi
    
    local key_file=""
    local list_all=false
    local verbose=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -k|--key-file)
                key_file="$2"
                shift 2
                ;;
            -a|--all)
                list_all=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1"
                return 1
                ;;
            *)
                if [[ -z "$key_file" ]]; then
                    key_file="$1"
                else
                    echo "Error: Too many arguments"
                    return 1
                fi
                shift
                ;;
        esac
    done
    
    local key_files=()
    
    if $list_all; then
        # Common AGE key locations
        local common_locations=(
            "$HOME/.age/keys.txt"
            "$HOME/.config/age/keys.txt"
            "$HOME/.age/key.txt"
        )
        
        for location in "${common_locations[@]}"; do
            if [[ -f "$location" ]]; then
                key_files+=("$location")
            fi
        done
    else
        if [[ -n "$key_file" ]]; then
            key_files+=("$key_file")
        else
            key_files+=("$HOME/.age/keys.txt")
        fi
    fi
    
    if [[ ${#key_files[@]} -eq 0 ]]; then
        echo "No AGE key files found."
        echo "Generate a key with: generate_age_key"
        return 1
    fi
    
    echo "AGE Keys:"
    echo "========="
    
    for kf in "${key_files[@]}"; do
        if [[ ! -f "$kf" ]]; then
            $verbose && echo "Key file not found: $kf"
            continue
        fi
        
        echo ""
        echo "Key file: $kf"
        
        local count=0
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            
            if [[ "$line" =~ ^AGE-SECRET-KEY ]]; then
                count=$((count + 1))
                echo "  Private key #$count: ${line:0:20}..."
                
                # Try to get corresponding public key
                if command -v age-keygen &>/dev/null; then
                    local pub_key
                    pub_key=$(echo "$line" | age-keygen -y 2>/dev/null)
                    if [[ -n "$pub_key" ]]; then
                        echo "  Public key #$count:  $pub_key"
                    fi
                fi
            fi
        done < "$kf"
        
        if [[ $count -eq 0 ]]; then
            echo "  No valid AGE keys found in this file."
        fi
    done
    
    # Also check for public key files
    local public_files=(
        "$HOME/.age/public.txt"
        "$HOME/.age/recipients.txt"
    )
    
    for pf in "${public_files[@]}"; do
        if [[ -f "$pf" ]]; then
            echo ""
            echo "Public key file: $pf"
            while IFS= read -r line || [[ -n "$line" ]]; do
                # Skip empty lines and comments
                [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
                
                if [[ "$line" =~ ^age1 ]]; then
                    echo "  Public key: $line"
                fi
            done < "$pf"
        fi
    done
}

# Decrypt file with AGE 
decrypt_file_age() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: decrypt_file_age [options] [encrypted_file] [output_file]"
        echo "  Decrypt AGE-encrypted files."
        echo ""
        echo "Options:"
        echo "  -k, --key FILE       Use specific key file"
        echo "  -o, --output FILE    Specify output filename"
        echo "  -d, --delete         Delete encrypted file after decryption"
        echo "  -v, --verbose        Verbose output"
        echo ""
        echo "Examples:"
        echo "  decrypt_file_age document.age"
        echo "  decrypt_file_age -k ~/.age/keys.txt file.age"
        return 0
    fi
    
    # Use the enhanced decrypt_file function with AGE method
    decrypt_file -m age "$@"
}

# Quick AGE encryption (passphrase)
age_encrypt() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: age_encrypt [file]"
        echo "  Quick AGE passphrase encryption."
        echo ""
        echo "Examples:"
        echo "  age_encrypt document.txt"
        return 0
    fi
    
    encrypt_file_age -p "$1"
}

# Quick AGE decryption
age_decrypt() {
    if [[ $# -lt 1 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: age_decrypt [encrypted_file]"
        echo "  Quick AGE decryption."
        echo ""
        echo "Examples:"
        echo "  age_decrypt document.age"
        return 0
    fi
    
    decrypt_file_age "$1"
}

# Check AGE installation and setup
check_age_setup() {
    echo "AGE Encryption Setup Check"
    echo "========================="
    echo ""
    
    # Check if AGE is installed
    if command -v age &>/dev/null; then
        echo "✓ AGE is installed: $(which age)"
        echo "  Version: $(age --version 2>/dev/null || echo 'Unknown')"
    else
        echo "✗ AGE is not installed"
        echo "  Install with: brew install age"
        echo ""
        return 1
    fi
    
    # Check if age-keygen is available
    if command -v age-keygen &>/dev/null; then
        echo "✓ age-keygen is available: $(which age-keygen)"
    else
        echo "✗ age-keygen is not available"
    fi
    
    echo ""
    
    # Check for key files
    local key_locations=(
        "$HOME/.age/keys.txt"
        "$HOME/.config/age/keys.txt"
        "$HOME/.age/key.txt"
    )
    
    echo "Key Files:"
    local found_keys=false
    for location in "${key_locations[@]}"; do
        if [[ -f "$location" ]]; then
            echo "✓ Found: $location"
            found_keys=true
        else
            echo "✗ Not found: $location"
        fi
    done
    
    if ! $found_keys; then
        echo ""
        echo "No AGE key files found. Generate one with:"
        echo "  generate_age_key"
    fi
    
    echo ""
    
    # Check for public key files
    local public_locations=(
        "$HOME/.age/public.txt"
        "$HOME/.age/recipients.txt"
    )
    
    echo "Public Key Files:"
    local found_public=false
    for location in "${public_locations[@]}"; do
        if [[ -f "$location" ]]; then
            echo "✓ Found: $location"
            found_public=true
        else
            echo "✗ Not found: $location"
        fi
    done
    
    echo ""
    echo "Setup Summary:"
    if command -v age &>/dev/null && $found_keys; then
        echo "✓ AGE is ready to use!"
        echo ""
        echo "Quick commands:"
        echo "  age_encrypt file.txt      # Encrypt with passphrase"
        echo "  age_decrypt file.age      # Decrypt file"
        echo "  list_age_keys            # List your keys"
    else
        echo "✗ AGE setup incomplete"
        echo ""
        echo "Setup steps:"
        if ! command -v age &>/dev/null; then
            echo "1. Install AGE: brew install age"
        fi
        if ! $found_keys; then
            echo "2. Generate keys: generate_age_key"
        fi
    fi
}

# Show encryption method comparison
compare_encryption_methods() {
    echo "Encryption Methods Comparison"
    echo "============================="
    echo ""
    
    printf "%-12s %-15s %-15s %-20s %-25s\n" "Method" "Speed" "Key Mgmt" "Use Case" "Command Example"
    printf "%-12s %-15s %-15s %-20s %-25s\n" "------" "-----" "--------" "--------" "---------------"
    printf "%-12s %-15s %-15s %-20s %-25s\n" "GPG" "Medium" "Complex" "Email/Collab" "encrypt_file doc.txt"
    printf "%-12s %-15s %-15s %-20s %-25s\n" "AGE" "Fast" "Simple" "Modern/Simple" "age_encrypt doc.txt"
    printf "%-12s %-15s %-15s %-20s %-25s\n" "OpenSSL" "Fast" "Password" "Quick/Local" "encrypt_file_simple doc.txt"
    
    echo ""
    echo "Recommendations:"
    echo "• Use AGE for modern, simple encryption needs"
    echo "• Use GPG for email integration and established workflows"
    echo "• Use OpenSSL for quick, local password-based encryption"
    echo ""
    echo "AGE Advantages:"
    echo "• Simple key format (one line)"
    echo "• Fast and memory-efficient"
    echo "• Modern cryptography (ChaCha20Poly1305, X25519)"
    echo "• No configuration needed"
    echo "• Easy to share public keys"
}

# EOF - End of file marker to ensure proper termination

