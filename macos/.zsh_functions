# ----------------------
# General Shell Functions
# ----------------------

# PDF Handling
#using ghost script to convert pdfs to text that are still ocr
# gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile=same_name_with_no_spaces_and_no_special_chars.pdf original.pdf
alias ocr-pdf="handle_pdf -o"
alias extract-text="handle_pdf -t"
alias compress-pdf="handle_pdf -c"
alias rotate-pdf="handle_pdf -r"
alias sanitize-pdf="handle_pdf -s"
alias metadata-pdf="handle_pdf -m"

handle_pdf() {
    # Show help if no arguments or help option provided
    if [[ $# -eq 0 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "📄 PDF Handler"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Usage: handle_pdf [options] file.pdf [output.pdf]"
        echo ""
        echo "Options:"
        echo "  -c, --compress       Compress the PDF file"
        echo "  -e, --epub           Convert PDF to EPUB, if epub then convert to pdf"
        echo "  -o, --ocr            Apply OCR to make text searchable"
        echo "  -t, --text           Extract text from PDF"
        echo "  -s, --sanitize       Sanitize filename (remove spaces and special chars)"
        echo "  -m, --metadata       Display PDF metadata"
        echo "  -r, --rotate [90|180|270]  Rotate PDF by specified degrees"
        echo "  -q, --quiet          Suppress verbose output"
        echo "  -k, --keep           Keep original files (don't delete)"
        echo "  -p, --prompt         Prompt before overwriting or deleting"
        echo "  -n, --rename         Rename the file to the sanitized name"
        echo "  -f, --force          Force overwrite without prompting (default)"
        echo "  -h, --help           Show this help message"
        echo ""
        echo "Examples:"
        echo "  handle_pdf document.pdf                  # Process and replace original"
        echo "  handle_pdf -c large_file.pdf             # Compress PDF"
        echo "  handle_pdf -o scan.pdf                   # Make PDF searchable with OCR"
        echo "  handle_pdf -t document.pdf > text.txt    # Extract text to file"
        echo "  handle_pdf -c -o -s document.pdf         # Compress, OCR, and sanitize"
        echo "  handle_pdf -k *.pdf                      # Process multiple PDFs, keep originals"
        echo "  handle_pdf -p \"*.pdf\"                   # Process with prompts for each file"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        return 0
    fi

    # Parse options
    local compress=false
    local epub=false
    local ocr=false
    local extract_text=false
    local sanitize=false
    local show_metadata=false
    local rotate=false
    local rotate_degrees=0
    local quiet_mode=false
    local keep_originals=false
    local prompt_user=false
    local force_overwrite=true  # Default is to force overwrite
    local recursive=false       # Option for recursive directory processing
    local rename_file=false     # New option to control whether to rename with sanitized name
    local files=()
    
    # Parse all options first
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--compress)
                compress=true
                shift
                ;;
            -e|--epub)
                epub=true
                shift
                ;;
            -o|--ocr)
                ocr=true
                shift
                ;;
            -t|--text)
                extract_text=true
                shift
                ;;
            -s|--sanitize)
                sanitize=true
                shift
                ;;
            -m|--metadata)
                show_metadata=true
                shift
                ;;
            -r|--rotate)
                #rotate the pdf
                rotate=true
                shift
                if [[ "$1" =~ ^(90|180|270)$ ]]; then
                    rotate_degrees="$1"
                    shift
                else
                    echo "❌ Error: Rotation must be 90, 180, or 270 degrees"
                    return 1
                fi
                ;;
            -q|--quiet)
                #quiet mode
                quiet_mode=true
                shift
                ;;
            -k|--keep)
                #keep the original file
                keep_originals=true
                shift
                ;;
            -p|--prompt)
                #prompt the user before overwriting or deleting the file
                prompt_user=true
                force_overwrite=false  # Disable force overwrite when prompt is enabled
                shift
                ;;
            -f|--force)
                #force overwrite of the file
                force_overwrite=true
                prompt_user=false  # Disable prompting when force is enabled
                shift
                ;;
            -h|--help)
                #show help and exit
                handle_pdf
                return 0
                ;;
            -R|--recursive)     
                #recursive processing of pdfs in a directory
                recursive=true
                shift
                ;;
            -n|--rename)
                #rename the file to the sanitized name
                rename_file=true
                shift
                ;;
            -*)
                echo "❌ Unknown option: $1"
                echo "Use 'handle_pdf --help' to see available options"
                return 1
                ;;
            *)
                # Add to files array
                files+=("$1")
                shift
                ;;
        esac
    done
    
    # Check if we have any files to process
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "❌ Error: No input files specified"
        return 1
    fi

    # Process each file or directory
    local processed_count=0
    local sanitized_count=0
    local failed_count=0
    
    for item in "${files[@]}"; do
        # Check if item is a directory
        if [[ -d "$item" ]]; then
            if [[ "$quiet_mode" != true ]]; then
                echo "📁 Processing directory: $item"
            fi
            
            # Find all PDF files in the directory
            local dir_pdfs=()
            
            if [[ "$recursive" == true ]]; then
                # Find PDFs recursively
                while IFS= read -r pdf_file; do
                    dir_pdfs+=("$pdf_file")
                done < <(find "$item" -type f -iname "*.pdf" 2>/dev/null)
            else
                # Find PDFs in just this directory
                while IFS= read -r pdf_file; do
                    dir_pdfs+=("$pdf_file")
                done < <(find "$item" -maxdepth 1 -type f -iname "*.pdf" 2>/dev/null)
            fi
            
            if [[ ${#dir_pdfs[@]} -eq 0 ]]; then
                echo "⚠️ No PDF files found in directory: $item"
                continue
            fi
            
            if [[ "$quiet_mode" != true ]]; then
                echo "🔍 Found ${#dir_pdfs[@]} PDF files to process"
            fi
            
            # Process each PDF in the directory
            for pdf in "${dir_pdfs[@]}"; do
                # Create a new argument list with the same options
                local pdf_args=()
                
                # Add all the option flags
                $compress && pdf_args+=("-c")
                $epub && pdf_args+=("-e")
                $ocr && pdf_args+=("-o")
                $extract_text && pdf_args+=("-t")
                $sanitize && pdf_args+=("-s")
                $show_metadata && pdf_args+=("-m")
                $rotate && pdf_args+=("-r" "$rotate_degrees")
                $quiet_mode && pdf_args+=("-q")
                $keep_originals && pdf_args+=("-k")
                $prompt_user && pdf_args+=("-p")
                $force_overwrite && pdf_args+=("-f")
                
                # Add the PDF file
                pdf_args+=("$pdf")
                
                # Process this PDF file
                handle_pdf "${pdf_args[@]}"
                
                # Update counts based on return code
                if [[ $? -eq 0 ]]; then
                    ((processed_count++))
                    $sanitize && ((sanitized_count++))
                else
                    ((failed_count++))
                fi
            done
        else
            # Check if file exists and is readable
            if [[ ! -e "$item" ]]; then
                echo "Warning: $item does not exist, skipping"
                continue
            fi
            
            if [[ ! -r "$item" ]]; then
                echo "Warning: $item is not readable, skipping"
                continue
            fi
            
            # Check if it's a PDF file
            if [[ "$item" =~ \.pdf$ ]]; then
                if [[ "$quiet_mode" != true ]]; then
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "📄 Processing '$item'"
                fi
                
                # Get the sanitized filename
                local dirname=$(dirname "$item")
                local basename=$(basename "$item" .pdf)
                
                # Better sanitization: replace spaces with underscores first, then remove special chars
                local sanitized_name=""
                if [[ "$sanitize" == true ]]; then
                    #remove (Z-Library) from the filename first 
                    sanitized_name=$(echo "$basename" | sed 's/(Z-Library)//g')
                    # Replace spaces with underscores, then remove other special characters
                    sanitized_name=$(echo "$sanitized_name" | tr ' ' '_' | tr -cd '[:alnum:]._-')
                    
                else
                    sanitized_name="$basename"
                fi
                
                # Determine output filename based on rename_file flag
        local output_file=""
                if [[ "$rename_file" == true && "$sanitize" == true ]]; then
                    # Use sanitized name when rename is requested
            output_file="${dirname}/${sanitized_name}.pdf"
            
                    # Don't overwrite input file with same name
                    if [[ "$output_file" == "$item" ]]; then
                output_file="${dirname}/${sanitized_name}_clean.pdf"
            fi
        else
                    # Default: use the original filename
                    output_file="$item"
                    
                    # For processing, we need a temporary file with a different name
                    local temp_final="${temp_dir}/final.pdf"
                fi
                
                # Check if output file exists and handle accordingly
                if [[ -f "$output_file" && "$output_file" != "$item" ]]; then
                    if [[ "$prompt_user" == true ]]; then
                        echo -n "⚠️ File '$output_file' already exists. Overwrite? (y/n): "
                        read overwrite
                        if [[ ! $overwrite =~ ^[Yy]$ ]]; then
                            echo "💾 Not overwritten, skipping file"
                            continue
                        fi
                    elif [[ "$force_overwrite" != true ]]; then
                        # If neither prompt nor force, skip
                        echo "⚠️ File '$output_file' already exists. Skipping (use -f to force overwrite)"
                        continue
                    fi
                    # Otherwise, with force_overwrite=true, we proceed without prompting
                fi
                
                # Create a temporary directory for processing
                local temp_dir=$(mktemp -d)
                trap 'rm -rf "$temp_dir"' EXIT
                
                # Temporary file for processing
                local temp_output="${temp_dir}/processed.pdf"
                
                # Process the PDF
                local processing_done=false
                
                if $show_metadata; then
                    echo "📋 PDF Metadata for '$item':"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    pdfinfo "$item"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                fi
                
                # First, copy the file to our temp location
                cp "$item" "$temp_output"
                
                if $rotate; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Rotating PDF..."
                    fi
                    
                    local rotate_temp="${temp_dir}/rotated.pdf"
                    gs -q -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile="$rotate_temp" \
                       -c "<</Orientation $rotate_degrees>> setpagedevice" -f "$temp_output"
                    
                    if [[ -f "$rotate_temp" ]]; then
                        mv "$rotate_temp" "$temp_output"
                        processing_done=true
                    fi
                fi
                if $epub; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Converting PDF to EPUB..."
                    fi
                    
                    local epub_output="${dirname}/${sanitized_name}.epub"
                    
                    # Check if calibre's ebook-convert is installed
                    if command -v ebook-convert &> /dev/null; then
                        ebook-convert "$temp_output" "$epub_output"
                        
                        if [[ -f "$epub_output" ]]; then
                            if [[ "$quiet_mode" != true ]]; then
                                echo "✅ EPUB conversion complete: '$epub_output'"
                            fi
                            processing_done=true
                        else
                            echo "❌ EPUB conversion failed"
                        fi
                    else
                        echo "❌ Error: ebook-convert (Calibre) is required for EPUB conversion but not installed"
                        echo "Please install Calibre: brew install --cask calibre"
                        return 1
                    fi
                fi
                if $ocr; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Applying OCR..."
                    fi
                    
                    local ocr_temp="${temp_dir}/ocr.pdf"
                    
                    # Check if ocr_files function exists
                    if typeset -f ocr_files > /dev/null; then
                        ocr_files "$temp_output" "$ocr_temp"
                    # Check if ocrmyfile function exists
                    elif typeset -f ocrmyfile > /dev/null; then
                        ocrmyfile "$temp_output" "$ocr_temp"
                    else
                        ocrmypdf --skip-text "$temp_output" "$ocr_temp"
                    fi
                    
                    if [[ -f "$ocr_temp" ]]; then
                        mv "$ocr_temp" "$temp_output"
                        processing_done=true
                    fi
                fi
                
                if $extract_text; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "📝 Extracting text..."
                    fi
                    pdftotext "$temp_output" -
                    processing_done=true
                fi
                
                if $compress; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🗜️ Compressing PDF..."
                    fi
                    
                    local compress_temp="${temp_dir}/compressed.pdf"
                    gs -q -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -dPDFSETTINGS=/ebook \
                       -dCompatibilityLevel=1.4 -sOutputFile="$compress_temp" "$temp_output"
                    
                    if [[ -f "$compress_temp" ]]; then
                        mv "$compress_temp" "$temp_output"
                        processing_done=true
                    fi
                fi
                
                # If sanitize is the only option and no processing was done, we still need to mark it
                if $sanitize && [[ "$processing_done" == false ]]; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Sanitizing filename..."
                    fi
                    processing_done=true
                    ((sanitized_count++))
                fi
                
                # Check if processing was successful
                if [[ -f "$temp_output" && "$processing_done" == true ]]; then
                    if [[ "$output_file" == "$item" ]]; then
                        # When replacing the original file, use a temporary final file first
                        cp "$temp_output" "$temp_final"
                        
                        # Then replace the original
                        mv "$temp_final" "$output_file"
                    else
                        # When using a different output name, just copy directly
                        cp "$temp_output" "$output_file"
                        
                        # Handle original file (delete by default unless keep_originals is true)
                        if [[ "$prompt_user" == true ]]; then
                            echo -n "❓ Do you want to delete the original file '$item'? (y/n): "
                            read delete_original
                            if [[ $delete_original =~ ^[Yy]$ ]]; then
                                rm -f "$item"
                                if [[ "$quiet_mode" != true ]]; then
                                    echo "🗑️ Original file deleted."
                                fi
                            else
                                if [[ "$quiet_mode" != true ]]; then
                                    echo "💾 Original file kept."
                                fi
                            fi
                        elif [[ "$keep_originals" == true ]]; then
                            if [[ "$quiet_mode" != true ]]; then
                                echo "💾 Original file kept (--keep option)."
                            fi
                        else
                            # Default behavior: delete original without prompting
                            rm -f "$item"
                            if [[ "$quiet_mode" != true ]]; then
                                echo "🗑️ Original file deleted."
                            fi
                        fi
                    fi
                    
                    ((processed_count++))
                else
                    echo "❌ Processing failed for '$item'"
                    ((failed_count++))
                fi
            else
                echo "⚠️ Skipping non-PDF file: $item"
            fi
        fi
    done
    
    # Show summary
    if [[ "$quiet_mode" != true ]]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📋 Summary:"
        echo "  - $processed_count file(s) processed successfully"
        if [[ $sanitized_count -gt 0 ]]; then
            echo "  - $sanitized_count file(s) sanitized"
        fi
        if [[ $failed_count -gt 0 ]]; then
            echo "  - $failed_count file(s) failed to process"
        fi
    fi
    
    return 0
}

# Create a directory and cd to it if only one arg is passed else just make the dir
mkd(){
    if [[ -z "$1" ]]; then
        echo "No directory name provided"
        return 1
    # If multiple args are passed then make the dirs and list them
    elif [[ $# -gt 1 ]]; then
        mkdir -p "$@" && ls -l "$@"
    # Otherwise, make the dir and cd to it (single argument case)
    else
        mkdir -p "$1" && cd "$1"
        pwd # print the current directory
        lt # list the directory contents 
    fi
}

# Reset file content
reset_file(){
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
  # Reset the file content to an empty string
  # use the backup function to create a backup of the file before erasing
  #handle one or multiple files
  # catch escapes and errors to handle prompting user to restore backup or delete
  for file in "$@"; do
    backup "$file"
    echo "" > "$file"
    echo "File content backed up and erased."
    echo "Opening $file in nano editor"
    #echo >> the filename to the file with a # at the beginning
    echo "# $file" >> "$file"
    #sleep half a second
    sleep 0.5
    nano "$file"
    # prompt user to restore backup or delete
    ls $file$backup_name
    # default to no
    see_diff="n"
    echo -n "Do you want to see the difference between the original and backup file? (y/n):(default:n) "
    read see_diff
    if [ "$see_diff" == "y" ]; then
      diff "$file" "$file$backup_name"
      restore_backup="n"
      echo -n "Do you want to restore the backup file? (y/n):(default:n) "
      read restore_backup
      if [ "$restore_backup" == "y" ]; then
          mv "$file$backup_name" "$file"
          echo "Backup file restored."
      fi
    fi
  done
}

# Create a zip archive
zipfile(){
    # usage: zipfile name file_or_dir1 file_or_dir2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: zipfile name_of_zip_file file_or_dir1 file_or_dir2 ..."
        return 0
    fi
    # check if args are passed
    # check if name is passed or if file or dir is passed
    # If name is passed then zip the file or dir with the name
    # if no name is passed then zip the file or dir with the name of the file or dir
    # if multiple files or dirs are passed then zip them all with the name of the first file or dir + more + .zip
}

# create backup of a file or directory
backup(){
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  
  # take files, dictionaries as arguments get full path as needed many args possible
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done
}

# change dir and List Directory Contents
cdl(){
  if [ -n "$1" ]; then
    cd "$1" && ll
  else
    cd ~ && ll
  fi
}

# Help functions
show_func(){
    # usage: show_help function_name
    # show the help for a specific function
    local files=("$HOME/.zsh_aliases" "$HOME/.zsh_functions" "$HOME/.zsh_git" "$HOME/.zsh_apps" "$HOME/.zsh_network" "$HOME/.zsh_transfer" "$HOME/.zsh_security" "$HOME/.zsh_utils")
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" "$file"
        fi
    done
}

alias show_function="show_func"

show_alias(){
    # usage: show_alias
    # show all the aliases in all zsh config files
    local files=("$HOME/.zsh_aliases" "$HOME/.zsh_functions" "$HOME/.zsh_git" "$HOME/.zsh_apps" "$HOME/.zsh_network" "$HOME/.zsh_transfer" "$HOME/.zsh_security" "$HOME/.zsh_utils")
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            echo "Aliases in $file:"
            grep -E "^alias " "$file" | cut -d '=' -f 1 | sort | uniq
            echo ""
        fi
    done
}

show_help(){
    # usage: show_help function_name
    # show the help for a specific function
    local files=("$HOME/.zsh_aliases" "$HOME/.zsh_functions" "$HOME/.zsh_git" "$HOME/.zsh_apps" "$HOME/.zsh_network" "$HOME/.zsh_transfer" "$HOME/.zsh_security" "$HOME/.zsh_utils")
    
    if [[ -z "$1" ]]; then
        # If no argument provided, show helpmenu
        helpmenu
        return 0
    fi
    
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" "$file"
        fi
    done
}

helpmenu(){
    echo "Help Menu:"
    echo "----------"
    echo "See all functions: show_function"
    echo "See all aliases: show_alias"
    echo "See help for a function: show_help function_name"
    echo "See help for an alias: show_help alias_name"
} 