# ----------------------
# Miscellaneous Utility Functions
# ----------------------

# Find files matching a pattern and execute a command on them
findex(){
  # Skip if being sourced (zsh-specific check)
  if [[ ${zsh_eval_context[-1]} == "file" ]]; then
    return 0
  fi
  
  # Show help menu if -h or --help is passed or no arguments provided
  if [[ "$1" == "-h" || "$1" == "--help" || $# -eq 0 ]]; then
    echo "Usage: findex [OPTIONS] [PATH] PATTERN COMMAND [--shift] [ARGS...]"
    echo ""
    echo "Required arguments:"
    echo "  PATTERN       File pattern to search for (e.g., '*.txt')"
    echo "  COMMAND       Command to execute on each matching file"
    echo ""
    echo "Optional arguments:"
    echo "  PATH          Directory path to search in (default: current directory)"
    echo "  -d DEPTH      Maximum directory depth to search (default: unlimited)"
    echo "  -t TYPE       File type: f (files), d (directories), l (symlinks)"
    echo "  --shift       Place all arguments after --shift to the right of the file placeholder"
    echo ""
    echo "Examples:"
    echo "  findex '*.txt' ls -l                         # List all text files in current dir"
    echo "  findex /home '*.pdf' ls -l                   # List all PDF files in /home"
    echo "  findex -d 2 '*.sh' chmod 755                 # Make shell scripts executable (max depth 2)"
    echo "  findex -t f /var/log '*.log' grep 'error'    # Search for 'error' in log files"
    echo "  findex '*.txt' sed -i 's/old/new/g'          # Replace text in all text files"
    echo "  findex /tmp '*.jpg' 'convert {} -resize 50% {}.resized'  # Resize all JPG files in /tmp"
    echo "  findex -d 2 ~/Documents '*.pdf' cp --shift /tmp/     # Copy PDFs to /tmp directory"
    return 0
  fi
    
  local max_depth=""
  local file_type=""
  local search_path="."  # Default to current directory
  local pattern=""
  local command=""
  local pre_shift_args=()
  local post_shift_args=()
  local shift_mode=false
  
  # Check for --shift anywhere in the arguments and remove it
  for arg in "$@"; do
    if [[ "$arg" == "--shift" ]]; then
      shift_mode=true
      break
    fi
  done
  
  # Parse options first
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d)
        if [[ -z "$2" || "$2" == -* ]]; then
          echo "Error: -d requires a depth argument"
          return 1
        fi
        max_depth="-maxdepth $2"
        shift 2
        ;;
      -t)
        if [[ -z "$2" || "$2" == -* ]]; then
          echo "Error: -t requires a type argument (f, d, or l)"
          return 1
        fi
        file_type="-type $2"
        shift 2
        ;;
      --shift)
        # Just skip the --shift flag, we already processed it
        shift
        ;;
      -*)
        echo "Unknown option: $1"
        echo "Use 'findex --help' for usage information."
        return 1
        ;;
      *)
        # If pattern is not set yet, check if this is a directory path
        if [[ -z "$pattern" ]]; then
          if [[ -d "$1" ]]; then
            search_path="$1"
          else
            pattern="$1"
          fi
        elif [[ -z "$command" ]]; then
          # This is the command
          command="$1"
        elif [[ "$shift_mode" == true && "$1" != "--shift" ]]; then
          # Add to post-shift arguments
          post_shift_args+=("$1")
        else
          # Add to pre-shift arguments
          pre_shift_args+=("$1")
        fi
        shift
        ;;
    esac
  done
  
  # Check if we have all required arguments
  if [[ -z "$pattern" || -z "$command" ]]; then
    echo "Error: Missing pattern or command. See 'findex --help' for usage."
    return 1
  fi
  
  # Expand the search path to handle ~ and other shell expansions
  search_path=$(eval echo "$search_path")
  
  # Construct and show the find command that will be executed
  local find_cmd=""
  
  # Special handling for common commands that need specific argument order
  if [[ ${#post_shift_args[@]} -gt 0 ]]; then
    # If we have post-shift arguments, construct command with them after the file placeholder
    find_cmd="find \"$search_path\" $max_depth $file_type -name \"$pattern\" -exec $command"
    
    # Add pre-shift arguments if any
    for arg in "${pre_shift_args[@]}"; do
      find_cmd+=" \"$arg\""
    done
    
    # Add the file placeholder
    find_cmd+=" {}"
    
    # Add post-shift arguments
    for arg in "${post_shift_args[@]}"; do
      find_cmd+=" \"$arg\""
    done
    
    find_cmd+=" \\;"
  else
    # Standard execution with all arguments before the file placeholder
    find_cmd="find \"$search_path\" $max_depth $file_type -name \"$pattern\" -exec $command"
    
    # Add all arguments
    for arg in "${pre_shift_args[@]}"; do
      find_cmd+=" \"$arg\""
    done
    
    # Add the file placeholder at the end
    find_cmd+=" {} \\;"
  fi
  
  echo "DEBUG: $find_cmd"
  
  # Additional debug: List files in the search path to verify it exists and is accessible
  echo "DEBUG: Files in search path (first 5):"
  ls -la "$search_path" | head -5
  
  # Get a list of files that will be processed
  echo "Finding files matching pattern: $pattern in $search_path"
  # Use 2>/dev/null to suppress permission errors
  local matching_files=$(find "$search_path" $max_depth $file_type -name "$pattern" 2>/dev/null)
  
  if [[ -z "$matching_files" ]]; then
    echo "No files found matching pattern: $pattern in $search_path"
    # Try a more direct approach to see if the file exists
    echo "DEBUG: Checking for files with ls:"
    
    # Fix the path pattern to avoid double slashes
    local search_pattern
    if [[ "$search_path" == */ ]]; then
      # If path ends with slash, don't add another one
      search_pattern="${search_path}${pattern#\*}"
    else
      # Otherwise add a slash between path and pattern
      search_pattern="${search_path}/${pattern#\*}"
    fi
    
    # Try to list matching files
    local ls_files=$(ls -la "$search_pattern" 2>/dev/null)
    
    if [[ -n "$ls_files" ]]; then
      echo "$ls_files"
      echo "Files found with ls, proceeding with command execution..."
      # Execute the command using the find command we constructed earlier
      eval "$find_cmd"
    else
      # If ls with pattern fails, try a direct find command as a last resort
      echo "Trying direct find command as fallback..."
      
      # Run a test find command first to see if any files match
      local test_files=$(find "$search_path" $max_depth $file_type -name "$pattern" 2>/dev/null)
      
      if [[ -n "$test_files" ]]; then
        echo "Found files with direct find command:"
        echo "$test_files" | head -10  # Show first 10 files
        if [[ $(echo "$test_files" | wc -l) -gt 10 ]]; then
          echo "... and more ($(echo "$test_files" | wc -l | tr -d ' ') files total)"
        fi
        
        echo "Executing command on found files..."
        if [[ ${#post_shift_args[@]} -gt 0 ]]; then
          find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} "${post_shift_args[@]}" \; 2>/dev/null
        else
          find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} \; 2>/dev/null
        fi
        echo "Command execution completed."
      else
        echo "No files found with fallback methods either"
      fi
    fi
    return 0
  fi
  
  # Count the number of files
  local file_count=$(echo "$matching_files" | wc -l | tr -d ' ')
  echo "Found $file_count file(s) to process:"
  echo "$matching_files" | sed 's/^/  /'
  
  # Execute the command
  if [[ ${#post_shift_args[@]} -gt 0 ]]; then
    echo "Executing: $command ${pre_shift_args[*]} [FILES] ${post_shift_args[*]}"
    find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} "${post_shift_args[@]}" \; 2>/dev/null
  else
    echo "Executing: $command ${pre_shift_args[*]} [FILES]"
    find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} \; 2>/dev/null
  fi
  
  echo "Command execution completed on $file_count file(s)."
}

# Matrix server functions

# Matrix setup
matrix_setup(){
    # for a list of tags see https://github.com/spantaleev/matrix-docker-ansible-deploy/blob/a1efb78bcbc3a9205a59de3364f47192b6232f0f/docs/playbook-tags.md#L4
    ## Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        # show help
        echo "Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}"
        return 0
    fi

    if ! command -v ansible-playbook &> /dev/null; then
        # show error
        echo "Error: 'ansible-playbook' is not installed."
        return 1
    fi
    # set mode to normal if no mode is passed
    local mode="${1:-normal}"
    # set vars file to the default path if no path is passed $HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com
    local vars_file="${2:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com/vars.yml}"
    # Fix: Go up three directories from vars file to reach inventory directory
    local hosts_file="$(dirname "$(dirname "$(dirname "$vars_file")")")/hosts"
    #set the setup.yml file to the directory above the inventory directory
    local setup_file="${hosts_file%/*/*}/setup.yml"
    # set the matrix repo path to the directory above the inventory directory
    local matrix_repo_path="${hosts_file%/*}/.."
    # check if vars file exists
    if [[ ! -f "$vars_file" ]]; then
        echo "Error: Vars file not found at $vars_file"
        return 1
    fi
    # check if hosts file exists
    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the case statement
    case "$mode" in
        full|1)
            # full will update the repo and make roles then setup and start the services using all the tags
            # git pull && sudo make roles of the matrix repo without moving to the repo dir
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=install-all,setup-all,ensure-matrix-users-created,restart || return 1
            cd - # return to the previous directory
            ;;
        normal)
            # normal will update the repo and make roles then setup and start the services
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=setup-all,start || return 1
            cd - # return to the previous directory
            ;;
        restart)
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=restart || return 1
            cd - # return to the previous directory
            ;;
        *)
            echo "Usage: matrix_setup {full|1|normal|restart} [hosts_file_path]"
            return 1
            ;;
    esac
}

# Matrix user setup
matrix_setup_user(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: matrix_setup_user username [password] [admin] [device_id] [hosts_file_path]"
        return 0
    fi

    if ! command -v curl &> /dev/null || ! command -v ansible-playbook &> /dev/null; then
        echo "Error: Required commands 'curl' or 'ansible-playbook' are not installed."
        return 1
    fi

    local username="$1"
    local password="${2:-$(openssl rand -base64 18)}"
    local admin="${3:-no}"
    local device_id="${4:-${username}_$(openssl rand -hex 3)}"
    local hosts_file="${5:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/hosts}"

    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the ansible playbook to register the user
    sudo ansible-playbook -i "$hosts_file" setup.yml \
        --extra-vars="username=${username} password='${password}' admin=${admin}" \
        --tags=register-user
    # login to the matrix server and obtain the access token
    curl -XPOST -d "{
        \"identifier\": { \"type\": \"m.id.user\", \"user\": \"${username}\" },
        \"password\": \"${password}\",
        \"type\": \"m.login.password\",
        \"device_id\": \"${device_id}\"
    }" 'https://matrix.irregularchat.com/_matrix/client/r0/login'
}

# Disk usage aliases
alias du='du -h -d 1'  # Show disk usage in human-readable format (macOS uses -d instead of --max-depth)
alias df='df -h'       # Show free disk space in human-readable format

# ----------------------
# Additional Utility Functions
# ----------------------

# Quick calculator function
calc() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: calc <expression>"
        echo "Quick calculator using bc"
        echo "Examples:"
        echo "  calc '2 + 3'"
        echo "  calc 'sqrt(16)'"
        echo "  calc '3.14 * 2^2'"
        return 0
    fi

    if [[ $# -eq 0 ]]; then
        echo "Error: No expression provided"
        return 1
    fi

    if command -v bc &> /dev/null; then
        echo "scale=4; $*" | bc -l
    else
        echo "Error: bc calculator not installed"
        echo "Install with: brew install bc"
        return 1
    fi
}

# Extract various archive formats
extract() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: extract <archive_file>"
        echo "Extract various archive formats automatically"
        echo "Supported formats: zip, tar.gz, tar.bz2, tar.xz, rar, 7z, gz, bz2"
        return 0
    fi

    if [[ $# -eq 0 ]]; then
        echo "Error: No archive file specified"
        return 1
    fi

    for file in "$@"; do
        if [[ ! -f "$file" ]]; then
            echo "Error: File '$file' not found"
            continue
        fi

        echo "Extracting: $file"
        case "$file" in
            *.tar.bz2) tar -jxvf "$file" ;;
            *.tar.gz)  tar -zxvf "$file" ;;
            *.tar.xz)  tar -Jxvf "$file" ;;
            *.bz2)     bunzip2 "$file" ;;
            *.rar)     unrar x "$file" ;;
            *.gz)      gunzip "$file" ;;
            *.tar)     tar -xvf "$file" ;;
            *.tbz2)    tar -jxvf "$file" ;;
            *.tgz)     tar -zxvf "$file" ;;
            *.zip)     unzip "$file" ;;
            *.Z)       uncompress "$file" ;;
            *.7z)      7z x "$file" ;;
            *)         echo "Error: '$file' format not supported" ;;
        esac
    done
}

# Create archive
archive() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: archive [-t type] <output_name> <file/directory>..."
        echo "Create archives of various formats"
        echo "Options:"
        echo "  -t type    Archive type: zip, tar, tar.gz (default), tar.bz2, tar.xz, 7z"
        return 0
    fi

    local archive_type="tar.gz"
    local output_name=""
    local files=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t)
                archive_type="$2"
                shift 2
                ;;
            *)
                if [[ -z "$output_name" ]]; then
                    output_name="$1"
                else
                    files+=("$1")
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$output_name" || ${#files[@]} -eq 0 ]]; then
        echo "Error: Output name and files required"
        return 1
    fi

    echo "Creating $archive_type archive: $output_name"
    case "$archive_type" in
        zip)     zip -r "$output_name.zip" "${files[@]}" ;;
        tar)     tar -cvf "$output_name.tar" "${files[@]}" ;;
        tar.gz)  tar -czvf "$output_name.tar.gz" "${files[@]}" ;;
        tar.bz2) tar -cjvf "$output_name.tar.bz2" "${files[@]}" ;;
        tar.xz)  tar -cJvf "$output_name.tar.xz" "${files[@]}" ;;
        7z)      7z a "$output_name.7z" "${files[@]}" ;;
        *)       echo "Error: Unsupported archive type: $archive_type" ;;
    esac
}

# Find large files
find_large_files() {
    local size="${1:-100M}"
    local path="${2:-.}"

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: find_large_files [size] [path]"
        echo "Find files larger than specified size"
        echo "Default size: 100M, default path: current directory"
        echo "Size examples: 50M, 1G, 500K"
        return 0
    fi

    echo "Finding files larger than $size in $path..."
    find "$path" -type f -size +$size -exec ls -lh {} \; 2>/dev/null | awk '{ print $9 ": " $5 }'
}

# Process management helpers
psg() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: psg <process_name>"
        echo "Search for processes by name"
        return 0
    fi

    if [[ -z "$1" ]]; then
        echo "Error: Process name required"
        return 1
    fi

    ps aux | grep -i "$1" | grep -v grep
}

# Kill processes by name
killall_by_name() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: killall_by_name <process_name>"
        echo "Kill all processes matching the given name"
        return 0
    fi

    if [[ -z "$1" ]]; then
        echo "Error: Process name required"
        return 1
    fi

    local pids=$(pgrep -f "$1")
    if [[ -n "$pids" ]]; then
        echo "Killing processes matching '$1':"
        echo "$pids" | xargs ps -fp
        echo "$pids" | xargs kill
    else
        echo "No processes found matching '$1'"
    fi
}

# System information (macOS version)
sysinfo() {
    echo "=== System Information ==="
    echo "Hostname: $(hostname)"
    echo "Uptime: $(uptime)"
    echo "Kernel: $(uname -r)"
    echo "OS Version: $(sw_vers -productName) $(sw_vers -productVersion)"
    echo "Architecture: $(uname -m)"
    echo "CPU: $(sysctl -n machdep.cpu.brand_string)"
    echo "Memory: $(sysctl -n hw.memsize | awk '{print $1/1024/1024/1024 " GB"}')"
    echo "Disk Usage:"
    df -h | grep -E '^/dev/' | awk '{print "  " $1 ": " $3 "/" $2 " (" $5 ")"}'
}

# Network utilities (macOS version)
myip() {
    # Try different interfaces for local IP
    local local_ip=$(ifconfig en0 2>/dev/null | grep 'inet ' | awk '{print $2}')
    if [[ -z "$local_ip" ]]; then
        local_ip=$(ifconfig en1 2>/dev/null | grep 'inet ' | awk '{print $2}')
    fi
    if [[ -z "$local_ip" ]]; then
        local_ip=$(ifconfig | grep 'inet ' | grep -v '127.0.0.1' | head -1 | awk '{print $2}')
    fi

    echo "Local IP: ${local_ip:-Unable to determine}"
    echo "Public IP: $(curl -s https://ipinfo.io/ip || echo "Unable to determine")"
}

# Quick note taking
note() {
    local note_file="$HOME/.notes.txt"

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: note [text]"
        echo "Quick note taking utility"
        echo "If no text provided, opens notes file in editor"
        return 0
    fi

    if [[ $# -eq 0 ]]; then
        ${EDITOR:-nano} "$note_file"
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S'): $*" >> "$note_file"
        echo "Note added to $note_file"
    fi
}

# Show notes
notes() {
    local note_file="$HOME/.notes.txt"
    if [[ -f "$note_file" ]]; then
        cat "$note_file"
    else
        echo "No notes found. Use 'note <text>' to create your first note."
    fi
}

# Generate a random UUID
uuidgen_util() {
    # macOS has uuidgen built-in
    uuidgen | tr '[:upper:]' '[:lower:]'
}

# Show disk usage for a directory
show_disk_usage() {
    local path="${1:-.}"
    du -sh "$path"
} 