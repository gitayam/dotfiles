# ----------------------
# Docker Aliases and Functions
# ----------------------

# Docker Compose aliases
alias dc="docker compose"
alias dcp="dc pull" # pull the docker compose services
alias dcs="docker compose stop"
alias dcrm="docker compose rm"
alias docker-compose="dc" # alias for docker compose instead of docker-compose
alias dcu="dcp && dc up -d" # pull and start the docker compose services
alias dcd="dcs;dcrm;dc down --volumes" # stop the docker compose services
# docker compose down and remove the containers, networks, and volumes for that compose file
alias dcdr="dcd --volumes; docker network rm \$(docker network ls -q); docker volume rm \$(docker volume ls -q)" # remove all docker networks and volumes
alias dcb="dcu --build" # build the docker compose services
alias dcr="dcd && dcu" # stop and start the docker compose services

# Docker network and cleanup aliases
alias dcnet="docker network prune"
alias dcvol="docker volume prune"
alias dcpur="dcd && dcp && dcnet && dcvol" # stop and pull the docker compose services

# Docker container management
alias d="docker" # alias for docker
alias dps="d ps"
alias dbash="d exec -it \$1 /bin/bash"
alias dsh="d exec -it \$1 /bin/sh" 

# Docker exec helper

### Interactive docker exec helper
dexec() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    echo "Usage: dexec [container] [command]"
    echo "Run a command inside a Docker container."
    echo "If no container is provided, select from running containers."
    return 0
  fi

  local container="$1"
  shift
  if [[ -z "$container" ]]; then
    mapfile -t containers < <(docker ps --format '{{.Names}}')
    if [[ ${#containers[@]} -eq 0 ]]; then
      echo "No running containers found."
      return 1
    fi
    echo "Select a container:"
    select c in "${containers[@]}" "Cancel"; do
      if [[ -n "$c" && "$c" != "Cancel" ]]; then
        container="$c"
        break
      elif [[ "$c" == "Cancel" ]]; then
        return 1
      else
        echo "Invalid selection"
      fi
    done
  fi

  local cmd="${*:-/bin/bash}"
  docker exec -it "$container" $cmd
}
# Docker auto for docker compose up -d --build if a docker-compose.yml file is found in the current directory
docker_auto() {
    """
    This function will automatically run docker compose up -d --build if a docker-compose.yml file is found in the current directory.
    If a Dockerfile is also found, it will run docker compose up -d --build
    Additionally, after starting, it will print a clickable localhost:PORT link if a port can be detected from the compose file.
    """
    # Helper: Try to extract a port from a compose file
    print_localhost_link() {
        local compose_file=""
        for f in docker-compose.yml docker-compose.yaml compose.yml compose.yaml; do
            if [ -f "$f" ]; then
                compose_file="$f"
                break
            fi
        done
        if [ -n "$compose_file" ]; then
            local port=""
            # Try yq if available
            if command -v yq >/dev/null 2>&1; then
                # Extract the first host port from any service's ports section
                port=$(yq '(.services[]?.ports[]? // []) | select(.) | sub("^([0-9]+):.*$"; "\\1")' "$compose_file" | grep -Eo '^[0-9]{2,5}$' | head -n1)
            fi
            # If yq not found or no port found, try improved grep/sed fallback
            if [ -z "$port" ]; then
                port=$(grep -E 'ports:|^[[:space:]]*-?[[:space:]]*[0-9]+:[0-9]+' "$compose_file" | \
                    awk '/ports:/ {p=1; next} p && /^[[:space:]]*-[[:space:]]*[0-9]+:[0-9]+/ {gsub(/[^0-9:]/,""); split($1,a,":"); print a[1]; exit}' )
            fi
            # If still not found, try another fallback for quoted ports
            if [ -z "$port" ]; then
                port=$(grep -E '^[[:space:]]*-?[[:space:]]*"[0-9]+:[0-9]+"' "$compose_file" | sed -E 's/.*"([0-9]{2,5}):[0-9]{2,5}".*/\1/' | head -n1)
            fi
            if [ -n "$port" ]; then
                echo "Open your app at: http://localhost:$port"
            else
                echo "App started! (Could not auto-detect port)"
                echo "If your service exposes a port, open: http://localhost:PORT (replace PORT with the correct value)"
            fi
        else
            echo "App started! (No compose file to detect port from)"
        fi
    }

    # Check for various Docker Compose file variations
    if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ] || [ -f "compose.yml" ] || [ -f "compose.yaml" ]; then
        echo "Docker Compose file found in current directory"
        # If both Dockerfile and docker-compose file exist
        if [ -f "Dockerfile" ]; then
            echo "Dockerfile also found - running docker compose up with build"
            docker compose up -d --build
            print_localhost_link
        else
            # Just docker-compose without Dockerfile
            echo "Running docker compose up -d"
            docker compose up -d
            print_localhost_link
        fi
    elif [ -f "Dockerfile" ]; then
        # Only Dockerfile exists, no compose file
        echo "Only Dockerfile found in current directory"
        echo "You may want to build this image manually with: docker build -t <name> ."
        echo "After running the container, open: http://localhost:PORT (replace PORT with the correct value)"
    else
        echo "No Docker Compose file or Dockerfile found in current directory"
    fi
}

# Docker cleanup functions
docker_cleanup() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_cleanup [--all]"
        echo "Clean up Docker system"
        echo "Options:"
        echo "  --all    Remove all unused containers, networks, images (both dangling and unreferenced)"
        return 0
    fi

    echo "üßπ Cleaning up Docker system..."

    if [[ "$1" == "--all" ]]; then
        echo "Removing all unused containers, networks, volumes, and images..."
        docker system prune -a --volumes -f
    else
        echo "Removing stopped containers, unused networks, and dangling images..."
        docker system prune -f
    fi

    echo "‚úÖ Docker cleanup completed"
    docker system df
}

# Docker container management
docker_stop_all() {
    echo "üõë Stopping all running containers..."
    docker stop $(docker ps -q) 2>/dev/null || echo "No running containers to stop"
}

docker_remove_all() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_remove_all [--force]"
        echo "Remove all containers (stopped containers by default)"
        echo "Options:"
        echo "  --force    Also stop and remove running containers"
        return 0
    fi

    if [[ "$1" == "--force" ]]; then
        echo "üóëÔ∏è  Force removing ALL containers (including running ones)..."
        docker rm -f $(docker ps -aq) 2>/dev/null || echo "No containers to remove"
    else
        echo "üóëÔ∏è  Removing stopped containers..."
        docker rm $(docker ps -aq) 2>/dev/null || echo "No stopped containers to remove"
    fi
}

# Docker image management
docker_remove_dangling() {
    echo "üóëÔ∏è  Removing dangling images..."
    docker rmi $(docker images -f "dangling=true" -q) 2>/dev/null || echo "No dangling images to remove"
}

# Docker stats
docker_stats() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_stats [container_name]"
        echo "Show Docker container resource usage"
        return 0
    fi

    if [[ -n "$1" ]]; then
        docker stats "$1"
    else
        docker stats
    fi
}

# Docker logs
docker_logs_tail() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_logs_tail <container> [lines]"
        echo "Show last N lines of container logs (default: 100)"
        return 0
    fi

    if [[ -z "$1" ]]; then
        echo "Error: Container name required"
        return 1
    fi

    local lines="${2:-100}"
    docker logs --tail "$lines" -f "$1"
}

# Docker Compose Update Function - scan and update multiple compose files
update_docker_compose() {
    local search_path="."
    local exclude_paths=""
    local pull_only=false
    local ask=false

    if [[ "$1" == "--help" ]]; then
        echo "Usage: update_docker_compose [OPTIONS]"
        echo "Find and update all docker-compose files in a directory tree"
        echo "Options:"
        echo "  --home              Set the search path to \$HOME"
        echo "  --exclude <path>    Exclude specific paths from the update"
        echo "  --pull-only         Only pull Docker images without running 'up -d'"
        echo "  --ask               Prompt before updating each compose file"
        echo "  --help              Show this help message"
        return 0
    fi

    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --home) search_path="$HOME" ;;
            --exclude) exclude_paths="$2"; shift ;;
            --pull-only) pull_only=true ;;
            --ask) ask=true ;;
            *) echo "Unknown parameter passed: $1"; return 1 ;;
        esac
        shift
    done

    # Build exclude expression for find
    local exclude_expr=""
    if [[ -n "$exclude_paths" ]]; then
        # Split on spaces for zsh
        local -a exclude_array
        exclude_array=("${(@s/ /)exclude_paths}")
        for path in "${exclude_array[@]}"; do
            exclude_expr+=" ! -path \"${path}*\""
        done
    fi

    # Find all compose files
    local find_cmd="find \"$search_path\" -type f \( -name \"docker-compose.yml\" -o -name \"docker-compose.yaml\" -o -name \"compose.yml\" -o -name \"compose.yaml\" \) $exclude_expr -print"

    eval "$find_cmd" | while read -r composefile; do
        local compose_dir=$(dirname "$composefile")
        echo "üì¶ Found docker-compose file in $compose_dir"

        if $ask; then
            read -q "REPLY?Update this compose file? (y/n): "
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                continue
            fi
        fi

        cd "$compose_dir"

        if $pull_only; then
            echo "üîÑ Pulling images for $compose_dir"
            docker compose pull
        else
            echo "üöÄ Updating and starting services in $compose_dir"
            docker compose pull && docker compose up -d
        fi

        cd - > /dev/null
        echo "‚úÖ Completed: $compose_dir"
        echo ""
    done
}

# Docker container inspection
docker_inspect_container() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_inspect_container <container>"
        echo "Show detailed information about a container"
        return 0
    fi

    if [[ -z "$1" ]]; then
        echo "Error: Container name required"
        return 1
    fi

    echo "üîç Container Information for: $1"
    echo "=================================="
    docker inspect "$1" | jq -r '.[] | {
        Name: .Name,
        Image: .Config.Image,
        State: .State.Status,
        IPAddress: .NetworkSettings.IPAddress,
        Ports: .NetworkSettings.Ports,
        Mounts: .Mounts
    }'
}

# Docker network utilities
docker_network_inspect() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_network_inspect [network_name]"
        echo "Show Docker network information"
        return 0
    fi

    if [[ -n "$1" ]]; then
        docker network inspect "$1"
    else
        echo "üåê Available Docker Networks:"
        docker network ls
    fi
}

# Docker volume utilities
docker_volume_inspect() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: docker_volume_inspect [volume_name]"
        echo "Show Docker volume information"
        return 0
    fi

    if [[ -n "$1" ]]; then
        docker volume inspect "$1"
    else
        echo "üíæ Available Docker Volumes:"
        docker volume ls
    fi
}

# Docker system information
docker_info() {
    echo "üê≥ Docker System Information"
    echo "============================"
    docker system df
    echo ""
    echo "üìä Docker System Info:"
    docker system info | grep -E "(Server Version|Storage Driver|Containers|Images|Docker Root Dir)"
}