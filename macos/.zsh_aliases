# ----------------------
# Git Aliases
# ----------------------
alias gita="git_add"
alias gitcg="git_commit"
alias gitp="git push"
alias gitpl="git pull"
alias gitco="git checkout"
alias gitcb="git checkout -b"
alias gitlog="git log --oneline --graph --all"

# ----------------------
# Git Functions
# ----------------------
git_commit() {
    if [[ -z "$1" ]]; then
        echo "No commit message provided. Opening editor for interactive commit message."
        git commit
    else
        git commit -m "$1"
    fi
}

git_add() {
    if [[ -z "$1" ]]; then
        echo "No files specified. Defaulting to 'git add .'"
        git add .
    else
        git add "$@"
    fi
}
# ----------------------
# Navigation and File Management Aliases
# ----------------------
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias mkdir="mkdir -p"
alias rmr="rm -rf"
alias untar="tar -zxvf"
alias tarx="tar -xvf"
#TODO: zipfile function
zipfile() {
    # usage: zipfile name file_or_dir1 file_or_dir2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: zipfile name file_or_dir1 file_or_dir2 ..."
        return 0
    fi
    # check if args are passed
    # check if name is passed or if file or dir is passed
    # If name is passed then zip the file or dir with the name
    # if no name is passed then zip the file or dir with the name of the file or dir
    # if multiple files or dirs are passed then zip them all with the name of the first file or dir + more + .zip
}
# ----------------------
# Security Tools Aliases
# ----------------------
alias json="jq ."
alias http="curl -I"
alias ports="netstat -tuln"

scan_ports() {
    #usage: scan_ports ip_or_host
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    # if no ip_or_host is passed then use the router ip 
    if [[ -z "$1" ]]; then
        local_ip=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -n 1)
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    #check if package is installed
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed"
        #prompt to install if yes install and continue else return 1
        install_nmap="n"
        echo -n "Do you want to install nmap? (y/n): " 
        read install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            brew install nmap
            echo "nmap installed, continuing with scan"
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn $1
}
# ----------------------
# Helper Functions
# ----------------------
# Colorize the `ls` output and setup useful aliases
export LS_OPTIONS='--color=auto'
alias ls='ls $LS_OPTIONS'
alias ll='ls -lh $LS_OPTIONS'        # Detailed list view
alias la='ls -lha $LS_OPTIONS'       # Show hidden files
alias l='ls -lA $LS_OPTIONS'         # Short list view with hidden files
alias lt='ls -strhal $LS_OPTIONS'       # Sort by date, most recent last

# Safe aliases to prevent accidental file overwrites or deletions
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Navigation Function
# Fast directory navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."

# change dir and List Directory Contents
cdl() {
  if [ -n "$1" ]; then
    cd "$1" && ll
  else
    cd ~ && ll
  fi
}

# create backup of a file or directory
backup() {
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  
  # take files, dictionaries as arguments get full path as needed many args possible
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done
}
# Searching 
# Grep aliases and functions
alias grep='grep -i --color=auto "$@"' # Ignore case and colorize output and pass all arguments to grep in quotes
alias grepv='grep -vi --color=auto' # Ignore case, invert match, and colorize output

# Find aliases and functions
alias findf='find . -type f -name' # Find files by name
alias findd='find . -type d -name' # Find directories by name

#TODO
# findex() {
#   # Skip if being sourced (zsh-specific check)
#   if [[ ${zsh_eval_context[-1]} == "file" ]]; then
#     return 0
#   }
  
  # Show help menu if -h or --help is passed
#   if [[ "$1" == "-h" || "$1" == "--help" ]]; then
#     echo "Usage: findex <pattern> <command> [args...]"
#     echo "Examples:"
#     echo "  findex '*.txt' ls -l"
#     echo "  findex '*.php' nano"
#     echo "  findex '*.sh' chmod 755"
#     echo "  findex '*.log' grep 'error'"
#     echo "  findex '*.txt' sed 's/old/new/g'"
#     return 0
#   fi

  # Need at least pattern and command
#   if [[ $# -lt 2 ]]; then
#     echo "Error: Missing command. See 'findex --help' for usage."
#     return 1
#   fi

#   local pattern="$1"
#   shift # Remove pattern from arguments
#   find . -iname "$pattern" -exec "$@" \;
# }

# Nano Editor settings
alias nanozsh='nano ~/.zshrc'     # Open the bashrc file in nano
alias reset='reset_file'          # Custom function to erase a file content then open with nano

# Nano Functions
reset_file() {
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
  # Reset the file content to an empty string
  # use the backup function to create a backup of the file before erasing
  #handle one or multiple files
  # catch escapes and errors to handle prompting user to restore backup or delete
  for file in "$@"; do
    backup "$file"
    echo "" > "$file"
    echo "File content backed up and erased."
    echo "Opening $file in nano editor"
    #echo >> the filename to the file with a # at the beginning
    echo "# $file" >> "$file"
    #sleep half a second
    sleep 0.5
    nano "$file"
    # prompt user to restore backup or delete
    ls $file$backup_name
    # default to no
    see_diff="n"
    read -p "Do you want to see the difference between the original and backup file? (y/n):(default:n) " see_diff
    if [ "$see_diff" == "y" ]; then
      diff "$file" "$file$backup_name"
      restore_backup="n"
      read -p "Do you want to restore the backup file? (y/n):(default:n) " restore_backup
      if [ "$restore_backup" == "y" ]; then
        echo "This will delete any changes made to the original file"
        restore_backup_confirm="n"
        read -p "Are you sure you want to restore the backup file? (y/n):(default:n) " restore_backup_confirm
        if [ "$restore_backup_confirm" == "y" ]; then
          mv "$file$backup_name" "$file"
          echo "Backup file restored."
        fi
      fi
    fi
  done
}

# Python Aliases 
pyenv(){
  python3 -m venv env  # Create the virtual environment
  source env/bin/activate  # Activate the virtual environment (on Linux/Mac)
}

pyserver(){
    # usage: pyserver file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver file1 file2 ..."
        return 0
    fi
    # check if python3 is installed
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed"
        return 1
    fi
    # set port for the python server
    local port=8000
    # create a python server for the passed files or dir
    #get local ip
    local_ip=$(hostname -I | awk '{print $1}')
    # path for the server else use current dir
    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    # if no files passed in arg then use current dir
    if [ -n "$1" ]; then # if there are files passed in arg
        # create temp dir
        mkdir -p /tmp/pyserver
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/pyserver
        done
        # change dir to the temp dir
        cd /tmp/pyserver
        # start the python server
        python3 -m http.server $port
    else
        # use current dir
        cd .
        # start the python server
        python3 -m http.server $port
    fi
    
}
# Docker Aliases
alias dc="docker compose"
alias docker-compose="dc" # alias for docker compose instead of docker-compose
alias dcu="dc pull && dc up -d" # pull and start the docker compose services
alias dcr="dc down && dc up -d" # stop and start the docker compose services
alias dcp="dc pull" # pull the docker compose services
alias d="docker" # alias for docker
alias dps="d ps"
alias dbash="d exec -it $1 /bin/bash"
alias dsh="d exec -it $1 /bin/sh"


# Networking shortcuts
alias ports='netstat -tulanp'  # List open ports
alias myip='curl ifconfig.me'  # Check external IP address

# Disk usage shortcuts
alias du='du -h --max-depth=1'  # Show disk usage in human-readable format
alias df='df -h'                # Show free disk space in human-readable format


# Menu with all functions in ~/.zsh_aliases and ~/.mac_functions.sh
helpmenu() {
    echo "Help Menu:"
    echo "----------"

    # show all functions in the ~/.zsh_aliases file
    cat ~/.zsh_aliases | grep -E '^[a-zA-Z_][a-zA-Z0-9_]*(\(\))? *\{' | sed 's/{$//'
    echo ""
    echo "To see the help for a specific function, use the show_help function with the function name as the argument."
}

# ----------------------
# GitHub Repository Management
# ----------------------

create_repo() {
    show_help "$1" "Usage: create_repo repo_name"

    if ! command -v gh &> /dev/null; then
        echo "Error: GitHub CLI 'gh' is not installed."
        return 1
    fi

    local repo_name=$1
    local base_dir="$HOME/Documents/Git"
    mkdir -p "$base_dir"

    gh repo create "$repo_name" --private || return 1
    git clone "https://github.com/$(gh api user | jq -r '.login')/$repo_name.git" "$base_dir/$repo_name" || return 1
    cd "$base_dir/$repo_name" || return 1
    echo "# $repo_name" > README.md
    git add README.md
    git commit -m "Initial commit"
    git branch -M main
    git push -u origin main

    echo "Repository $repo_name created and initialized successfully in $base_dir."
}

# ----------------------
# Python Virtual Environment Management
# ----------------------
# Python Aliases 
pyenv(){
  python3 -m venv env  # Create the virtual environment
  source env/bin/activate  # Activate the virtual environment (on Linux/Mac)
  pip install --upgrade pip  # Upgrade pip
  pip install -r requirements.txt  # Install dependencies
}

pyserver(){
  #get local ip
  local_ip=$(hostname -I | awk '{print $1}')
  # path for the server else use current dir
  # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
  if [ -n "$1" ]; then
    # create temp dir
    mkdir -p /tmp/pyserver
    # add files or dir to the temp dir
    #create python server for the dir
    for file in "$@"; do
      ln -s "$file" /tmp/pyserver
    done
    # change dir to the temp dir
    cd /tmp/pyserver
  fi
}

# ----------------------
# MAC Address Management
# ----------------------

gen_mac_addr() {
    local mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

change_mac_menu() {
    echo "Choose an option:"
    echo "1. Set a specific MAC address"
    echo "2. Set a random MAC address"
    echo "3. Restore original MAC address"
    echo -n "Enter your choice (1/2/3): "
    read choice

    case $choice in
        1)
            echo -n "Enter the new MAC address (e.g., E6:B8:BA:D2:41:07): "
            read mac_address
            echo -n "Enter the name of the new network location: "
            read location_name
            change_mac_address "$mac_address" "$location_name"
            ;;
        2)
            echo -n "Enter the name of the new network location: "
            read location_name
            mac_address=$(gen_mac_addr)
            change_mac_address "$mac_address" "$location_name"
            ;;
        3)
            restore_original_mac
            ;;
        *)
            echo "Invalid choice. Exiting."
            ;;
    esac
}

# ----------------------
# Matrix Setup
# ----------------------

matrix_setup() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        # show help
        echo "Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}"
        return 0
    fi

    if ! command -v ansible-playbook &> /dev/null; then
        # show error
        echo "Error: 'ansible-playbook' is not installed."
        return 1
    fi
    # set mode to normal if no mode is passed
    local mode="${1:-normal}"
    # set vars file to the default path if no path is passed $HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com
    local vars_file="${2:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com/vars.yml}"
    # Fix: Go up three directories from vars file to reach inventory directory
    local hosts_file="$(dirname "$(dirname "$(dirname "$vars_file")")")/hosts"
    # set the matrix repo path to the directory above the inventory directory
    local matrix_repo_path="${hosts_file%/*}/.."
    # check if vars file exists
    if [[ ! -f "$vars_file" ]]; then
        echo "Error: Vars file not found at $vars_file"
        return 1
    fi
    # check if hosts file exists
    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the case statement
    case "$mode" in
        full|1)
            # full will update the repo and make roles then setup and start the services using all the tags
            # git pull && sudo make roles of the matrix repo without moving to the repo dir
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" setup.yml --tags=install-all,setup-all,ensure-matrix-users-created,start || return 1
            cd - # return to the previous directory
            ;;
        normal)
            # normal will update the repo and make roles then setup and start the services
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" setup.yml --tags=setup-all,start || return 1
            cd - # return to the previous directory
            ;;
        restart)
            sudo ansible-playbook -i "$hosts_file" setup.yml --tags=restart || return 1
            cd - # return to the previous directory
            ;;
        *)
            echo "Usage: matrix_setup {full|1|normal|restart} [hosts_file_path]"
            return 1
            ;;
    esac
}

# ----------------------
# Matrix User Setup
# ----------------------

matrix_setup_user() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: matrix_setup_user username [password] [admin] [device_id] [hosts_file_path]"
        return 0
    fi

    if ! command -v curl &> /dev/null || ! command -v ansible-playbook &> /dev/null; then
        echo "Error: Required commands 'curl' or 'ansible-playbook' are not installed."
        return 1
    fi

    local username="$1"
    local password="${2:-$(openssl rand -base64 18)}"
    local admin="${3:-no}"
    local device_id="${4:-${username}_$(openssl rand -hex 3)}"
    local hosts_file="${5:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/hosts}"

    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi

    sudo ansible-playbook -i "$hosts_file" setup.yml \
        --extra-vars="username=${username} password='${password}' admin=${admin}" \
        --tags=register-user

    curl -XPOST -d "{
        \"identifier\": { \"type\": \"m.id.user\", \"user\": \"${username}\" },
        \"password\": \"${password}\",
        \"type\": \"m.login.password\",
        \"device_id\": \"${device_id}\"
    }" 'https://matrix.irregularchat.com/_matrix/client/r0/login'
}

# ----------------------
# File Transfer
# ----------------------

transfer_file() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: transfer_file path1 path2 ..."
        printf "This command uses rsync to transfer files or directories to a remote host.\n"
        printf "The remote host, port, and base remote path are read from the ~/.env file.\n"
        printf "An example ~/.env file is provided at $HOME/macos/.env-template\n"
        return 0
    fi
    #read .env file for the remote host and port and base remote path if file exists
    if [[ -f ~/.env ]]; then
        source ~/.env
    else
        echo "Error: ~/.env file not found"
        read -p "Do you want to create a new ~/.env file? (y/n): " REPLY
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "REMOTE_HOST=username@192.168.1.xxx" >> ~/.env
            echo "REMOTE_PORT=2220" >> ~/.env
            echo "REMOTE_BASE_PATH=/path/to/directory" >> ~/.env
            echo "~/.env file created, please edit the file with the correct remote host, port, and base remote path"
            return 1
            
        else
            return 1
        fi
    fi
    remote_host=$REMOTE_HOST
    remote_port=$REMOTE_PORT
    base_remote_path=$REMOTE_BASE_PATH
    #check if vars are set
    if [[ -z "$remote_host" || -z "$remote_port" || -z "$base_remote_path" ]]; then
        echo "Error: Remote host, port, or base remote path not set in ~/.env file"
        return 1
    fi
    #check if can connect to remote host
    if ! ssh -q -p "$remote_port" "$remote_host" "exit"; then
        echo "Error: Cannot connect to remote host"
        return 1
    fi

    for path in "$@"; do
        if [[ ! -e "$path" ]]; then
            echo "Error: '$path' does not exist"
            continue
        fi

        local target_path="$base_remote_path/$(basename "$path")"
        if [[ -d "$path" ]]; then
            ssh -p "$remote_port" "$remote_host" "mkdir -p \"$target_path\""
            rsync -vz --progress -e "ssh -p $remote_port" "$path/"* "$remote_host:$target_path/" || echo "Failed to transfer directory '$path'"
        elif [[ -f "$path" ]]; then
            ssh -p "$remote_port" "$remote_host" "mkdir -p \"$base_remote_path\""
            rsync -vz --progress -e "ssh -p $remote_port" "$path" "$remote_host:$target_path" || echo "Failed to transfer file '$path'"
        else
            echo "Error: '$path' is neither a file nor a directory"
        fi
    done
}