# ----------------------
# Git Aliases
# ----------------------
alias gita="git_add"
alias gitcg="git_commit"
alias gitp="git push"
alias gitpl="git pull"
alias gitco="git checkout"
alias gitcb="git checkout -b"
alias gitlog="git log --oneline --graph --all"

# ----------------------
# Git Functions
# ----------------------
git_commit(){
    if [[ -z "$1" ]]; then
        echo "No commit message provided. Opening editor for interactive commit message."
        git commit
    else
        git commit -m "$1"
    fi
}

git_add(){
    if [[ -z "$1" ]]; then
        echo "No files specified. Defaulting to 'git add .'"
        git add .
    else
        git add "$@"
    fi
}

update_git_repos(){
    # Default variables
    search_path="$HOME/Documents/Git/"  # Default search path
    exclude_paths=()                   # Array to store excluded paths

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --search-path)
                search_path="$2"
                shift 2
                ;;
            --exclude)
                exclude_paths+=("$2")
                shift 2
                ;;
            *)
                echo "Unknown argument: $1"
                return 1
                ;;
        esac
    done

    # Build the find command
    find_cmd="find \"$search_path\" -type d -name \".git\""

    for exclude in "${exclude_paths[@]}"; do
        find_cmd+=" ! -path \"$exclude/*\""
    done

    find_cmd+=" -print"

    # Execute the find command and update repositories
    eval "$find_cmd" | while IFS= read -r gitdir; do
        repo_dir=$(dirname "$gitdir")

        # Ensure the directory is marked safe for Git operations
        git config --global --add safe.directory "$repo_dir"

        echo "Updating repository in $repo_dir"
        cd "$repo_dir" || {
            echo "Failed to access $repo_dir"
            continue
        }
        git pull --rebase || echo "Failed to update $repo_dir"
    done
}

## Git Clone Function
### Usage: git_clone repo_name or url
### from any directory will clone the repo to the correct directory in the ~/Documents/Git/ directory
git_clone(){
    if [[ -z "$1" ]]; then
        echo "No repository name or URL provided"
        return 1
    fi

    # Determine the repo name from the URL or input
    if [[ "$1" =~ ^https?:// || "$1" =~ ^git@ ]]; then
        repo_name=$(basename "$1" .git)
        repo_url="$1"
    else
        repo_name=$(basename "$1")
        repo_url="https://github.com/your-username/$repo_name.git"
    fi

    # Check if the repo name is a valid directory name
    if [[ ! "$repo_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Invalid repository name: $repo_name"
        return 1
    fi

    # Check if the repo name already exists in the ~/Documents/Git/ directory
    if [[ -d "$HOME/Documents/Git/$repo_name" ]]; then
        echo "Repository already exists: $repo_name"
        return 1
    fi

    # Clone the repo to the ~/Documents/Git/ directory
    git clone "$repo_url" "$HOME/Documents/Git/$repo_name" || {
        echo "Failed to clone repository"
        return 1
    }

    # Change to the cloned repository directory
    cd "$HOME/Documents/Git/$repo_name" || {
        echo "Failed to access $repo_name directory"
        return 1
    }
    # print the current directory and list the files
    pwd
    ls -l
    #prompt user to open the repo dir (./) in vs code or cursor
    echo "Do you want to open the repository? (Y/n): "
    read open_in
    open_in=${open_in:-y}  # Default to 'y' if no input is provided

    if [[ $open_in =~ ^[Yy]$ ]]; then
        if command -v code &> /dev/null && command -v cursor &> /dev/null; then
            echo "Both VS Code and Cursor are available. Open with (v)scode or (c)ursor? (v/c): "
            read editor_choice
            editor_choice=${editor_choice:-v}  # Default to 'v' if no input is provided
            if [[ $editor_choice == "v" ]]; then
                code .
            elif [[ $editor_choice == "c" ]]; then
                cursor .
            fi
        elif command -v code &> /dev/null; then
            code .
        elif command -v cursor &> /dev/null; then
            cursor .
        else
            echo "Neither VS Code nor Cursor is available."
        fi
    fi
}
# ----------------------
# Navigation and File Management Aliases
# ----------------------
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias mkdir="mkdir -p"
alias rmr="rm -rf"
alias untar="tar -zxvf"
alias tarx="tar -xvf"
#TODO: zipfile function
zipfile(){
    # usage: zipfile name file_or_dir1 file_or_dir2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: zipfile name_of_zip_file file_or_dir1 file_or_dir2 ..."
        return 0
    fi
    # check if args are passed
    # check if name is passed or if file or dir is passed
    # If name is passed then zip the file or dir with the name
    # if no name is passed then zip the file or dir with the name of the file or dir
    # if multiple files or dirs are passed then zip them all with the name of the first file or dir + more + .zip
}

## Make Directory and cd to it if only one arg is passed else just make the dir
mkd(){
    if [[ -z "$1" ]]; then
        echo "No directory name provided"
        return 1
    # If multiple args are passed then make the dirs and list them
    elif [[ $# -gt 1 ]]; then
        mkdir -p "$@" && ls -l "$@"
    # Otherwise, make the dir and cd to it (single argument case)
    else
        mkdir -p "$1" && cd "$1"
        pwd # print the current directory
        lt # list the directory contents 
    fi
}

#All updates on macos including brew, macos,git function updates
update_all(){
    sudo echo "Updating brew" # using sudo with echo to get user password , sudo used softwareupdate
    brew update && brew upgrade && brew cleanup && brew doctor
    echo "Updating macos"
    sudo softwareupdate --install --all
    echo "Updating git functions"
    update_git_repos
    echo "Clearing cache"
    clear
}
# ----------------------
# Applications Aliases
# ----------------------
setup_profiles(){
    mkdir -p $HOME/Profiles
    cd $HOME/Profiles
}
alias run-matrix="run-element"
alias run-irregular="run-element irregularchat"
run-element(){
    # usage: run-element
    # open element desktop in the default browser
    # if a profile is passed then use it
    setup_profiles
    /Applications/Element.app/Contents/MacOS/Element --profile "$1"&
    cd - # go back to the previous directory
}

run-firefox(){
    # usage: run-firefox
    # open firefox in the default browser
    # if a profile is passed then use it 
    setup_profiles
    /Applications/Firefox.app/Contents/MacOS/firefox --profile "$1" --new-window "https://sso.irregularchat.com"&
    cd - # go back to the previous directory
}

run-discord(){
    # usage: run-discord
    # open discord in the default browser
    # if a profile is passed then use it
    setup_profiles
    /Applications/Discord.app/Contents/MacOS/Discord --profile "$1"&
    cd - # go back to the previous directory
}
# command line keepassxc
alias kp="keepassxc"
# Open database in keepassxc
alias run-kp="kp --db $1"

#general passphrase with diceware
#3 words, symbols, numbers
alias gen-passphrase="generate_password -p phrases -l 3"
# ----------------------
# Security Tools Aliases
# ----------------------
alias json="jq ."
alias http="curl -I"
alias ports="netstat -tuln"

scan_ports(){
    #usage: scan_ports ip_or_host
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    # if no ip_or_host is passed then use the router ip 
    if [[ -z "$1" ]]; then
        local_ip=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -n 1)
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    #check if package is installed
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed"
        #prompt to install if yes install and continue else return 1
        install_nmap="n"
        echo -n "Do you want to install nmap? (y/n): " 
        read install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            brew install nmap
            echo "nmap installed, continuing with scan"
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn $1
}
# PDF Handling
#using ghost script to convert pdfs to text that are still ocr
# gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile=same_name_with_no_spaces_and_no_special_chars.pdf original.pdf
alias ocr-pdf="handle_pdf -o"
alias extract-text="handle_pdf -t"
alias compress-pdf="handle_pdf -c"
alias rotate-pdf="handle_pdf -r"
alias sanitize-pdf="handle_pdf -s"
alias metadata-pdf="handle_pdf -m"

handle_pdf() {
    # Show help if no arguments or help option provided
    if [[ $# -eq 0 || "$1" == "-h" || "$1" == "--help" ]]; then
        echo "📄 PDF Handler"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Usage: handle_pdf [options] file.pdf [output.pdf]"
        echo ""
        echo "Options:"
        echo "  -c, --compress       Compress the PDF file"
        echo "  -e, --epub           Convert PDF to EPUB, if epub then convert to pdf"
        echo "  -o, --ocr            Apply OCR to make text searchable"
        echo "  -t, --text           Extract text from PDF"
        echo "  -s, --sanitize       Sanitize filename (remove spaces and special chars)"
        echo "  -m, --metadata       Display PDF metadata"
        echo "  -r, --rotate [90|180|270]  Rotate PDF by specified degrees"
        echo "  -q, --quiet          Suppress verbose output"
        echo "  -k, --keep           Keep original files (don't delete)"
        echo "  -p, --prompt         Prompt before overwriting or deleting"
        echo "  -n, --rename         Rename the file to the sanitized name"
        echo "  -f, --force          Force overwrite without prompting (default)"
        echo "  -h, --help           Show this help message"
        echo ""
        echo "Examples:"
        echo "  handle_pdf document.pdf                  # Process and replace original"
        echo "  handle_pdf -c large_file.pdf             # Compress PDF"
        echo "  handle_pdf -o scan.pdf                   # Make PDF searchable with OCR"
        echo "  handle_pdf -t document.pdf > text.txt    # Extract text to file"
        echo "  handle_pdf -c -o -s document.pdf         # Compress, OCR, and sanitize"
        echo "  handle_pdf -k *.pdf                      # Process multiple PDFs, keep originals"
        echo "  handle_pdf -p \"*.pdf\"                   # Process with prompts for each file"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        return 0
    fi

    # Parse options
    local compress=false
    local epub=false
    local ocr=false
    local extract_text=false
    local sanitize=false
    local show_metadata=false
    local rotate=false
    local rotate_degrees=0
    local quiet_mode=false
    local keep_originals=false
    local prompt_user=false
    local force_overwrite=true  # Default is to force overwrite
    local recursive=false       # Option for recursive directory processing
    local rename_file=false     # New option to control whether to rename with sanitized name
    local files=()
    
    # Parse all options first
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--compress)
                compress=true
                shift
                ;;
            -e|--epub)
                epub=true
                shift
                ;;
            -o|--ocr)
                ocr=true
                shift
                ;;
            -t|--text)
                extract_text=true
                shift
                ;;
            -s|--sanitize)
                sanitize=true
                shift
                ;;
            -m|--metadata)
                show_metadata=true
                shift
                ;;
            -r|--rotate)
                #rotate the pdf
                rotate=true
                shift
                if [[ "$1" =~ ^(90|180|270)$ ]]; then
                    rotate_degrees="$1"
                    shift
                else
                    echo "❌ Error: Rotation must be 90, 180, or 270 degrees"
                    return 1
                fi
                ;;
            -q|--quiet)
                #quiet mode
                quiet_mode=true
                shift
                ;;
            -k|--keep)
                #keep the original file
                keep_originals=true
                shift
                ;;
            -p|--prompt)
                #prompt the user before overwriting or deleting the file
                prompt_user=true
                force_overwrite=false  # Disable force overwrite when prompt is enabled
                shift
                ;;
            -f|--force)
                #force overwrite of the file
                force_overwrite=true
                prompt_user=false  # Disable prompting when force is enabled
                shift
                ;;
            -h|--help)
                #show help and exit
                handle_pdf
                return 0
                ;;
            -R|--recursive)     
                #recursive processing of pdfs in a directory
                recursive=true
                shift
                ;;
            -n|--rename)
                #rename the file to the sanitized name
                rename_file=true
                shift
                ;;
            -*)
                echo "❌ Unknown option: $1"
                echo "Use 'handle_pdf --help' to see available options"
                return 1
                ;;
            *)
                # Add to files array
                files+=("$1")
                shift
                ;;
        esac
    done
    
    # Check if we have any files to process
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "❌ Error: No input files specified"
        return 1
    fi

    # Process each file or directory
    local processed_count=0
    local sanitized_count=0
    local failed_count=0
    
    for item in "${files[@]}"; do
        # Check if item is a directory
        if [[ -d "$item" ]]; then
            if [[ "$quiet_mode" != true ]]; then
                echo "📁 Processing directory: $item"
            fi
            
            # Find all PDF files in the directory
            local dir_pdfs=()
            
            if [[ "$recursive" == true ]]; then
                # Find PDFs recursively
                while IFS= read -r pdf_file; do
                    dir_pdfs+=("$pdf_file")
                done < <(find "$item" -type f -iname "*.pdf" 2>/dev/null)
            else
                # Find PDFs in just this directory
                while IFS= read -r pdf_file; do
                    dir_pdfs+=("$pdf_file")
                done < <(find "$item" -maxdepth 1 -type f -iname "*.pdf" 2>/dev/null)
            fi
            
            if [[ ${#dir_pdfs[@]} -eq 0 ]]; then
                echo "⚠️ No PDF files found in directory: $item"
                continue
            fi
            
            if [[ "$quiet_mode" != true ]]; then
                echo "🔍 Found ${#dir_pdfs[@]} PDF files to process"
            fi
            
            # Process each PDF in the directory
            for pdf in "${dir_pdfs[@]}"; do
                # Create a new argument list with the same options
                local pdf_args=()
                
                # Add all the option flags
                $compress && pdf_args+=("-c")
                $epub && pdf_args+=("-e")
                $ocr && pdf_args+=("-o")
                $extract_text && pdf_args+=("-t")
                $sanitize && pdf_args+=("-s")
                $show_metadata && pdf_args+=("-m")
                $rotate && pdf_args+=("-r" "$rotate_degrees")
                $quiet_mode && pdf_args+=("-q")
                $keep_originals && pdf_args+=("-k")
                $prompt_user && pdf_args+=("-p")
                $force_overwrite && pdf_args+=("-f")
                
                # Add the PDF file
                pdf_args+=("$pdf")
                
                # Process this PDF file
                handle_pdf "${pdf_args[@]}"
                
                # Update counts based on return code
                if [[ $? -eq 0 ]]; then
                    ((processed_count++))
                    $sanitize && ((sanitized_count++))
                else
                    ((failed_count++))
                fi
            done
        else
            # Check if file exists and is readable
            if [[ ! -e "$item" ]]; then
                echo "Warning: $item does not exist, skipping"
                continue
            fi
            
            if [[ ! -r "$item" ]]; then
                echo "Warning: $item is not readable, skipping"
                continue
            fi
            
            # Check if it's a PDF file
            if [[ "$item" =~ \.pdf$ ]]; then
                if [[ "$quiet_mode" != true ]]; then
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "📄 Processing '$item'"
                fi
                
                # Get the sanitized filename
                local dirname=$(dirname "$item")
                local basename=$(basename "$item" .pdf)
                
                # Better sanitization: replace spaces with underscores first, then remove special chars
                local sanitized_name=""
                if [[ "$sanitize" == true ]]; then
                    #remove (Z-Library) from the filename first 
                    sanitized_name=$(echo "$basename" | sed 's/(Z-Library)//g')
                    # Replace spaces with underscores, then remove other special characters
                    sanitized_name=$(echo "$sanitized_name" | tr ' ' '_' | tr -cd '[:alnum:]._-')
                    
                else
                    sanitized_name="$basename"
                fi
                
                # Determine output filename based on rename_file flag
        local output_file=""
                if [[ "$rename_file" == true && "$sanitize" == true ]]; then
                    # Use sanitized name when rename is requested
            output_file="${dirname}/${sanitized_name}.pdf"
            
                    # Don't overwrite input file with same name
                    if [[ "$output_file" == "$item" ]]; then
                output_file="${dirname}/${sanitized_name}_clean.pdf"
            fi
        else
                    # Default: use the original filename
                    output_file="$item"
                    
                    # For processing, we need a temporary file with a different name
                    local temp_final="${temp_dir}/final.pdf"
                fi
                
                # Check if output file exists and handle accordingly
                if [[ -f "$output_file" && "$output_file" != "$item" ]]; then
                    if [[ "$prompt_user" == true ]]; then
                        echo -n "⚠️ File '$output_file' already exists. Overwrite? (y/n): "
                        read overwrite
                        if [[ ! $overwrite =~ ^[Yy]$ ]]; then
                            echo "💾 Not overwritten, skipping file"
                            continue
                        fi
                    elif [[ "$force_overwrite" != true ]]; then
                        # If neither prompt nor force, skip
                        echo "⚠️ File '$output_file' already exists. Skipping (use -f to force overwrite)"
                        continue
                    fi
                    # Otherwise, with force_overwrite=true, we proceed without prompting
                fi
                
                # Create a temporary directory for processing
                local temp_dir=$(mktemp -d)
                trap 'rm -rf "$temp_dir"' EXIT
                
                # Temporary file for processing
                local temp_output="${temp_dir}/processed.pdf"
                
                # Process the PDF
                local processing_done=false
                
                if $show_metadata; then
                    echo "📋 PDF Metadata for '$item':"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    pdfinfo "$item"
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                fi
                
                # First, copy the file to our temp location
                cp "$item" "$temp_output"
                
                if $rotate; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Rotating PDF..."
                    fi
                    
                    local rotate_temp="${temp_dir}/rotated.pdf"
                    gs -q -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile="$rotate_temp" \
                       -c "<</Orientation $rotate_degrees>> setpagedevice" -f "$temp_output"
                    
                    if [[ -f "$rotate_temp" ]]; then
                        mv "$rotate_temp" "$temp_output"
                        processing_done=true
                    fi
                fi
                if $epub; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Converting PDF to EPUB..."
                    fi
                    
                    local epub_output="${dirname}/${sanitized_name}.epub"
                    
                    # Check if calibre's ebook-convert is installed
                    if command -v ebook-convert &> /dev/null; then
                        ebook-convert "$temp_output" "$epub_output"
                        
                        if [[ -f "$epub_output" ]]; then
                            if [[ "$quiet_mode" != true ]]; then
                                echo "✅ EPUB conversion complete: '$epub_output'"
                            fi
                            processing_done=true
                        else
                            echo "❌ EPUB conversion failed"
                        fi
                    else
                        echo "❌ Error: ebook-convert (Calibre) is required for EPUB conversion but not installed"
                        echo "Please install Calibre: brew install --cask calibre"
                        return 1
                    fi
                fi
                if $ocr; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Applying OCR..."
                    fi
                    
                    local ocr_temp="${temp_dir}/ocr.pdf"
                    
                    # Check if ocr_files function exists
                    if typeset -f ocr_files > /dev/null; then
                        ocr_files "$temp_output" "$ocr_temp"
                    # Check if ocrmyfile function exists
                    elif typeset -f ocrmyfile > /dev/null; then
                        ocrmyfile "$temp_output" "$ocr_temp"
                    else
                        ocrmypdf --skip-text "$temp_output" "$ocr_temp"
                    fi
                    
                    if [[ -f "$ocr_temp" ]]; then
                        mv "$ocr_temp" "$temp_output"
                        processing_done=true
                    fi
                fi
                
                if $extract_text; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "📝 Extracting text..."
                    fi
                    pdftotext "$temp_output" -
                    processing_done=true
                fi
                
                if $compress; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🗜️ Compressing PDF..."
                    fi
                    
                    local compress_temp="${temp_dir}/compressed.pdf"
                    gs -q -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -dPDFSETTINGS=/ebook \
                       -dCompatibilityLevel=1.4 -sOutputFile="$compress_temp" "$temp_output"
                    
                    if [[ -f "$compress_temp" ]]; then
                        mv "$compress_temp" "$temp_output"
                        processing_done=true
                    fi
                fi
                
                # If sanitize is the only option and no processing was done, we still need to mark it
                if $sanitize && [[ "$processing_done" == false ]]; then
                    if [[ "$quiet_mode" != true ]]; then
                        echo "🔄 Sanitizing filename..."
                    fi
                    processing_done=true
                    ((sanitized_count++))
                fi
                
                # Check if processing was successful
                if [[ -f "$temp_output" && "$processing_done" == true ]]; then
                    if [[ "$output_file" == "$item" ]]; then
                        # When replacing the original file, use a temporary final file first
                        cp "$temp_output" "$temp_final"
                        
                        # Then replace the original
                        mv "$temp_final" "$output_file"
                    else
                        # When using a different output name, just copy directly
                        cp "$temp_output" "$output_file"
                        
                        # Handle original file (delete by default unless keep_originals is true)
                        if [[ "$prompt_user" == true ]]; then
                            echo -n "❓ Do you want to delete the original file '$item'? (y/n): "
                            read delete_original
                            if [[ $delete_original =~ ^[Yy]$ ]]; then
                                rm -f "$item"
                                if [[ "$quiet_mode" != true ]]; then
                                    echo "🗑️ Original file deleted."
                                fi
                            else
                                if [[ "$quiet_mode" != true ]]; then
                                    echo "💾 Original file kept."
                                fi
                            fi
                        elif [[ "$keep_originals" == true ]]; then
                            if [[ "$quiet_mode" != true ]]; then
                                echo "💾 Original file kept (--keep option)."
                            fi
                        else
                            # Default behavior: delete original without prompting
                            rm -f "$item"
                            if [[ "$quiet_mode" != true ]]; then
                                echo "🗑️ Original file deleted."
                            fi
                        fi
                    fi
                    
                    ((processed_count++))
                else
                    echo "❌ Processing failed for '$item'"
                    ((failed_count++))
                fi
            else
                echo "⚠️ Skipping non-PDF file: $item"
            fi
        fi
    done
    
    # Show summary
    if [[ "$quiet_mode" != true ]]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📋 Summary:"
        echo "  - $processed_count file(s) processed successfully"
        if [[ $sanitized_count -gt 0 ]]; then
            echo "  - $sanitized_count file(s) sanitized"
        fi
        if [[ $failed_count -gt 0 ]]; then
            echo "  - $failed_count file(s) failed to process"
        fi
    fi
    
    return 0
}

virus_scan() {
    # help menu with -h or --help and usage
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: virus_scan [file/directory...]"
        echo "   function from dotfiles or: findex \"*.pdf\" | virus_scan"
        echo "   or: virus_scan \$(findex \"*.pdf\")"
        echo ""
        echo "Features:"
        echo "  - Scans files and directories for viruses using ClamAV"
        echo "  - Can sanitize PDF files to remove potential malicious code"
        echo "  - Sanitized PDFs are automatically considered safe (not scanned)"
        echo "  - Logs scan results for future reference"
        return 0
    fi
    local files=()
    
    # Check if receiving input from pipe or arguments
    if [[ -p /dev/stdin ]]; then
        # Read from pipe (e.g., findex output)
        while IFS= read -r line; do
            files+=("$line")
        done
    elif [[ $# -gt 0 ]]; then
        # Read from arguments
        files=("$@")
    else
        # No input provided
        echo "Usage: virus_scan [file/directory...]"
        echo "   function from dotfiles or: findex \"*.pdf\" | virus_scan"
        echo "   or: virus_scan \$(findex \"*.pdf\")"
        echo ""
        echo "Examples:"
        echo "  virus_scan ~/Downloads"
        echo "  virus_scan document.pdf image.jpg"
        echo "  findex \"*.pdf\" | virus_scan"
        echo "  virus_scan \$(findex \"*.pdf\")"
        return 1
    fi
    
    # Check if clamscan is installed
    if ! command -v clamscan &> /dev/null; then
        echo "Error: clamscan is not installed."
        # Prompt user to install
        local install_clamav="n"
        echo -n "Do you want to install ClamAV? (y/n): " 
        read install_clamav
        if [[ $install_clamav =~ ^[Yy]$ ]]; then
            echo "Installing and Configuring ClamAV"
            clamav_maintenance
            # Verify installation succeeded
            if ! command -v clamscan &> /dev/null; then
                echo "Installation failed. Please install ClamAV manually."
                return 1
            fi
        else
            return 1
        fi
    fi

    # Create log directory if it doesn't exist
    local log_dir="$HOME/logs/clamscan"
    mkdir -p "$log_dir"
    local log_file="$log_dir/scan_$(date +%Y%m%d_%H%M%S).log"
    
    # Check for PDF files and offer to sanitize them
    local pdf_files=()
    local non_pdf_files=()
    
    for file in "${files[@]}"; do
        if [[ ! -e "$file" ]]; then
            echo "Warning: $file does not exist, skipping"
            continue
        fi
        
        if [[ ! -r "$file" ]]; then
            echo "Warning: $file is not readable, skipping"
            continue
        fi
        
        # Check if it's a PDF file
        if [[ "$file" =~ \.pdf$ ]]; then
            pdf_files+=("$file")
        else
            non_pdf_files+=("$file")
        fi
    done
    
    # If we found PDF files, offer to sanitize them
    local sanitized_count=0
    local files_to_scan=("${non_pdf_files[@]}")
    
    if [[ ${#pdf_files[@]} -gt 0 ]]; then
        echo "📄 Found ${#pdf_files[@]} PDF file(s) in the scan list."
        echo "PDF files can contain malicious code. Would you like to sanitize them?"
        echo "This will create clean copies and remove the originals."
        echo "Sanitized PDFs are automatically considered safe and won't need scanning."
        echo -n "Sanitize PDF files? (y/n): "
        read sanitize_pdfs
        
        if [[ $sanitize_pdfs =~ ^[Yy]$ ]]; then
            # Check if handle_pdf function exists
            if ! typeset -f handle_pdf > /dev/null; then
                echo "❌ Error: handle_pdf function not found. Cannot sanitize PDFs."
                # Add PDFs to scan list if we can't sanitize them
                files_to_scan+=("${pdf_files[@]}")
            else
                echo "🔄 Sanitizing PDF files..."
                local unsanitized_pdfs=()
                
                for pdf in "${pdf_files[@]}"; do
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "🔄 Sanitizing: $pdf"
                    
                    # Get the sanitized filename that handle_pdf would create
                    local dirname=$(dirname "$pdf")
                    local basename=$(basename "$pdf" .pdf)
                    local sanitized_name=$(echo "$basename" | tr -cd '[:alnum:]._-')
                    local sanitized_pdf="${dirname}/${sanitized_name}.pdf"
                    
                    # Don't overwrite input file
                    if [[ "$sanitized_pdf" == "$pdf" ]]; then
                        sanitized_pdf="${dirname}/${sanitized_name}_clean.pdf"
                    fi
                    
                    # Run handle_pdf with sanitize option and automatically delete original
                    handle_pdf -s -q "$pdf"
                            echo "🗑️ Removing original file: $pdf"
                            rm -f "$pdf"
                        fi
                    else
                        echo "⚠️ Sanitization failed for: $pdf"
                        # Add to list of PDFs that need scanning
                        unsanitized_pdfs+=("$pdf")
                    fi
                done
                        # Automatically delete the original when prompted by handle_pdf
                        # The sanitized file is already clean and doesn't need scanning
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "📄 PDF sanitization complete. $sanitized_count PDFs sanitized and originals removed."
                
                # Add any unsanitized PDFs to the scan list
            # User chose not to sanitize, add all PDFs to scan list
            files_to_scan+=("${pdf_files[@]}")
        fi
    fi
    
    # Process each file for scanning
    local valid_files=0
    
                echo "📄 PDF sanitization complete. $sanitized_count PDFs sanitized."
    if [[ ${#files_to_scan[@]} -eq 0 ]]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "✅ All files have been sanitized. No virus scanning needed."
        echo "📝 Sanitization log saved to: $log_file"
        return 0
    fi
    
    echo "Files to be scanned:"
    for file in "${files_to_scan[@]}"; do
        if [[ -e "$file" && -r "$file" ]]; then
            echo "  - $file"
            ((valid_files++))
        fi
    done
    
    # Check if we have any valid files to scan
    if [[ $valid_files -eq 0 ]]; then
        if [[ $sanitized_count -gt 0 ]]; then
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ All files have been sanitized. No virus scanning needed."
            echo "📝 Sanitization log saved to: $log_file"
            return 0
        else
            echo "No valid files to scan"
            return 1
        fi
    fi
    
    # Run the actual scan with logging
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "🔍 Starting virus scan at $(date)" | tee -a "$log_file"
    echo "📝 Scan log saved to: $log_file"
    
    clamscan --recursive=yes --infected "${files_to_scan[@]}" | tee -a "$log_file"
    local scan_status=$?
    
    # Report results
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    # Include sanitized files in the summary
    if [[ $sanitized_count -gt 0 ]]; then
        echo "📋 Summary:"
        echo "  - $sanitized_count PDF files sanitized and considered safe"
        echo "  - $valid_files other files scanned"
    fi
    
    case $scan_status in
        0) echo "✅ No viruses found" ;;
        1) echo "⚠️ Viruses found! Check $log_file for details" ;;
        2) echo "❌ Error occurred during scanning" ;;
    esac
    
    return $scan_status
}
    
    # Process each file
    local file_count=0
    local success_count=0
    
    for input_file in "${files[@]}"; do
        # Skip non-PDF files
        if [[ ! "$input_file" =~ \.pdf$ ]]; then
            echo "⚠️ Skipping non-PDF file: $input_file"
            continue
        fi
        
        # Validate input file
        if [[ ! -f "$input_file" ]]; then
            echo "❌ Error: File '$input_file' does not exist, skipping"
            continue
        fi
        
        ((file_count++))
        
        # Set default output file
        local output_file=""
        
        # If sanitize is true, create sanitized filename
        if [[ "$sanitize" == true ]]; then
            local dirname=$(dirname "$input_file")
            local basename=$(basename "$input_file" .pdf)
            # Remove spaces and special characters
            local sanitized_name=$(echo "$basename" | tr -cd '[:alnum:]._-')
            output_file="${dirname}/${sanitized_name}.pdf"
            
            # Don't overwrite input file
            if [[ "$output_file" == "$input_file" ]]; then
                output_file="${dirname}/${sanitized_name}_clean.pdf"
            fi
        else
            # Default output adds _processed suffix
            output_file="${input_file%.pdf}_processed.pdf"
        fi
        
        # Create a temporary directory for processing
        local temp_dir=$(mktemp -d)
        local temp_file="${temp_dir}/input.pdf"
        cp "$input_file" "$temp_file"
        local current_file="$temp_file"
        
        # Set up trap to clean temporary files on exit
        trap "rm -rf '$temp_dir'" EXIT
        
        # Process the PDF
        echo "🔄 Processing '$input_file'..."
        
        # Check for required tools and prompt for installation
        if [[ "$compress" == true || "$sanitize" == true || "$rotate" == true ]]; then
            if ! command -v gs &> /dev/null; then
                echo "❌ Error: Ghostscript (gs) is required but not installed"
                echo -n "Do you want to install Ghostscript now? (y/n): "
                read install_gs
                if [[ "$install_gs" =~ ^[Yy]$ ]]; then
                    echo "📦 Installing Ghostscript..."
                    brew install ghostscript
                    if ! command -v gs &> /dev/null; then
                        echo "❌ Installation failed. Please install Ghostscript manually."
                        continue
                    fi
                    echo "✅ Ghostscript installed successfully"
                else
                    continue
                fi
            fi
        fi
        
        if [[ "$ocr" == true ]]; then
            # Check if we have the ocr_files function available
            if ! typeset -f ocr_files > /dev/null; then
                # Check for OCR tools
                if ! command -v ocrmypdf &> /dev/null; then
                    echo "❌ Error: ocrmypdf is required for OCR but not installed"
                    echo -n "Do you want to install ocrmypdf now? (y/n): "
                    read install_ocrmypdf
                    if [[ "$install_ocrmypdf" =~ ^[Yy]$ ]]; then
                        echo "📦 Installing ocrmypdf..."
                        pip install ocrmypdf
                        if ! command -v ocrmypdf &> /dev/null; then
                            echo "❌ Installation failed. Please install ocrmypdf manually."
                            continue
                        fi
                        echo "✅ ocrmypdf installed successfully"
                    else
                        continue
                    fi
                fi
            fi
        fi
        
        # Show metadata if requested
        if [[ "$show_metadata" == true ]]; then
            if ! command -v pdfinfo &> /dev/null; then
                echo "❌ Error: pdfinfo is required but not installed"
                echo -n "Do you want to install poppler (includes pdfinfo) now? (y/n): "
                read install_poppler
                if [[ "$install_poppler" =~ ^[Yy]$ ]]; then
                    echo "📦 Installing poppler..."
                    brew install poppler
                    if ! command -v pdfinfo &> /dev/null; then
                        echo "❌ Installation failed. Please install poppler manually."
                        continue
                    fi
                    echo "✅ poppler installed successfully"
                else
                    continue
                fi
            fi
            
            echo "📋 PDF Metadata for '$input_file':"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            pdfinfo "$input_file"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            # If only showing metadata, continue to next file
            if [[ "$compress" == false && "$ocr" == false && "$extract_text" == false && "$sanitize" == false && "$rotate" == false ]]; then
                ((success_count++))
                continue
            fi
        fi
        
        # Extract text if requested
        if [[ "$extract_text" == true ]]; then
            if ! command -v pdftotext &> /dev/null; then
                echo "❌ Error: pdftotext is required but not installed"
                echo -n "Do you want to install poppler (includes pdftotext) now? (y/n): "
                read install_poppler
                if [[ "$install_poppler" =~ ^[Yy]$ ]]; then
                    echo "📦 Installing poppler..."
                    brew install poppler
                    if ! command -v pdftotext &> /dev/null; then
                        echo "❌ Installation failed. Please install poppler manually."
                        continue
                    fi
                    echo "✅ poppler installed successfully"
                else
                    continue
                fi
            fi
            
            echo "📄 Extracting text from '$input_file'..."
            pdftotext "$input_file" -
            ((success_count++))
            continue
        fi
        
        # Sanitize/compress/rotate with Ghostscript
        if [[ "$compress" == true || "$sanitize" == true || "$rotate" == true ]]; then
            local next_file="${temp_dir}/gs_output.pdf"
            
            if [[ "$quiet_mode" != true ]]; then
                echo "🔄 Running Ghostscript..."
            fi
            
            # Run Ghostscript with appropriate options
            if [[ "$quiet_mode" == true ]]; then
                gs -q -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile="$next_file" \
                   $([[ "$compress" == true ]] && echo "-dPDFSETTINGS=/ebook") \
                   $([[ "$rotate" == true ]] && echo "-dAutoRotatePages=/None -c \"<</Orientation $rotate_degrees>> setpagedevice\"") \
                   "$current_file" 2>/dev/null
            else
                gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile="$next_file" \
                   $([[ "$compress" == true ]] && echo "-dPDFSETTINGS=/ebook") \
                   $([[ "$rotate" == true ]] && echo "-dAutoRotatePages=/None -c \"<</Orientation $rotate_degrees>> setpagedevice\"") \
                   "$current_file"
            fi
            
            # Check if successful
            if [[ $? -ne 0 ]]; then
                echo "❌ Error: Ghostscript processing failed for '$input_file'"
                continue
            fi
            
            current_file="$next_file"
        fi
        
        # Apply OCR if requested
        if [[ "$ocr" == true ]]; then
            echo "🔄 Applying OCR to make text searchable..."
            local next_file="${temp_dir}/ocr_output.pdf"
            
            # Check for and use existing OCR functions in order of preference
            if typeset -f ocr_files > /dev/null; then
                echo "🔄 Using existing ocr_files function for OCR processing"
                ocr_files "$current_file" "$next_file"
            elif typeset -f ocrmyfile > /dev/null; then
                echo "🔄 Using existing ocrmyfile function for OCR processing"
                ocrmyfile "$current_file" "$next_file"
            elif typeset -f ocr_pdf > /dev/null; then
                echo "🔄 Using existing ocr_pdf function for OCR processing"
                ocr_pdf "$current_file" "$next_file"
            else
                ocrmypdf --skip-text "$current_file" "$next_file"
            fi
            
            # Check if successful
            if [[ $? -ne 0 ]]; then
                echo "❌ Error: OCR processing failed for '$input_file'"
                continue
            fi
            
            current_file="$next_file"
        fi
        
        # Check if output file already exists and prompt for overwrite
        if [[ -f "$output_file" && "$output_file" != "$input_file" ]]; then
            echo -n "⚠️ File '$output_file' already exists. Overwrite? (y/n): "
            read overwrite
            if [[ ! "$overwrite" =~ ^[Yy]$ ]]; then
                echo "Operation cancelled for '$input_file'. Processed file not saved."
                continue
            fi
        fi
        
        # Move the processed file to the final destination
        cp "$current_file" "$output_file"
        
        echo "✅ Processing complete: '$output_file'"
        
        # Show file size comparison
        if [[ "$input_file" != "$output_file" ]]; then
            # Use macOS compatible file size commands
            local original_size=$(stat -f "%z" "$input_file" | awk '{ suffix="BKMGTPEZY"; for(i=0; $1>1024 && i < length(suffix); i++) $1/=1024; printf "%.1f%s", $1, substr(suffix, i+1, 1); }')
            local new_size=$(stat -f "%z" "$output_file" | awk '{ suffix="BKMGTPEZY"; for(i=0; $1>1024 && i < length(suffix); i++) $1/=1024; printf "%.1f%s", $1, substr(suffix, i+1, 1); }')
            echo "📊 Original size: $original_size, New size: $new_size"
            
            # Calculate percentage change
            local original_bytes=$(stat -f "%z" "$input_file")
            local new_bytes=$(stat -f "%z" "$output_file")
            if [[ $original_bytes -gt 0 ]]; then
                if command -v bc &> /dev/null; then
                    local percent_change=$(echo "scale=1; ($new_bytes - $original_bytes) * 100 / $original_bytes" | bc 2>/dev/null)
                    if [[ $? -eq 0 ]]; then
                        if [[ $(echo "$percent_change < 0" | bc) -eq 1 ]]; then
                            echo "🔽 Reduced by $(echo $percent_change | tr -d '-')% from original"
                        elif [[ $(echo "$percent_change > 0" | bc) -eq 1 ]]; then
                            echo "🔼 Increased by $percent_change% from original"
                        else
                            echo "📊 File size unchanged"
                        fi
                    fi
                fi
            fi
            
            # Ask if user wants to delete the original
            echo -n "❓ Do you want to delete the original file '$input_file'? (y/n): "
            read delete_original
            if [[ "$delete_original" =~ ^[Yy]$ ]]; then
                rm -f "$input_file"
                echo "🗑️ Original file deleted."
            else
                echo "💾 Original file kept."
            fi
        fi
        
        ((success_count++))
        
        # Add a separator between files if processing multiple
        if [[ ${#files[@]} -gt 1 && file_count < ${#files[@]} ]]; then
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        fi
    done
    
    # Summary if multiple files were processed
    if [[ $file_count -gt 1 ]]; then
        echo "📋 Summary: Successfully processed $success_count of $file_count PDF files"
    fi
    
    return 0
}

# Virus Scan
alias scan_file="virus_scan"
alias scan_dir="virus_scan"
alias scan_files="virus_scan"
alias scan_dirs="virus_scan"
virus_scan() {
    # help menu with -h or --help and usage
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: virus_scan [file/directory...]"
        echo "   function from dotfiles or: findex \"*.pdf\" | virus_scan"
        echo "   or: virus_scan \$(findex \"*.pdf\")"
        echo ""
        echo "Features:"
        echo "  - Scans files and directories for viruses using ClamAV"
        echo "  - Can sanitize PDF files to remove potential malicious code"
        echo "  - Sanitized PDFs are automatically considered safe (not scanned)"
        echo "  - Logs scan results for future reference"
        return 0
    fi
    local files=()
    
    # Check if receiving input from pipe or arguments
    if [[ -p /dev/stdin ]]; then
        # Read from pipe (e.g., findex output)
        while IFS= read -r line; do
            files+=("$line")
        done
    elif [[ $# -gt 0 ]]; then
        # Read from arguments
        files=("$@")
    else
        # No input provided
        echo "Usage: virus_scan [file/directory...]"
        echo "   function from dotfiles or: findex \"*.pdf\" | virus_scan"
        echo "   or: virus_scan \$(findex \"*.pdf\")"
        echo ""
        echo "Examples:"
        echo "  virus_scan ~/Downloads"
        echo "  virus_scan document.pdf image.jpg"
        echo "  findex \"*.pdf\" | virus_scan"
        echo "  virus_scan \$(findex \"*.pdf\")"
        return 1
    fi
    
    # Check if clamscan is installed
    if ! command -v clamscan &> /dev/null; then
        echo "Error: clamscan is not installed."
        # Prompt user to install
        local install_clamav="n"
        echo -n "Do you want to install ClamAV? (y/n): " 
        read install_clamav
        if [[ $install_clamav =~ ^[Yy]$ ]]; then
            echo "Installing and Configuring ClamAV"
            clamav_maintenance
            # Verify installation succeeded
            if ! command -v clamscan &> /dev/null; then
                echo "Installation failed. Please install ClamAV manually."
                return 1
            fi
        else
            return 1
        fi
    fi

    # Create log directory if it doesn't exist
    local log_dir="$HOME/logs/clamscan"
    mkdir -p "$log_dir"
    local log_file="$log_dir/scan_$(date +%Y%m%d_%H%M%S).log"
    
    # Check for PDF files and offer to sanitize them
    local pdf_files=()
    local non_pdf_files=()
    
    for file in "${files[@]}"; do
        if [[ ! -e "$file" ]]; then
            echo "Warning: $file does not exist, skipping"
            continue
        fi
        
        if [[ ! -r "$file" ]]; then
            echo "Warning: $file is not readable, skipping"
            continue
        fi
        
        # Check if it's a PDF file
        if [[ "$file" =~ \.pdf$ ]]; then
            pdf_files+=("$file")
        else
            non_pdf_files+=("$file")
        fi
    done
    
    # If we found PDF files, offer to sanitize them
    local sanitized_count=0
    local files_to_scan=("${non_pdf_files[@]}")
    
    if [[ ${#pdf_files[@]} -gt 0 ]]; then
        echo "📄 Found ${#pdf_files[@]} PDF file(s) in the scan list."
        echo "PDF files can contain malicious code. Would you like to sanitize them?"
        echo "This will create clean copies and remove the originals."
        echo "Sanitized PDFs are automatically considered safe and won't need scanning."
        echo -n "Sanitize PDF files? (y/n): "
        read sanitize_pdfs
        
        if [[ $sanitize_pdfs =~ ^[Yy]$ ]]; then
            # Check if handle_pdf function exists
            if ! typeset -f handle_pdf > /dev/null; then
                echo "❌ Error: handle_pdf function not found. Cannot sanitize PDFs."
                # Add PDFs to scan list if we can't sanitize them
                files_to_scan+=("${pdf_files[@]}")
            else
                echo "🔄 Sanitizing PDF files..."
                local unsanitized_pdfs=()
                
                for pdf in "${pdf_files[@]}"; do
                    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                    echo "🔄 Sanitizing: $pdf"
                    
                    # Get the sanitized filename that handle_pdf would create
                    local dirname=$(dirname "$pdf")
                    local basename=$(basename "$pdf" .pdf)
                    local sanitized_name=$(echo "$basename" | tr -cd '[:alnum:]._-')
                    local sanitized_pdf="${dirname}/${sanitized_name}.pdf"
                    
                    # Don't overwrite input file
                    if [[ "$sanitized_pdf" == "$pdf" ]]; then
                        sanitized_pdf="${dirname}/${sanitized_name}_clean.pdf"
                    fi
                    
                    # Run handle_pdf with sanitize option and automatically delete original
                    handle_pdf -s -q "$pdf"
                    
                    # Check if sanitization was successful
                    if [[ -f "$sanitized_pdf" || -f "${dirname}/${sanitized_name}_clean.pdf" ]]; then
                        if [[ -f "$sanitized_pdf" ]]; then
                            echo "✅ Sanitized PDF created: $sanitized_pdf"
                        else
                            echo "✅ Sanitized PDF created: ${dirname}/${sanitized_name}_clean.pdf"
                        fi
                        
                        # Automatically delete the original when prompted by handle_pdf
                        # The sanitized file is already clean and doesn't need scanning
                        ((sanitized_count++))
                        
                        # Log the sanitization in the scan log
                        echo "$(date): Sanitized PDF: $pdf" >> "$log_file"
                    else
                        echo "⚠️ Sanitization failed for: $pdf"
                        # Add to list of PDFs that need scanning
                        unsanitized_pdfs+=("$pdf")
                    fi
                done
                
                echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                echo "📄 PDF sanitization complete. $sanitized_count PDFs sanitized."
                
                # Add any unsanitized PDFs to the scan list
                if [[ ${#unsanitized_pdfs[@]} -gt 0 ]]; then
                    echo "⚠️ ${#unsanitized_pdfs[@]} PDFs could not be sanitized and will be scanned."
                    files_to_scan+=("${unsanitized_pdfs[@]}")
                fi
            fi
        else
            # User chose not to sanitize, add all PDFs to scan list
            files_to_scan+=("${pdf_files[@]}")
        fi
    fi
    
    # Process each file for scanning
    local valid_files=0
    
    # Check if we have any files left to scan
    if [[ ${#files_to_scan[@]} -eq 0 ]]; then
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "✅ All files have been sanitized. No virus scanning needed."
        echo "📝 Sanitization log saved to: $log_file"
        return 0
    fi
    
    echo "Files to be scanned:"
    for file in "${files_to_scan[@]}"; do
        if [[ -e "$file" && -r "$file" ]]; then
            echo "  - $file"
            ((valid_files++))
        fi
    done
    
    # Check if we have any valid files to scan
    if [[ $valid_files -eq 0 ]]; then
        if [[ $sanitized_count -gt 0 ]]; then
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ All files have been sanitized. No virus scanning needed."
            echo "📝 Sanitization log saved to: $log_file"
            return 0
        else
            echo "No valid files to scan"
            return 1
        fi
    fi
    
    # Run the actual scan with logging
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "🔍 Starting virus scan at $(date)" | tee -a "$log_file"
    echo "📝 Scan log saved to: $log_file"
    
    clamscan --recursive=yes --infected "${files_to_scan[@]}" | tee -a "$log_file"
    local scan_status=$?
    
    # Report results
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    # Include sanitized files in the summary
    if [[ $sanitized_count -gt 0 ]]; then
        echo "📋 Summary:"
        echo "  - $sanitized_count PDF files sanitized and considered safe"
        echo "  - $valid_files other files scanned"
    fi
    
    case $scan_status in
        0) echo "✅ No viruses found" ;;
        1) echo "⚠️ Viruses found! Check $log_file for details" ;;
        2) echo "❌ Error occurred during scanning" ;;
    esac
    
    return $scan_status
}

clamav_maintenance(){
    CONFIG="/opt/homebrew/etc/clamav/freshclam.conf"
    DB_DIR="/opt/homebrew/var/lib/clamav"
    EXPECTED_MIRROR="DatabaseMirror database.clamav.net"
    # Check if clamav is installed

    echo "=== ClamAV Maintenance ==="
    # Check if clamav is installed
    echo "Checking if clamav is installed"
    if ! command -v clamav &> /dev/null; then
        echo "Error: clamav is not installed"
        #prompt to install if yes install and continue else return 1
        install_clamav="n"
        echo -n "Do you want to install clamav? (y/n): " 
        read install_clamav
        if [[ $install_clamav =~ ^[Yy]$ ]]; then
            brew install clamav
            echo "clamav installed, continuing with maintenance"
        else
            return 1
        fi
    fi
        # Check if config file exists; if not, search for it.
    if [ ! -f "$CONFIG" ]; then
    echo "Error: $CONFIG not found."
    echo "Searching for freshclam.conf in /opt/homebrew..."
    new_config=$(find /opt/homebrew -type f -name freshclam.conf 2>/dev/null | head -n 1)
    if [ -n "$new_config" ]; then
        echo "Found config file at: $new_config"
        read -p "Use this config file? (y/n): " use_new_config
        if [[ "$use_new_config" =~ ^[Yy] ]]; then
            CONFIG="$new_config"
            echo "Using config: $CONFIG"
        else
            echo "No valid config selected. Exiting."
            return 1
        fi
    else
        echo "No freshclam.conf found on the system."
        return 1
    fi
    fi

    # Remove the "Example" marker if present.
    if grep -q "^Example" "$CONFIG"; then
    echo "Removing 'Example' marker from config file..."
    sudo sed -i.bak '/^Example/d' "$CONFIG"
    fi

    # Check the DatabaseMirror setting.
    current_mirror=$(grep "^DatabaseMirror" "$CONFIG" | head -n1)
    if [ -z "$current_mirror" ]; then
    echo "No DatabaseMirror setting found. Appending expected value."
    echo "$EXPECTED_MIRROR" | sudo tee -a "$CONFIG" >/dev/null
    elif ! echo "$current_mirror" | grep -qi "database\.clamav\.net"; then
    echo "Found DatabaseMirror: $current_mirror"
    echo "Updating to use: $EXPECTED_MIRROR..."
    sudo sed -i.bak "s|^DatabaseMirror.*|$EXPECTED_MIRROR|" "$CONFIG"
    else
    echo "DatabaseMirror is correctly set: $current_mirror"
    fi

    # Ensure the database directory exists; if not, search or create it.
    if [ ! -d "$DB_DIR" ]; then
    echo "Database directory $DB_DIR not found."
    echo "Searching for a possible ClamAV database directory in /opt/homebrew..."
    new_db_dir=$(find /opt/homebrew -type d -name clamav 2>/dev/null | head -n 1)
    if [ -n "$new_db_dir" ]; then
        echo "Found potential database directory: $new_db_dir"
        read -p "Use this directory? (y/n): " use_new_db
        if [[ "$use_new_db" =~ ^[Yy] ]]; then
            DB_DIR="$new_db_dir"
            echo "Using database directory: $DB_DIR"
        else
            echo "No valid directory selected. Creating default: $DB_DIR..."
            sudo mkdir -p "$DB_DIR" || { echo "Failed to create directory"; return 1; }
        fi
    else
        echo "No alternate database directory found. Creating default: $DB_DIR..."
        sudo mkdir -p "$DB_DIR" || { echo "Failed to create directory"; return 1; }
    fi
    fi

    # Set ownership of the database directory.
    echo "Setting ownership of $DB_DIR to _clamav:_clamav..."
    sudo chown -R _clamav:_clamav "$DB_DIR"

    # Run freshclam update.
    echo "Running freshclam update..."
    echo "This ensures the virus database is up to date"
    echo "This may take a while..."
    sudo freshclam
    if [ $? -eq 0 ]; then
    echo "ClamAV database updated successfully."
    else
    echo "ClamAV update encountered errors. Please review the output above."
    fi

    echo "=== ClamAV Maintenance Completed ==="
}


# ----------------------
# Helper Functions
# ----------------------
# Colorize the `ls` output and setup useful aliases
export LS_OPTIONS='--color=auto'
alias ls='ls $LS_OPTIONS'
alias ll='ls -lh $LS_OPTIONS'        # Detailed list view
alias la='ls -lha $LS_OPTIONS'       # Show hidden files
alias l='ls -lA $LS_OPTIONS'         # Short list view with hidden files
alias lt='ls -strhal $LS_OPTIONS'       # Sort by date, most recent last

# Safe aliases to prevent accidental file overwrites or deletions
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Navigation Function
# Fast directory navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."

# change dir and List Directory Contents
cdl(){
  if [ -n "$1" ]; then
    cd "$1" && ll
  else
    cd ~ && ll
  fi
}

# create backup of a file or directory
backup(){
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  
  # take files, dictionaries as arguments get full path as needed many args possible
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done
}
# Searching 
# Grep aliases and functions
alias grep='grep -i --color=auto "$@"' # Ignore case and colorize output and pass all arguments to grep in quotes
alias grepv='grep -vi --color=auto' # Ignore case, invert match, and colorize output

# Find aliases and functions
alias findf='find . -type f -name' # Find files by name
alias findd='find . -type d -name' # Find directories by name

# Find files matching a pattern and execute a command on them
findex(){
  # Skip if being sourced (zsh-specific check)
  if [[ ${zsh_eval_context[-1]} == "file" ]]; then
    return 0
  fi
  
  # Show help menu if -h or --help is passed or no arguments provided
  if [[ "$1" == "-h" || "$1" == "--help" || $# -eq 0 ]]; then
    echo "Usage: findex [OPTIONS] [PATH] PATTERN COMMAND [--shift] [ARGS...]"
    echo ""
    echo "Required arguments:"
    echo "  PATTERN       File pattern to search for (e.g., '*.txt')"
    echo "  COMMAND       Command to execute on each matching file"
    echo ""
    echo "Optional arguments:"
    echo "  PATH          Directory path to search in (default: current directory)"
    echo "  -d DEPTH      Maximum directory depth to search (default: unlimited)"
    echo "  -t TYPE       File type: f (files), d (directories), l (symlinks)"
    echo "  --shift       Place all arguments after --shift to the right of the file placeholder"
    echo ""
    echo "Examples:"
    echo "  findex '*.txt' ls -l                         # List all text files in current dir"
    echo "  findex /home '*.pdf' ls -l                   # List all PDF files in /home"
    echo "  findex -d 2 '*.sh' chmod 755                 # Make shell scripts executable (max depth 2)"
    echo "  findex -t f /var/log '*.log' grep 'error'    # Search for 'error' in log files"
    echo "  findex '*.txt' sed -i 's/old/new/g'          # Replace text in all text files"
    echo "  findex /tmp '*.jpg' 'convert {} -resize 50% {}.resized'  # Resize all JPG files in /tmp"
    echo "  findex -d 2 ~/Documents '*.pdf' cp --shift /tmp/     # Copy PDFs to /tmp directory"
    return 0
  fi
    
  local max_depth=""
  local file_type=""
  local search_path="."  # Default to current directory
  local pattern=""
  local command=""
  local pre_shift_args=()
  local post_shift_args=()
  local shift_mode=false
  
  # Check for --shift anywhere in the arguments and remove it
  for arg in "$@"; do
    if [[ "$arg" == "--shift" ]]; then
      shift_mode=true
      break
    fi
  done
  
  # Parse options first
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d)
        if [[ -z "$2" || "$2" == -* ]]; then
          echo "Error: -d requires a depth argument"
          return 1
        fi
        max_depth="-maxdepth $2"
        shift 2
        ;;
      -t)
        if [[ -z "$2" || "$2" == -* ]]; then
          echo "Error: -t requires a type argument (f, d, or l)"
          return 1
        fi
        file_type="-type $2"
        shift 2
        ;;
      --shift)
        # Just skip the --shift flag, we already processed it
        shift
        ;;
      -*)
        echo "Unknown option: $1"
        echo "Use 'findex --help' for usage information."
        return 1
        ;;
      *)
        # If pattern is not set yet, check if this is a directory path
        if [[ -z "$pattern" ]]; then
          if [[ -d "$1" ]]; then
            search_path="$1"
          else
            pattern="$1"
          fi
        elif [[ -z "$command" ]]; then
          # This is the command
          command="$1"
        elif [[ "$shift_mode" == true && "$1" != "--shift" ]]; then
          # Add to post-shift arguments
          post_shift_args+=("$1")
        else
          # Add to pre-shift arguments
          pre_shift_args+=("$1")
        fi
        shift
        ;;
    esac
  done
  
  # Check if we have all required arguments
  if [[ -z "$pattern" || -z "$command" ]]; then
    echo "Error: Missing pattern or command. See 'findex --help' for usage."
    return 1
  fi
  
  # Expand the search path to handle ~ and other shell expansions
  search_path=$(eval echo "$search_path")
  
  # Construct and show the find command that will be executed
  local find_cmd=""
  
  # Special handling for common commands that need specific argument order
  if [[ ${#post_shift_args[@]} -gt 0 ]]; then
    # If we have post-shift arguments, construct command with them after the file placeholder
    find_cmd="find \"$search_path\" $max_depth $file_type -name \"$pattern\" -exec $command"
    
    # Add pre-shift arguments if any
    for arg in "${pre_shift_args[@]}"; do
      find_cmd+=" \"$arg\""
    done
    
    # Add the file placeholder
    find_cmd+=" {}"
    
    # Add post-shift arguments
    for arg in "${post_shift_args[@]}"; do
      find_cmd+=" \"$arg\""
    done
    
    find_cmd+=" \\;"
  else
    # Standard execution with all arguments before the file placeholder
    find_cmd="find \"$search_path\" $max_depth $file_type -name \"$pattern\" -exec $command"
    
    # Add all arguments
    for arg in "${pre_shift_args[@]}"; do
      find_cmd+=" \"$arg\""
    done
    
    # Add the file placeholder at the end
    find_cmd+=" {} \\;"
  fi
  
  echo "DEBUG: $find_cmd"
  
  # Additional debug: List files in the search path to verify it exists and is accessible
  echo "DEBUG: Files in search path (first 5):"
  ls -la "$search_path" | head -5
  
  # Get a list of files that will be processed
  echo "Finding files matching pattern: $pattern in $search_path"
  # Use 2>/dev/null to suppress permission errors
  local matching_files=$(find "$search_path" $max_depth $file_type -name "$pattern" 2>/dev/null)
  
  if [[ -z "$matching_files" ]]; then
    echo "No files found matching pattern: $pattern in $search_path"
    # Try a more direct approach to see if the file exists
    echo "DEBUG: Checking for files with ls:"
    
    # Fix the path pattern to avoid double slashes
    local search_pattern
    if [[ "$search_path" == */ ]]; then
      # If path ends with slash, don't add another one
      search_pattern="${search_path}${pattern#\*}"
    else
      # Otherwise add a slash between path and pattern
      search_pattern="${search_path}/${pattern#\*}"
    fi
    
    # Try to list matching files
    local ls_files=$(ls -la "$search_pattern" 2>/dev/null)
    
    if [[ -n "$ls_files" ]]; then
      echo "$ls_files"
      echo "Files found with ls, proceeding with command execution..."
      # Execute the command using the find command we constructed earlier
      eval "$find_cmd"
    else
      # If ls with pattern fails, try a direct find command as a last resort
      echo "Trying direct find command as fallback..."
      
      # Run a test find command first to see if any files match
      local test_files=$(find "$search_path" $max_depth $file_type -name "$pattern" 2>/dev/null)
      
      if [[ -n "$test_files" ]]; then
        echo "Found files with direct find command:"
        echo "$test_files" | head -10  # Show first 10 files
        if [[ $(echo "$test_files" | wc -l) -gt 10 ]]; then
          echo "... and more ($(echo "$test_files" | wc -l | tr -d ' ') files total)"
        fi
        
        echo "Executing command on found files..."
        if [[ ${#post_shift_args[@]} -gt 0 ]]; then
          find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} "${post_shift_args[@]}" \; 2>/dev/null
        else
          find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} \; 2>/dev/null
        fi
        echo "Command execution completed."
      else
        echo "No files found with fallback methods either"
      fi
    fi
    return 0
  fi
  
  # Count the number of files
  local file_count=$(echo "$matching_files" | wc -l | tr -d ' ')
  echo "Found $file_count file(s) to process:"
  echo "$matching_files" | sed 's/^/  /'
  
  # Execute the command
  if [[ ${#post_shift_args[@]} -gt 0 ]]; then
    echo "Executing: $command ${pre_shift_args[*]} [FILES] ${post_shift_args[*]}"
    find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} "${post_shift_args[@]}" \; 2>/dev/null
  else
    echo "Executing: $command ${pre_shift_args[*]} [FILES]"
    find "$search_path" $max_depth $file_type -name "$pattern" -exec $command "${pre_shift_args[@]}" {} \; 2>/dev/null
  fi
  
  echo "Command execution completed on $file_count file(s)."
}

# Nano Editor settings
alias nanozsh='nano ~/.zshrc'     # Open the bashrc file in nano
alias reset='reset_file'          # Custom function to erase a file content then open with nano

# Nano Functions
reset_file(){
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
  # Reset the file content to an empty string
  # use the backup function to create a backup of the file before erasing
  #handle one or multiple files
  # catch escapes and errors to handle prompting user to restore backup or delete
  for file in "$@"; do
    backup "$file"
    echo "" > "$file"
    echo "File content backed up and erased."
    echo "Opening $file in nano editor"
    #echo >> the filename to the file with a # at the beginning
    echo "# $file" >> "$file"
    #sleep half a second
    sleep 0.5
    nano "$file"
    # prompt user to restore backup or delete
    ls $file$backup_name
    # default to no
    see_diff="n"
    echo -n "Do you want to see the difference between the original and backup file? (y/n):(default:n) "
    read see_diff
    if [ "$see_diff" == "y" ]; then
      diff "$file" "$file$backup_name"
      restore_backup="n"
      echo -n "Do you want to restore the backup file? (y/n):(default:n) "
      read restore_backup
      if [ "$restore_backup" == "y" ]; then
          mv "$file$backup_name" "$file"
          echo "Backup file restored."
      fi
    fi
  done
}

# Docker Aliases
alias dc="docker compose"
alias docker-compose="dc" # alias for docker compose instead of docker-compose
alias dcu="dc pull && dc up -d" # pull and start the docker compose services
alias dcd="dc down" # stop the docker compose services
alias dcb="dcu --build" # build the docker compose services
alias dcp="dc pull" # pull the docker compose services
alias dcr="dcd && dcu" # stop and start the docker compose services
#purge docker compose services networks and volumes 
alias dcnet="docker network prune"
alias dcvol="docker volume prune"
alias dcpur="dcd && dcp && dcnet && dcvol" # stop and pull the docker compose services
alias d="docker" # alias for docker
alias dps="d ps"
alias dbash="d exec -it $1 /bin/bash"
alias dsh="d exec -it $1 /bin/sh"


# Networking shortcuts
alias ports='netstat -tulanp'  # List open ports
alias myip='curl ifconfig.me'  # Check external IP address

# Disk usage shortcuts
alias du='du -h --max-depth=1'  # Show disk usage in human-readable format
alias df='df -h'                # Show free disk space in human-readable format


# Menu with all functions in ~/.zsh_aliases and ~/.mac_functions.sh

show_func(){
    # usage: show_help function_name
    # show the help for a specific function
    cat ~/.zsh_aliases|grep "$1()"
}
alias show_function="show_func"
show_alias(){
    # usage: show_alias
    # show all the aliases in the ~/.zsh_aliases file
    cat ~/.zsh_aliases | grep -E "^alias " | cut -d '=' -f 1 | sort | uniq
}

show_help(){
    # usage: show_help function_name
    # show the help for a specific function
    grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" ~/.zsh_aliases
}

helpmenu(){
    echo "Help Menu:"
    echo "----------"
    echo "See all functions: show_function"
    echo "See all aliases: show_alias"
    echo "See help for a function: show_help function_name"
    echo "See help for an alias: show_help alias_name"
}

# ----------------------
# GitHub Repository Management
# ----------------------

create_repo(){
    # "Usage: create_repo repo_name"
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: create_repo repo_name"
        return 0
    fi
    
    if ! command -v gh &> /dev/null; then
        echo "Error: GitHub CLI 'gh' is not installed."
        install_gh="y"
        echo -n "Do you want to install GitHub CLI? (y/n):(default:y) "
        read install_gh
        if [[ $install_gh =~ ^[Yy]$ ]]; then
            brew install gh
            echo "GitHub CLI installed, continuing with repo creation"
        else
            echo "GitHub CLI not installed, you can install it with 'brew install gh' before running this function again"
            return 1
        fi
    fi

    repo_name=$(echo "$@" | tr ' ' '_')
    local base_dir="$HOME/Documents/Git"
    mkdir -p "$base_dir"

    use_gitignore="n"
    echo -n "Do you want to use a special .gitignore file? (y/n):(default:n) "
    read use_gitignore

    if [[ $use_gitignore =~ ^[Yy]$ ]]; then
        echo "Available gitignore templates:"
        echo "1) Python"
        echo "2) Node/JavaScript"
        echo "3) Markdown"
        echo "4) Shell"
        echo "5) None (basic repo setup)"
        
        echo -n "Select a template (1-5): "
        read template_choice

        case $template_choice in
            1)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Python || return 1
                ;;
            2)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Node || return 1
                ;;
            3)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Markdown || return 1
                ;;
            4)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Shell || return 1
                ;;
            *)
                gh repo create --add-readme "$repo_name" --private --license=mit || return 1
                ;;
        esac
    else
        gh repo create --add-readme "$repo_name" --private --license=mit || return 1
    fi

    git clone "https://github.com/$(gh api user | jq -r '.login')/$repo_name.git" "$base_dir/$repo_name" || return 1
    cd "$base_dir/$repo_name" || return 1
    echo "# $repo_name" >> README.md
    git add README.md
    git commit -m "Initial commit"
    git branch -M main
    git push -u origin main

    echo "Repository $repo_name created and initialized successfully in $base_dir."
}

# ----------------------
# Python Virtual Environment Management
# ----------------------
# Python Aliases 
pyenv(){
  python3 -m venv env  # Create the virtual environment
  source env/bin/activate  # Activate the virtual environment (on Linux/Mac)
  pip install --upgrade pip  # Upgrade pip
  pip install -r requirements.txt  # Install dependencies
}

# Python Aliases 
pyserver(){
    # usage: pyserver file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver file1 file2 ..."
        return 0
    fi
    # check if python3 is installed
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed"
        echo "You can install it with:"
        echo 'brew install python'
        return 1
    fi
    # set port for the python server
    local port=8000
    # create a python server for the passed files or dir
    #get local ip
    local_ip=$(hostname -I | awk '{print $1}')
    # path for the server else use current dir
    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    # if no files passed in arg then use current dir
    if [ -n "$1" ]; then # if there are files passed in arg
        # create temp dir
        mkdir -p /tmp/pyserver
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/pyserver
        done
        # change dir to the temp dir
        cd /tmp/pyserver
        # start the python server
        python3 -m http.server $port
    else
        # use current dir
        cd .
        # start the python server
        python3 -m http.server $port
    fi
    
}

funnel() {
    # usage: funnel file1 file2 dir1 dir2 ...
    # On MacOS you must be using the open source tailscaled distribution to use the funnel command for files. 
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: funnel <target>"
        echo "Funnel enables you to share a local server on the internet using Tailscale."
        return 0
    fi
    
    # Default port and allow override with FUNNEL_PORT env variable
    local port=${FUNNEL_PORT:-8080}
    use_python=true #use this with MacOS or as needed

    # Check if tailscale is running
    if ! tailscale status &> /dev/null; then
        echo "Tailscale is not running. Attempting to start it with 'tailscale up'..."
        tailscale up
        
        # Check again if tailscale is running after attempting to start it
        if ! tailscale status &> /dev/null; then
            echo "Error: Failed to start Tailscale. Please start it manually."
        return 1
        fi
        echo "Tailscale started successfully. Continuing..."
    fi

    # Use current directory if no target is specified
    if [ -z "$1" ]; then
        echo "No target specified. Using current directory as target."
        target="."
    else
        target="$@"
    fi

    # Kill any existing Python HTTP servers on our port
    local existing_pid=$(lsof -ti:$port)
    if [[ -n "$existing_pid" ]]; then
        echo "Killing existing process on port $port (PID: $existing_pid)"
        kill -9 $existing_pid 2>/dev/null
        sleep 1
    fi

    # Function to clean up background processes
    cleanup() {
        echo "Cleaning up..."
        # Find and kill the Python HTTP server process
        if [[ -n "$server_pid" ]]; then
            echo "Killing server process (PID: $server_pid)"
            kill -9 $server_pid 2>/dev/null
            wait $server_pid 2>/dev/null
        fi
        
        # Also try to find any process using our port
        local port_pid=$(lsof -ti:$port)
        if [[ -n "$port_pid" ]]; then
            echo "Killing process on port $port (PID: $port_pid)"
            kill -9 $port_pid 2>/dev/null
        fi
        
        # Clean up temp directory
        if [[ -d "/tmp/funnel" ]]; then
            echo "Removing temporary directory"
            rm -rf /tmp/funnel
        fi
        
        # Return to original directory
        if [[ -n "$original_dir" ]]; then
            cd "$original_dir"
        fi
        
        return 0
    }

    # Save original directory
    original_dir=$(pwd)

    # Trap SIGINT (Ctrl+C) to run cleanup
    trap cleanup INT TERM EXIT

    # if files are passed as arguments
    if [ -n "$1" ]; then
        # Clean up any existing temp directory
        if [[ -d "/tmp/funnel" ]]; then
            rm -rf /tmp/funnel
        fi
        
        # Create temp dir
        mkdir -p /tmp/funnel
        
        # Copy (not link) the files to the temp dir
        for file in "$@"; do
            # Use absolute paths for files
            local abs_path
            if [[ "$file" = /* ]]; then
                abs_path="$file"
            else
                abs_path="$original_dir/$file"
            fi
            
            echo "Checking path: $abs_path"
            
            if [[ -f "$abs_path" ]]; then
                cp "$abs_path" "/tmp/funnel/"
                echo "Copied file: $abs_path"
            elif [[ -d "$abs_path" ]]; then
                # For directories, copy the entire directory structure
                cp -r "$abs_path" "/tmp/funnel/"
                echo "Copied directory: $abs_path"
            else
                echo "Warning: $abs_path does not exist, skipping"
            fi
        done
        
        # Change dir to the temp dir
        cd /tmp/funnel
        
        # List the contents to verify
        echo "Files available for sharing:"
        ls -la
        
        if $use_python; then
            # Start the python server
            python3 -m http.server $port &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:$port >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel localhost:$port
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    else
        # Use current dir
        cd .
        if $use_python; then
            # Start the python server
            python3 -m http.server $port &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:$port >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel localhost:$port
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    fi
}

alias tsf=funnel
alias postfile=funnel


# ----------------------
# MAC Address Management
# ----------------------

gen_mac_addr(){
    local mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

change_mac_menu(){
    echo "Choose an option:"
    echo "1. Set a specific MAC address"
    echo "2. Set a random MAC address"
    echo "3. Restore original MAC address"
    echo -n "Enter your choice (1/2/3): "
    read choice

    case $choice in
        1)
            echo -n "Enter the new MAC address (e.g., E6:B8:BA:D2:41:07): "
            read mac_address
            echo -n "Enter the name of the new network location: "
            read location_name
            change_mac_address "$mac_address" "$location_name"
            ;;
        2)
            echo -n "Enter the name of the new network location: "
            read location_name
            mac_address=$(gen_mac_addr)
            change_mac_address "$mac_address" "$location_name"
            ;;
        3)
            restore_original_mac
            ;;
        *)
            echo "Invalid choice. Exiting."
            ;;
    esac
}

# ----------------------
# Matrix Setup
# ----------------------

matrix_setup(){
    # for a list of tags see https://github.com/spantaleev/matrix-docker-ansible-deploy/blob/a1efb78bcbc3a9205a59de3364f47192b6232f0f/docs/playbook-tags.md#L4
    ## Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        # show help
        echo "Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}"
        return 0
    fi

    if ! command -v ansible-playbook &> /dev/null; then
        # show error
        echo "Error: 'ansible-playbook' is not installed."
        return 1
    fi
    # set mode to normal if no mode is passed
    local mode="${1:-normal}"
    # set vars file to the default path if no path is passed $HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com
    local vars_file="${2:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com/vars.yml}"
    # Fix: Go up three directories from vars file to reach inventory directory
    local hosts_file="$(dirname "$(dirname "$(dirname "$vars_file")")")/hosts"
    #set the setup.yml file to the directory above the inventory directory
    local setup_file="${hosts_file%/*/*}/setup.yml"
    # set the matrix repo path to the directory above the inventory directory
    local matrix_repo_path="${hosts_file%/*}/.."
    # check if vars file exists
    if [[ ! -f "$vars_file" ]]; then
        echo "Error: Vars file not found at $vars_file"
        return 1
    fi
    # check if hosts file exists
    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the case statement
    case "$mode" in
        full|1)
            # full will update the repo and make roles then setup and start the services using all the tags
            # git pull && sudo make roles of the matrix repo without moving to the repo dir
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=install-all,setup-all,ensure-matrix-users-created,restart || return 1
            cd - # return to the previous directory
            ;;
        normal)
            # normal will update the repo and make roles then setup and start the services
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=setup-all,start || return 1
            cd - # return to the previous directory
            ;;
        restart)
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=restart || return 1
            cd - # return to the previous directory
            ;;
        *)
            echo "Usage: matrix_setup {full|1|normal|restart} [hosts_file_path]"
            return 1
            ;;
    esac
}

# ----------------------
# Matrix User Setup
# ----------------------

matrix_setup_user(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: matrix_setup_user username [password] [admin] [device_id] [hosts_file_path]"
        return 0
    fi

    if ! command -v curl &> /dev/null || ! command -v ansible-playbook &> /dev/null; then
        echo "Error: Required commands 'curl' or 'ansible-playbook' are not installed."
        return 1
    fi

    local username="$1"
    local password="${2:-$(openssl rand -base64 18)}"
    local admin="${3:-no}"
    local device_id="${4:-${username}_$(openssl rand -hex 3)}"
    local hosts_file="${5:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/hosts}"

    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the ansible playbook to register the user
    sudo ansible-playbook -i "$hosts_file" setup.yml \
        --extra-vars="username=${username} password='${password}' admin=${admin}" \
        --tags=register-user
    # login to the matrix server and obtain the access token
    curl -XPOST -d "{
        \"identifier\": { \"type\": \"m.id.user\", \"user\": \"${username}\" },
        \"password\": \"${password}\",
        \"type\": \"m.login.password\",
        \"device_id\": \"${device_id}\"
    }" 'https://matrix.irregularchat.com/_matrix/client/r0/login'
}

# ----------------------
# Cryptography
# ----------------------
setup_age(){
    # setup age directory and keys
    mkdir -p ~/.age
    #get username
    username=$(whoami)
    #if no argument passed for key name then use username
    if [[ -z "$1" ]]; then
        key_name="$username"
    else
        key_name="$1"
    fi
    
    #echo guidance on storying and using the age keys
    echo "Store the following keys in a secure location:"
    echo "Public key: ~/.age/keys/$key_name.pub"
    echo "Private key: ~/.age/keys/$key_name.key"
    echo "You will see a public key output to the screen that you can share with others"
    echo "For more information on age see https://github.com/FiloSottile/age"
    sleep 1
    # generate keys
    age-keygen -a -o ~/.age/keys/$key_name.key
    ls -l ~/.age/keys
}


# ----------------------
# OCR
# ----------------------
ocr_files(){
    # Display help if requested
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: ocr_files file1 file2 dir1 dir2 ..."
        echo "Processes PDF files to add OCR text layer."
        #examples of single, directory, and multiple files
        echo "Examples:"
        echo "ocr_files file1.pdf"
        echo "ocr_files dir1/ dir2/"
        echo "ocr_files file1.pdf file2.pdf dir1/ dir2/"
        return 0
    fi

    # Check if any arguments were provided
    if [[ $# -eq 0 ]]; then
        echo "Error: No files or directories specified."
        echo "Usage: ocr_files file1 file2 dir1 dir2 ..."
        return 1
    fi

    # Check if ocrmypdf is installed
    if ! command -v ocrmypdf &> /dev/null; then
        echo "Error: 'ocrmypdf' is not installed."
        echo "You can install it with: brew install ocrmypdf"
        return 1
    fi

    # Check if tesseract is installed
    if ! command -v tesseract &> /dev/null; then
        echo "Error: 'tesseract' is not installed."
        echo "You can install it with: brew install tesseract"
        return 1
    fi

    # Process a single PDF file
    process_pdf_file() {
        local input_file="$1"
        local output_file="${input_file%.*}-ocr.pdf"
        
        echo "Processing: $input_file"
        
        # Run ocrmypdf in a subshell to prevent terminal breakage
        (
            set +e
            ocrmypdf --skip-text "$input_file" "$output_file"
            if [[ $? -ne 0 ]]; then 
                echo "Failed to process $input_file"
            else
                echo "Successfully processed $input_file to $output_file"
            fi
        )
    }

    # Process a directory
    process_directory() {
        local dir="$1"
        echo "Processing directory: $dir"
        
        # Find PDF files (case insensitive)
        local pdf_files=()
        while IFS= read -r -d '' file; do
            pdf_files+=("$file")
        done < <(find "$dir" -type f -iname "*.pdf" -print0 2>/dev/null)
        
        # Check if any PDF files were found
        if [[ ${#pdf_files[@]} -eq 0 ]]; then
            echo "No PDF files found in directory: $dir"
            return
        fi
        
        # Process each PDF file
        for file in "${pdf_files[@]}"; do
            process_pdf_file "$file"
        done
    }

    # Process each argument
    for item in "$@"; do
        # Check if item exists
        if [[ ! -e "$item" ]]; then
            echo "Error: '$item' does not exist"
            continue
        fi
        
        # Check if it's a directory
        if [[ -d "$item" ]]; then
            process_directory "$item"
        # Check if it's a PDF file (case insensitive)
        elif [[ -f "$item" && $(echo "$item" | tr '[:upper:]' '[:lower:]') == *".pdf" ]]; then
            process_pdf_file "$item"
        else
            echo "Skipping $item: Not a PDF file or directory."
        fi
    done
    
    return 0
}
# ----------------------
# File Cleanup
# ----------------------
clean_file(){
    # Check if a file path is provided
    if [[ -z "$1" ]]; then
        echo "Error: No file path provided."
        return 1
    fi

    # Use the provided file path
    local path="$1"
    # get full path
    local full_path=$(realpath "$path")

    # Remove spaces and special characters from the file name
    local clean_file=$(echo "$full_path" | tr -cd '[:alnum:]_.-')

    # Move the file to the new name
    mv "$full_path" "$clean_file"

    # Return the cleaned file name with full path
    echo "$clean_file"
}

encrypt_file(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: encrypt_file [-m method] [-r recipient] file1 file2 ..."
        echo "Options:"
        echo "  -m method       Encryption method: age (default), gpg, or aes"
        echo "  -r recipient    Use recipient's public key instead of passphrase (only for age)"
        echo "  -e, --encrypt   Optional flag (for consistency with other functions)"
        return 0
    fi

    # Check if encryption tools are installed
    local has_age=false
    local has_gpg=false
    local has_openssl=false
    
    if command -v age &> /dev/null; then
        has_age=true
    fi
    if command -v gpg &> /dev/null; then
        has_gpg=true
    fi
    if command -v openssl &> /dev/null; then
        has_openssl=true
    fi
    
    # If no encryption tools are available, prompt to install age
    if ! $has_age && ! $has_gpg && ! $has_openssl; then
        echo "Error: No encryption tools found (age, gpg, or openssl)."
        echo -n "Do you want to install 'age'? (y/n):(default:y) "
        read install_age
        if [[ $install_age =~ ^[Yy]$ || -z "$install_age" ]]; then
            brew install age
            has_age=true
        else
            return 1
        fi
    fi

    # Initialize variables
    local recipient=""
    local use_passphrase=true
    local encrypt_method="age"  # Default encryption method
    local zip_file=""
    local password=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--encrypt)
                # Just a flag for consistency with other functions
                shift
                ;;
            -m)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -m requires a method argument (age, gpg, or aes)"
                    return 1
                fi
                encrypt_method="$2"
                shift 2
                ;;
            -r)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -r requires a recipient argument"
                    return 1
                fi
                recipient="$2"
                use_passphrase=false
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                echo "Usage: encrypt_file [-m method] [-r recipient] file1 file2 ..."
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    # Validate encryption method
    case "$encrypt_method" in
        age)
            if ! $has_age; then
                echo "Error: 'age' is not installed but specified as encryption method."
                return 1
            fi
            ;;
        gpg)
            if ! $has_gpg; then
                echo "Error: 'gpg' is not installed but specified as encryption method."
                return 1
            fi
            ;;
        aes)
            if ! $has_openssl; then
                echo "Error: 'openssl' is not installed but specified as encryption method."
                return 1
            fi
            ;;
        *)
            echo "Error: Invalid encryption method '$encrypt_method'. Use age, gpg, or aes."
            return 1
            ;;
    esac

    # Check if files are provided
    if [[ "$#" -eq 0 ]]; then
        echo "Error: No files provided for encryption."
        return 1
    fi

    # If multiple files are passed, zip them and encrypt the zip file
    local files_to_encrypt
    if [[ "$#" -gt 1 ]]; then
        # zip the files
        zip_file="./$(basename "$1")_encrypted_$(date +%Y%m%d%H%M%S).zip"
        echo "Creating zip file with multiple files..."
        zip -q "$zip_file" "$@"
        files_to_encrypt="$zip_file"
    else
        # if only one file is passed then set the file to encrypt
        files_to_encrypt="$1"
    fi

    # Encrypt the file(s) based on the selected method
    local encrypted_file
    case "$encrypt_method" in
        age)
            encrypted_file="${files_to_encrypt}.age"
            echo "Encrypting with age..."
            
            if $use_passphrase; then
                # Capture the passphrase from age output
                echo "Using passphrase encryption..."
                local age_output=$(age -p -o "$encrypted_file" "$files_to_encrypt" 2>&1)
                # Extract the passphrase from the output
                password=$(echo "$age_output" | grep -o 'passphrase: "[^"]*"' | cut -d '"' -f 2)
                if [[ -z "$password" ]]; then
                    # Try alternate format
                    password=$(echo "$age_output" | grep -o 'passphrase "[^"]*"' | cut -d '"' -f 2)
                fi
                
                if [[ -n "$password" ]]; then
                    echo "Generated passphrase: $password"
                    echo "Save this passphrase securely - you'll need it to decrypt the file."
                fi
            else
                echo "Using recipient key encryption..."
                age -r "$recipient" -o "$encrypted_file" "$files_to_encrypt"
        echo "Recipient key used for encryption: $recipient"
    fi
            ;;
            
        gpg)
            encrypted_file="${files_to_encrypt}.gpg"
            echo "Encrypting with GPG..."
            echo "You will be prompted to enter a passphrase for encryption."
            gpg --output "$encrypted_file" --symmetric "$files_to_encrypt"
            echo "File encrypted with GPG. Remember your passphrase for decryption."
            ;;
            
        aes)
            encrypted_file="${files_to_encrypt}.aes"
            echo "Encrypting with OpenSSL AES-256-CBC..."
            echo "You will be prompted to enter a passphrase for encryption."
            openssl enc -aes-256-cbc -salt -in "$files_to_encrypt" -out "$encrypted_file"
            echo "File encrypted with AES-256. Remember your passphrase for decryption."
            ;;
    esac

    # Verify the encrypted file was created
    if [[ ! -f "$encrypted_file" ]]; then
        echo "Error: Encryption failed. Encrypted file not created."
    # Clean up zip file if it was created
        [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
        return 1
    fi

    # Clean up zip file if it was created
    if [[ -n "$zip_file" && -f "$zip_file" ]]; then
        rm -f "$zip_file"
    fi

    # Instructions for decryption
    echo "Encrypted file created: $encrypted_file"
    echo ""
    echo "To decrypt the file:"
    
    case "$encrypt_method" in
        age)
            if $use_passphrase; then
                echo "age --decrypt --output ${encrypted_file%.age} $encrypted_file"
                echo "You will be prompted for the passphrase shown above."
            else
                echo "age --decrypt --identity ~/.age/keys/your_private_key.key --output ${encrypted_file%.age} $encrypted_file"
            fi
            ;;
            
        gpg)
            echo "gpg --output ${encrypted_file%.gpg} --decrypt $encrypted_file"
            echo "You will be prompted for the passphrase you entered during encryption."
            ;;
            
        aes)
            echo "openssl enc -d -aes-256-cbc -in $encrypted_file -out ${encrypted_file%.aes}"
            echo "You will be prompted for the passphrase you entered during encryption."
            ;;
    esac
    
    echo ""
    echo "File successfully encrypted: $encrypted_file"
    return 0
}

generate_password(){
    # Generate a random password
    # Default password type is phrases using diceware
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: generate_password [-p type] [-l length] [-m] [-c] [-s] [-q] [-n]"
        echo "Options:"
        echo "  -p type       Password type: phrases (default), chars (random characters), numbers, or hex"
        echo "  -l length     Length of the password (default: 6 words for phrases, 22 chars for others)"
        echo "  -m            Manual mode - prompt for password instead of generating"
        echo "  -c            Copy the generated password to clipboard"
        echo "  -s            Include special characters (for chars type only)"
        echo "  -q            Quiet mode - only output the password (useful for scripting)"
        echo "  -n            No spaces in passphrase (for phrases type only)"
        return 0
    fi
    
    # Check if diceware is installed for phrase passwords
    local has_diceware=false
    if command -v diceware &> /dev/null; then
        has_diceware=true
    fi
    
    local password_type="phrases"
    local length=6  # Default 6 words for phrases
    local char_length=22  # Default 22 chars for character passwords
    local manual_mode=false
    local copy_to_clipboard=false
    local include_special=false
    local quiet_mode=false
    local no_spaces=false
    local password=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -p requires a type argument (phrases, chars, numbers, hex)" >&2
                    return 1
                fi
                password_type="$2"
                shift 2
                ;;
            -l)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -l requires a length argument" >&2
                    return 1
                fi
                if [[ ! "$2" =~ ^[0-9]+$ ]]; then
                    echo "Error: Length must be a number" >&2
                    return 1
                fi
                if [[ "$password_type" == "phrases" ]]; then
                    length="$2"
                else
                    char_length="$2"
                fi
                shift 2
                ;;
            -m)
                manual_mode=true
                shift
                ;;
            -c)
                copy_to_clipboard=true
                shift
                ;;
            -s)
                include_special=true
                shift
                ;;
            -q)
                quiet_mode=true
                shift
                ;;
            -n)
                no_spaces=true
                shift
                ;;
            *)
                if ! $quiet_mode; then
                    echo "Unknown option: $1" >&2
                    echo "Use 'generate_password -h' for help." >&2
                fi
                return 1
                ;;
        esac
    done
    
    # If manual mode, prompt for password
    if $manual_mode; then
        if ! $quiet_mode; then
            echo "Enter your password (input will be hidden):" >&2
        fi
        read -s password
        if ! $quiet_mode; then
            echo "Confirm password:" >&2
        fi
        read -s password_confirm
        
        if [[ "$password" != "$password_confirm" ]]; then
            if ! $quiet_mode; then
                echo "Error: Passwords do not match." >&2
            fi
            return 1
        fi
        
        if ! $quiet_mode; then
            echo "Password set manually." >&2
        fi
    else
        # Generate password based on type
        case "$password_type" in
            phrases)
                if ! $has_diceware; then
                    if ! $quiet_mode; then
                        echo "Error: 'diceware' is not installed but required for phrase passwords." >&2
                        echo "You can install it with: brew install diceware" >&2
                        echo -n "Do you want to install diceware now? (y/n): " >&2
                    fi
                    read install_diceware
                    if [[ "$install_diceware" =~ ^[Yy]$ ]]; then
                        brew install diceware
                        has_diceware=true
                    else
                        if ! $quiet_mode; then
                            echo "Falling back to character-based password." >&2
                        fi
                        password_type="chars"
                    fi
                fi
                
                if $has_diceware; then
                    # Use diceware to generate a phrase password
                    password=$(diceware -n "$length" -c -s 2)
                    
                    # Remove spaces if requested
                    if $no_spaces; then
                        password=$(echo "$password" | tr -d ' ')
                    fi
                    
                    if ! $quiet_mode; then
                        echo "Generated passphrase: $password" >&2
                    fi
                else
                    # Fallback if diceware installation failed
                    password=$(openssl rand -base64 $(($char_length * 2)) | tr -d '/+=' | cut -c1-"$char_length")
                    if ! $quiet_mode; then
                        echo "Generated password: $password" >&2
                    fi
                fi
                ;;
                
            chars)
                # Generate a random character password with letters, numbers, and symbols
                if $include_special; then
                    # Include more special characters
                    password=$(LC_ALL=C tr -dc 'a-zA-Z0-9!@#$%^&*()_+=-' < /dev/urandom | head -c "$char_length")
                    
                    # Ensure at least one of each character type for better password strength
                    if [[ ${#password} -ge 4 ]]; then
                        # Get one of each type
                        local lower=$(LC_ALL=C tr -dc 'a-z' < /dev/urandom | head -c 1)
                        local upper=$(LC_ALL=C tr -dc 'A-Z' < /dev/urandom | head -c 1)
                        local number=$(LC_ALL=C tr -dc '0-9' < /dev/urandom | head -c 1)
                        local special=$(LC_ALL=C tr -dc '!@#$%^&*()_+=-' < /dev/urandom | head -c 1)
                        
                        # Replace first 4 characters with our guaranteed types
                        password="${lower}${upper}${number}${special}${password:4}"
                        
                        # Shuffle the password to avoid predictable pattern
                        password=$(echo "$password" | fold -w1 | shuf | tr -d '\n' | head -c "$char_length")
                    fi
                else
                    # Standard character set
                    password=$(LC_ALL=C tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c "$char_length")
                    
                    # Ensure at least one lowercase, one uppercase, and one number
                    if [[ ${#password} -ge 3 ]]; then
                        local lower=$(LC_ALL=C tr -dc 'a-z' < /dev/urandom | head -c 1)
                        local upper=$(LC_ALL=C tr -dc 'A-Z' < /dev/urandom | head -c 1)
                        local number=$(LC_ALL=C tr -dc '0-9' < /dev/urandom | head -c 1)
                        
                        password="${lower}${upper}${number}${password:3}"
                        password=$(echo "$password" | fold -w1 | shuf | tr -d '\n' | head -c "$char_length")
                    fi
                fi
                
                if ! $quiet_mode; then
                    echo "Generated password: $password" >&2
                fi
                ;;
                
            numbers)
                # Generate a random numeric password
                password=$(LC_ALL=C tr -dc '0-9' < /dev/urandom | head -c "$char_length")
                if ! $quiet_mode; then
                    echo "Generated numeric password: $password" >&2
                fi
                ;;
                
            hex)
                # Generate a random hexadecimal password
                password=$(LC_ALL=C tr -dc 'a-f0-9' < /dev/urandom | head -c "$char_length")
                if ! $quiet_mode; then
                    echo "Generated hex password: $password" >&2
                fi
                ;;
                
            *)
                if ! $quiet_mode; then
                    echo "Error: Invalid password type '$password_type'. Use phrases, chars, numbers, or hex." >&2
                fi
                return 1
                ;;
        esac
    fi
    
    # Copy to clipboard if requested
    if $copy_to_clipboard && [[ -n "$password" ]]; then
        if command -v pbcopy &> /dev/null; then
            echo -n "$password" | pbcopy
            if ! $quiet_mode; then
                echo "Password copied to clipboard." >&2
            fi
        elif command -v xclip &> /dev/null; then
            echo -n "$password" | xclip -selection clipboard
            if ! $quiet_mode; then
                echo "Password copied to clipboard." >&2
            fi
        elif command -v wl-copy &> /dev/null; then
            # Support for Wayland
            echo -n "$password" | wl-copy
            if ! $quiet_mode; then
                echo "Password copied to clipboard." >&2
            fi
        else
            if ! $quiet_mode; then
                echo "Warning: Could not copy to clipboard. No supported clipboard utility found." >&2
            fi
        fi
    fi
    
    if ! $quiet_mode; then
        echo "Save this password securely!" >&2
    fi
    
    # Return the password as the function result
    echo "$password"
}

# ----------------------
# File Transfer
# ----------------------


#wormhole alias
alias wh="wormhole"
alias wht="wh-transfer"
#transfer file with wormhole many or one file
wh-transfer(){
    trap '[[ -f "$zip_file" ]] && rm -rf "$zip_file"' EXIT

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: wh-transfer [-e|--encrypt] path1 path2 ..."
        echo "The default is to send the files as is"
        echo "-e or --encrypt will encrypt the files before sending using age, gpg, or aes"
        return 0
    fi

    encrypt_and_send() {
        local encrypt_tool="$1"
        shift
        local files=("$@")
        local zip_file="./wormhole_$(date +%Y%m%d%H%M%S).zip"
        zip "$zip_file" "${files[@]}"
        
        local encrypted_file="${zip_file}.age"
        if [[ "$encrypt_tool" == "gpg" ]]; then
            encrypted_file="${zip_file}.gpg"
            gpg --output "$encrypted_file" --symmetric "$zip_file"
        elif [[ "$encrypt_tool" == "aes" ]]; then
            encrypted_file="${zip_file}.aes"
            openssl enc -aes-256-cbc -salt -in "$zip_file" -out "$encrypted_file"
        else
            age -o "$encrypted_file" -p "$zip_file"
        fi

        wormhole send "$encrypted_file"
        rm -rf "$zip_file" "$encrypted_file"
    }

    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        shift
        if command -v age &> /dev/null; then
            encrypt_and_send "age" "$@"
        elif command -v gpg &> /dev/null; then
            encrypt_and_send "gpg" "$@"
        else
            encrypt_and_send "aes" "$@"
        fi
    else
        if [[ "$#" -gt 1 ]]; then
            local zip_file="./wormhole_$(date +%Y%m%d%H%M%S).zip"
            zip "$zip_file" "$@"
            wormhole send "$zip_file"
            rm -rf "$zip_file"
        else
            wormhole send "$@"
        fi
    fi
}

upload_to_pcloud(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: upload_to_pcloud [-e|-encrypt] source_path [remote_path]"
        echo "Uploads files or directories to pCloud using rclone."
        echo "Options:"
        echo "  -e, --encrypt   Encrypt the file(s) before uploading using 'age'."
        echo "If remote_path is not provided, files will be uploaded to the root of the remote."
        return 0
    fi

    # Default remote name for pCloud
    local remote="pcloud"
    # Check for encryption option
    local encrypt=false
    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        encrypt=true
        shift
    fi

    # Check for source_path
    if [[ -z "$1" ]]; then
        echo "Error: Source path is required."
        echo "Use 'upload_to_pcloud -h' for help."
        return 1
    fi
    local source_path="$1"
    shift

    # Set the remote path or use the root of the remote
    local remote_path="$1"
    if [[ -z "$remote_path" ]]; then
        remote_path="/"
    fi

    # Debug: Print paths
    echo "Source path: $source_path"
    echo "Remote path: $remote_path"

    # Check if the source path exists
    if [[ ! -e "$source_path" ]]; then
        echo "Error: Source path '$source_path' does not exist."
        return 1
    fi

    # Encrypt the file if requested
    if [[ "$encrypt" == true ]]; then
        echo "Encrypting file..."
        encrypt_file "$source_path"
        local encrypted_path="${source_path}.age"
        echo "Uploading encrypted file to pCloud..."
        rclone copy "$encrypted_path" "$remote:$remote_path" -P || {
            echo "Error: Failed to upload encrypted file to pCloud."
            return 1
        }
        rm "$encrypted_path" # Clean up encrypted file
    else
        # Upload directly
        echo "Uploading '$source_path' to pCloud..."
        rclone copy "$source_path" "$remote:$remote_path" -P || {
            echo "Error: Failed to upload to pCloud."
            return 1
        }
    fi

    echo "Upload to pCloud completed successfully!"
}

# ffsend file transfer including encryption option
fsend(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: fsend [-e|--encrypt] [-m method] [-r recipient] [-p password] [-g] path1 path2 ..."
        echo "Options:"
        echo "  -e, --encrypt    Encrypt the file(s) before sending"
        echo "  -m method        Encryption method: age (default), gpg, or aes"
        echo "  -r recipient     Use recipient's public key instead of passphrase (only for age)"
        echo "  -p password      Specify a password (for gpg and aes methods)"
        echo "  -g               Auto-generate password without prompting"
        return 0
    fi

    # Check if ffsend is installed
    if ! command -v ffsend &> /dev/null; then
        echo "Error: 'ffsend' is not installed."
        echo "You can install it with: brew install ffsend"
        return 1
    fi

    # Define variables at the top level
    local zip_file=""
    local encrypt_method="age"  # Default encryption method
    local password=""
    local link=""
    local encrypt=false
    local recipient=""
    local use_passphrase=true
    local user_password=""
    local auto_generate=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--encrypt)
                encrypt=true
                shift
                ;;
            -m)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -m requires a method argument (age, gpg, or aes)"
                    return 1
                fi
                encrypt_method="$2"
                shift 2
                ;;
            -r)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -r requires a recipient argument"
                    return 1
                fi
                recipient="$2"
                use_passphrase=false
                shift 2
                ;;
            -p)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -p requires a password argument"
                    return 1
                fi
                user_password="$2"
                shift 2
                ;;
            -g)
                auto_generate=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    # Check if any files were provided
    if [[ $# -eq 0 ]]; then
        echo "Error: No files specified for upload."
        echo "Usage: fsend [-e|--encrypt] [-m method] [-r recipient] path1 path2 ..."
        return 1
    fi

    # Debug: Print the arguments
    echo "Files to upload: $@"

    # Handle multiple files
    local files=("$@")
    local upload_file=""
    
    if [[ "${#files[@]}" -gt 1 ]]; then
        # Set the zip_file variable for the outer scope
        zip_file="./ffsend_$(date +%Y%m%d%H%M%S).zip"
        echo "Creating zip file with multiple files..."
        zip -q "$zip_file" "${files[@]}"
        upload_file="$zip_file"
    else
        # Single file case - use the first argument directly
        upload_file="$1"
        echo "Single file mode: $upload_file"
    fi

    # Verify the file exists before proceeding
    if [[ ! -f "$upload_file" ]]; then
        echo "Error: File '$upload_file' does not exist."
        return 1
    fi

    if $encrypt; then
        # Encryption handling
        if [[ "${#files[@]}" -eq 1 && "$zip_file" == "" ]]; then
            # For single file encryption, create a temporary zip first
            zip_file="./ffsend_$(date +%Y%m%d%H%M%S).zip"
            echo "Creating temporary zip for encryption..."
            zip -q "$zip_file" "$upload_file"
            upload_file="$zip_file"
        fi
        
        local encrypted_file=""
        
        # Handle password for all encryption methods except when using recipient key
        if [[ -z "$user_password" && "$use_passphrase" == true ]]; then
            if [[ "$encrypt_method" != "age" || "$auto_generate" == false ]]; then
                # For non-age methods or when not auto-generating, prompt for password
                if [[ "$auto_generate" == false ]]; then
                    # Prompt for password
                    echo "Enter password for encryption (leave empty to auto-generate):"
                    read -s user_password
                    
                    if [[ -n "$user_password" ]]; then
                        echo "Confirm password:"
                        read -s password_confirm
                        
                        if [[ "$user_password" != "$password_confirm" ]]; then
                            echo "Error: Passwords do not match."
                            [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
                            return 1
                        fi
                    fi
                fi
                
                # If user didn't enter a password or auto-generate is true, generate one
                if [[ -z "$user_password" || "$auto_generate" == true ]]; then
                    # Use the generate_password function instead of reimplementing
                    if [[ "$encrypt_method" == "age" ]]; then
                        user_password=$(generate_password -p phrases -l 3)
                    else
                        user_password=$(generate_password -p chars -l 12)
                    fi
                    echo "Generated password: $user_password"
                    echo "Save this password securely - you'll need it to decrypt the file."
                fi
                
                # For age encryption with manual password, we'll use this later
                if [[ "$encrypt_method" == "age" ]]; then
                    password="$user_password"
                fi
            fi
        fi
        
        # Determine encryption method and encrypt
        case "$encrypt_method" in
            age)
                encrypted_file="${upload_file}.age"
                echo "Encrypting with age..."
                
                if $use_passphrase; then
                    # Use age with passphrase
                    echo "Using passphrase encryption..."
                    
                    if [[ -n "$password" && "$auto_generate" == false ]]; then
                        # Use the manually entered password
                        echo "Using manually entered passphrase"
                        echo "$password" | age --passphrase -o "$encrypted_file" "$upload_file"
                    else
                        # Let age generate a passphrase
                        local age_output=$(age -p -o "$encrypted_file" "$upload_file" 2>&1)
                        echo "$age_output"  # Display the output to the user
                        
                        # Extract the passphrase using regex
                        if [[ "$age_output" =~ using\ autogenerated\ passphrase\ \"([^\"]+)\" ]]; then
                            password="${BASH_REMATCH[1]}"
                            echo "Captured passphrase: $password"
                        else
                            echo "Warning: Could not capture the passphrase automatically."
                            password="[See the passphrase displayed above]"
                        fi
                    fi
                else
                    echo "Using recipient key encryption..."
                    age -r "$recipient" -o "$encrypted_file" "$upload_file"
        echo "Recipient key used for encryption: $recipient"
    fi
            ;;
            
        gpg)
            encrypted_file="${upload_file}.gpg"
            echo "Encrypting with GPG..."
            
            if [[ -n "$user_password" ]]; then
                # Use the provided or generated password
                echo "Using provided/generated password for GPG encryption"
                # Create a temporary batch file for GPG with individual echo commands
                local batch_file=$(mktemp)
                
                # Write each line separately with proper indentation
                echo "%echo Encrypting with GPG" > "$batch_file"
                echo "%no-protection" >> "$batch_file"
                echo "%passphrase $user_password" >> "$batch_file"
                echo "%no-ask-passphrase" >> "$batch_file"
                echo "%no-symkey-cache" >> "$batch_file"
                
                # Use batch mode for GPG
                gpg --batch --yes --passphrase "$user_password" --output "$encrypted_file" --symmetric "$upload_file"
                rm -f "$batch_file"
                password="$user_password"
            else
                echo "Please enter a passphrase for GPG encryption"
                gpg --output "$encrypted_file" --symmetric "$upload_file"
                password="[Use the password you entered during encryption]"
            fi
            ;;
            
        aes)
            encrypted_file="${upload_file}.aes"
            echo "Encrypting with OpenSSL AES-256-CBC..."
            
            if [[ -n "$user_password" ]]; then
                # Use the provided or generated password
                echo "Using provided/generated password for AES encryption"
                # Use echo to provide the password to openssl
                echo "$user_password" | openssl enc -aes-256-cbc -salt -in "$upload_file" -out "$encrypted_file" -pass stdin
                password="$user_password"
            else
                echo "Please enter a passphrase for AES encryption"
                openssl enc -aes-256-cbc -salt -in "$upload_file" -out "$encrypted_file"
                password="[Use the password you entered during encryption]"
            fi
            ;;
            
        *)
            echo "Error: Invalid encryption method '$encrypt_method'. Use age, gpg, or aes."
            [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
        return 1
        ;;
    esac
        
        # Verify encrypted file exists
        if [[ ! -f "$encrypted_file" ]]; then
            echo "Error: Encryption failed. Encrypted file not created."
            # Clean up zip file
            [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
        return 1
        fi
        
        echo "Uploading encrypted file: $encrypted_file"
        # Capture the upload output and display it
        local upload_output=$(ffsend upload "$encrypted_file")
        echo "$upload_output"
        
        # Extract the link using a more reliable method
        if [[ "$upload_output" =~ https://[^[:space:]]+ ]]; then
            link="${BASH_REMATCH[0]}"
        else
            echo "Warning: Could not capture the download link automatically."
            link="[See the link displayed above]"
        fi
        
        echo "Removing encrypted file..."
        rm -f "$encrypted_file"
    else
        # Non-encrypted upload
        echo "Uploading file without encryption: $upload_file"
        # Capture the upload output and display it
        local upload_output=$(ffsend upload "$upload_file")
        echo "$upload_output"
        
        # Extract the link using a more reliable method
        if [[ "$upload_output" =~ https://[^[:space:]]+ ]]; then
            link="${BASH_REMATCH[0]}"
        else
            echo "Warning: Could not capture the download link automatically."
            link="[See the link displayed above]"
        fi
    fi

    # Clean up zip file if it was created
    if [[ -n "$zip_file" && -f "$zip_file" ]]; then
        echo "Cleaning up temporary zip file..."
        rm -f "$zip_file"
    fi

    echo "Upload completed. Use 'ffsend ls' to see your uploaded files."
    
    # Output sharing information
    if $encrypt; then
        echo "Copy and paste the following into your message to the receiver:"
        echo "Link: $link"
        echo "Password: $password"
        echo "Encryption method: $encrypt_method"
        echo "Command to decrypt the file: "
        if [[ "$encrypt_method" == "age" ]]; then
            echo "age -d -o $upload_file $encrypted_file"
        elif [[ "$encrypt_method" == "gpg" ]]; then
            echo "gpg --decrypt $encrypted_file"
        elif [[ "$encrypt_method" == "aes" ]]; then
            echo "openssl enc -aes-256-cbc -d -in $encrypted_file -out $upload_file -pass pass:$password"
        fi
    else
        echo "Share this link with the recipient: $link"
    fi
}

transfer_file(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: transfer_file path1 path2 ..."
        printf "This command uses rsync to transfer files or directories to a remote host.\n"
        printf "The remote host, port, and base remote path are read from the ~/.env file.\n"
        printf "An example ~/.env file is provided at $HOME/macos/.env-template\n"
        return 0
    fi

    # Source the .env file to load variables
    if [[ -f ~/.env ]]; then
        source ~/.env
    else
        echo "Error: ~/.env file not found"
        echo -n "Do you want to create a new ~/.env file? (y/n):(default:n) "
        read create_env
        if [[ $create_env =~ ^[Yy]$ ]]; then
            echo "REMOTE_HOST=username@192.168.1.xxx" >> $HOME/.env
            echo "REMOTE_PORT=2220" >> $HOME/.env
            echo "REMOTE_BASE_PATH=/path/to/directory" >> $HOME/.env
            echo "source ~/.zshrc" >> $HOME/.env
            echo "~/.env file created, please edit the file with the correct remote host, port, and base remote path"
            return 1
        else
            return 1
        fi
    fi
    # clean up files and directories before starting. 
    for path in "$@"; do
        # remove spaces and special characters from the variables
        path=$(echo "$path" | tr -cd '[:alnum:]_.-')
        # ask if the files should be scanned for viruses
        echo "Do you want to scan the file '$path' for viruses? (y/n):(default:n) "
        read scan_file
        if [[ $scan_file =~ ^[Yy]$ ]]; then
            # scan the file for viruses
            scan_file "$path"
        fi
    done
     

    # Check if vars are set
    if [[ -z "$REMOTE_HOST" || -z "$REMOTE_PORT" || -z "$REMOTE_BASE_PATH" ]]; then
        echo "Error: Remote host, port, or base remote path not set in ~/.env file"
        echo "Please set the variables in the ~/.env file"
    # prompt the user for the variables that are missing loop through the variables and prompt the user for the missing ones
    for var in REMOTE_HOST REMOTE_PORT REMOTE_BASE_PATH; do
        if [[ -z "${!var}" ]]; then
            echo "Please enter the value for $var:"
            read -s "${!var}"
        fi
    done
        return 1
    fi

    for path in "$@"; do
        if [[ ! -e "$path" ]]; then
            echo "Error: '$path' does not exist"
            continue
        fi
        # Set the target path on the remote host
        local target_path="$REMOTE_BASE_PATH/$(basename "$path")"
        if [[ -d "$path" ]]; then # if the path is a directory
            # create the directory on the remote host if it doesn't exist
            command ssh -p "$REMOTE_PORT" "$REMOTE_HOST" "mkdir -p \"$target_path\""
            # transfer the directory to the remote host
            /opt/homebrew/bin/rsync -avz --progress -e "ssh -p $REMOTE_PORT" "$path/" "$REMOTE_HOST:$target_path/" || echo "Failed to transfer directory '$path'"
        elif [[ -f "$path" ]]; then # if the path is a file
            # create the directory on the remote host if it doesn't exist
            command ssh -p "$REMOTE_PORT" "$REMOTE_HOST" "mkdir -p \"$REMOTE_BASE_PATH\""
            # transfer the file to the remote host
            /opt/homebrew/bin/rsync -avz --progress -e "ssh -p $REMOTE_PORT" "$path" "$REMOTE_HOST:$REMOTE_BASE_PATH/" || echo "Failed to transfer file '$path'"
        else
            echo "Error: '$path' is neither a file nor a directory"
        fi
    done
}