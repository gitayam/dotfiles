# ----------------------
# Git Aliases
# ----------------------
alias gita="git_add"
alias gitcg="git_commit"
alias gitp="git push"
alias gitpl="git pull"
alias gitco="git checkout"
alias gitcb="git checkout -b"
alias gitlog="git log --oneline --graph --all"

# ----------------------
# Git Functions
# ----------------------
git_commit(){
    if [[ -z "$1" ]]; then
        echo "No commit message provided. Opening editor for interactive commit message."
        git commit
    else
        git commit -m "$1"
    fi
}

git_add(){
    if [[ -z "$1" ]]; then
        echo "No files specified. Defaulting to 'git add .'"
        git add .
    else
        git add "$@"
    fi
}

update_git_repos(){
    # Default variables
    search_path="$HOME/Documents/Git/"  # Default search path
    exclude_paths=()                   # Array to store excluded paths

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --search-path)
                search_path="$2"
                shift 2
                ;;
            --exclude)
                exclude_paths+=("$2")
                shift 2
                ;;
            *)
                echo "Unknown argument: $1"
                return 1
                ;;
        esac
    done

    # Build the find command
    find_cmd="find \"$search_path\" -type d -name \".git\""

    for exclude in "${exclude_paths[@]}"; do
        find_cmd+=" ! -path \"$exclude/*\""
    done

    find_cmd+=" -print"

    # Execute the find command and update repositories
    eval "$find_cmd" | while IFS= read -r gitdir; do
        repo_dir=$(dirname "$gitdir")

        # Ensure the directory is marked safe for Git operations
        git config --global --add safe.directory "$repo_dir"

        echo "Updating repository in $repo_dir"
        cd "$repo_dir" || {
            echo "Failed to access $repo_dir"
            continue
        }
        git pull --rebase || echo "Failed to update $repo_dir"
    done
}

## Git Clone Function
### Usage: git_clone repo_name or url
### from any directory will clone the repo to the correct directory in the ~/Documents/Git/ directory
git_clone(){
    if [[ -z "$1" ]]; then
        echo "No repository name or URL provided"
        return 1
    fi

    # Determine the repo name from the URL or input
    if [[ "$1" =~ ^https?:// || "$1" =~ ^git@ ]]; then
        repo_name=$(basename "$1" .git)
        repo_url="$1"
    else
        repo_name=$(basename "$1")
        repo_url="https://github.com/your-username/$repo_name.git"
    fi

    # Check if the repo name is a valid directory name
    if [[ ! "$repo_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Invalid repository name: $repo_name"
        return 1
    fi

    # Check if the repo name already exists in the ~/Documents/Git/ directory
    if [[ -d "$HOME/Documents/Git/$repo_name" ]]; then
        echo "Repository already exists: $repo_name"
        return 1
    fi

    # Clone the repo to the ~/Documents/Git/ directory
    git clone "$repo_url" "$HOME/Documents/Git/$repo_name" || {
        echo "Failed to clone repository"
        return 1
    }

    # Change to the cloned repository directory
    cd "$HOME/Documents/Git/$repo_name" || {
        echo "Failed to access $repo_name directory"
        return 1
    }
    # print the current directory and list the files
    pwd
    ls -l
    #prompt user to open the repo dir (./) in vs code or cursor
    echo "Do you want to open the repository? (Y/n): "
    read open_in
    open_in=${open_in:-y}  # Default to 'y' if no input is provided

    if [[ $open_in =~ ^[Yy]$ ]]; then
        if command -v code &> /dev/null && command -v cursor &> /dev/null; then
            echo "Both VS Code and Cursor are available. Open with (v)scode or (c)ursor? (v/c): "
            read editor_choice
            editor_choice=${editor_choice:-v}  # Default to 'v' if no input is provided
            if [[ $editor_choice == "v" ]]; then
                code .
            elif [[ $editor_choice == "c" ]]; then
                cursor .
            fi
        elif command -v code &> /dev/null; then
            code .
        elif command -v cursor &> /dev/null; then
            cursor .
        else
            echo "Neither VS Code nor Cursor is available."
        fi
    fi
}
# ----------------------
# Navigation and File Management Aliases
# ----------------------
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias mkdir="mkdir -p"
alias rmr="rm -rf"
alias untar="tar -zxvf"
alias tarx="tar -xvf"
#TODO: zipfile function
zipfile(){
    # usage: zipfile name file_or_dir1 file_or_dir2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: zipfile name_of_zip_file file_or_dir1 file_or_dir2 ..."
        return 0
    fi
    # check if args are passed
    # check if name is passed or if file or dir is passed
    # If name is passed then zip the file or dir with the name
    # if no name is passed then zip the file or dir with the name of the file or dir
    # if multiple files or dirs are passed then zip them all with the name of the first file or dir + more + .zip
}

## Make Directory and cd to it if only one arg is passed else just make the dir
mcd(){
    if [[ -z "$1" ]]; then
        echo "No directory name provided"
        return 1
    # elif only one arg is passed then make the dir and cd to it
    elif [[ -n "$1" ]]; then
        mkdir -p "$1" && cd "$1"
        pwd # print the current directory
    #else if multiple args are passed then make the dirs and list them
    elif [[ -n "$@" ]]; then
        mkdir -p "$@" && ls -l "$@"
    fi
}

#All updates on macos including brew, macos,git function updates
update_all(){
    sudo echo "Updating brew" # using sudo with echo to get user password , sudo used softwareupdate
    brew update && brew upgrade && brew cleanup && brew doctor
    echo "Updating macos"
    sudo softwareupdate --install --all
    echo "Updating git functions"
    update_git_repos
    echo "Clearing cache"
    clear
}
# ----------------------
# Applications Aliases
# ----------------------
setup_profiles(){
    mkdir -p $HOME/Profiles
    cd $HOME/Profiles
}
alias run-matrix="run-element"
alias run-irregular="run-element irregularchat"
run-element(){
    # usage: run-element
    # open element desktop in the default browser
    # if a profile is passed then use it
    setup_profiles
    /Applications/Element.app/Contents/MacOS/Element --profile "$1"&
    cd - # go back to the previous directory
}

run-firefox(){
    # usage: run-firefox
    # open firefox in the default browser
    # if a profile is passed then use it 
    setup_profiles
    /Applications/Firefox.app/Contents/MacOS/firefox --profile "$1" --new-window "https://sso.irregularchat.com"&
    cd - # go back to the previous directory
}

run-discord(){
    # usage: run-discord
    # open discord in the default browser
    # if a profile is passed then use it
    setup_profiles
    /Applications/Discord.app/Contents/MacOS/Discord --profile "$1"&
    cd - # go back to the previous directory
}
# command line keepassxc
alias kp="keepassxc"
# Open database in keepassxc
alias run-kp="kp --db $1"

#general passphrase with diceware
#3 words, symbols, numbers
alias gen-passphrase="diceware -n 3 -w 3 -s 3 -d 3"
# ----------------------
# Security Tools Aliases
# ----------------------
alias json="jq ."
alias http="curl -I"
alias ports="netstat -tuln"

scan_ports(){
    #usage: scan_ports ip_or_host
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    # if no ip_or_host is passed then use the router ip 
    if [[ -z "$1" ]]; then
        local_ip=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -n 1)
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    #check if package is installed
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed"
        #prompt to install if yes install and continue else return 1
        install_nmap="n"
        echo -n "Do you want to install nmap? (y/n): " 
        read install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            brew install nmap
            echo "nmap installed, continuing with scan"
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn $1
}
# ----------------------
# Helper Functions
# ----------------------
# Colorize the `ls` output and setup useful aliases
export LS_OPTIONS='--color=auto'
alias ls='ls $LS_OPTIONS'
alias ll='ls -lh $LS_OPTIONS'        # Detailed list view
alias la='ls -lha $LS_OPTIONS'       # Show hidden files
alias l='ls -lA $LS_OPTIONS'         # Short list view with hidden files
alias lt='ls -strhal $LS_OPTIONS'       # Sort by date, most recent last

# Safe aliases to prevent accidental file overwrites or deletions
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Navigation Function
# Fast directory navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."

# change dir and List Directory Contents
cdl(){
  if [ -n "$1" ]; then
    cd "$1" && ll
  else
    cd ~ && ll
  fi
}

# create backup of a file or directory
backup(){
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  
  # take files, dictionaries as arguments get full path as needed many args possible
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done
}
# Searching 
# Grep aliases and functions
alias grep='grep -i --color=auto "$@"' # Ignore case and colorize output and pass all arguments to grep in quotes
alias grepv='grep -vi --color=auto' # Ignore case, invert match, and colorize output

# Find aliases and functions
alias findf='find . -type f -name' # Find files by name
alias findd='find . -type d -name' # Find directories by name

#TODO
# findex(){
#   # Skip if being sourced (zsh-specific check)
#   if [[ ${zsh_eval_context[-1]} == "file" ]]; then
#     return 0
#   fi
  
  # Show help menu if -h or --help is passed
#   if [[ "$1" == "-h" || "$1" == "--help" ]]; then
#     echo "Usage: findex <pattern> <command> [args...]"
#     echo "Examples:"
#     echo "  findex '*.txt' ls -l"
#     echo "  findex '*.php' nano"
#     echo "  findex '*.sh' chmod 755"
#     echo "  findex '*.log' grep 'error'"
#     echo "  findex '*.txt' sed 's/old/new/g'"
#     return 0
#   fi

  # Need at least pattern and command
#   if [[ $# -lt 2 ]]; then
#     echo "Error: Missing command. See 'findex --help' for usage."
#     return 1
#   fi

#   local pattern="$1"
#   shift # Remove pattern from arguments
#   find . -iname "$pattern" -exec "$@" \;
# }

# Nano Editor settings
alias nanozsh='nano ~/.zshrc'     # Open the bashrc file in nano
alias reset='reset_file'          # Custom function to erase a file content then open with nano

# Nano Functions
reset_file(){
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
  # Reset the file content to an empty string
  # use the backup function to create a backup of the file before erasing
  #handle one or multiple files
  # catch escapes and errors to handle prompting user to restore backup or delete
  for file in "$@"; do
    backup "$file"
    echo "" > "$file"
    echo "File content backed up and erased."
    echo "Opening $file in nano editor"
    #echo >> the filename to the file with a # at the beginning
    echo "# $file" >> "$file"
    #sleep half a second
    sleep 0.5
    nano "$file"
    # prompt user to restore backup or delete
    ls $file$backup_name
    # default to no
    see_diff="n"
    echo -n "Do you want to see the difference between the original and backup file? (y/n):(default:n) "
    read see_diff
    if [ "$see_diff" == "y" ]; then
      diff "$file" "$file$backup_name"
      restore_backup="n"
      echo -n "Do you want to restore the backup file? (y/n):(default:n) "
      read restore_backup
      if [ "$restore_backup" == "y" ]; then
          mv "$file$backup_name" "$file"
          echo "Backup file restored."
      fi
    fi
  done
}

# Docker Aliases
alias dc="docker compose"
alias docker-compose="dc" # alias for docker compose instead of docker-compose
alias dcu="dc pull && dc up -d" # pull and start the docker compose services
alias dcd="dc down" # stop the docker compose services
alias dcb="dcu --build" # build the docker compose services
alias dcp="dc pull" # pull the docker compose services
alias dcr="dcd && dcu" # stop and start the docker compose services
#purge docker compose services networks and volumes 
alias dcnet="docker network prune"
alias dcvol="docker volume prune"
alias dcpur="dcd && dcp && dcnet && dcvol" # stop and pull the docker compose services
alias d="docker" # alias for docker
alias dps="d ps"
alias dbash="d exec -it $1 /bin/bash"
alias dsh="d exec -it $1 /bin/sh"


# Networking shortcuts
alias ports='netstat -tulanp'  # List open ports
alias myip='curl ifconfig.me'  # Check external IP address

# Disk usage shortcuts
alias du='du -h --max-depth=1'  # Show disk usage in human-readable format
alias df='df -h'                # Show free disk space in human-readable format


# Menu with all functions in ~/.zsh_aliases and ~/.mac_functions.sh

show_func(){
    # usage: show_help function_name
    # show the help for a specific function
    cat ~/.zsh_aliases|grep "$1()"
}
alias show_function="show_func"
show_alias(){
    # usage: show_alias
    # show all the aliases in the ~/.zsh_aliases file
    cat ~/.zsh_aliases | grep -E "^alias " | cut -d '=' -f 1 | sort | uniq
}

show_help(){
    # usage: show_help function_name
    # show the help for a specific function
    grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" ~/.zsh_aliases
}

helpmenu(){
    echo "Help Menu:"
    echo "----------"
    echo "See all functions: show_function"
    echo "See all aliases: show_alias"
    echo "See help for a function: show_help function_name"
    echo "See help for an alias: show_help alias_name"
}

# ----------------------
# GitHub Repository Management
# ----------------------

create_repo(){
    # "Usage: create_repo repo_name"
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: create_repo repo_name"
        return 0
    fi
    
    if ! command -v gh &> /dev/null; then
        echo "Error: GitHub CLI 'gh' is not installed."
        install_gh="y"
        echo -n "Do you want to install GitHub CLI? (y/n):(default:y) "
        read install_gh
        if [[ $install_gh =~ ^[Yy]$ ]]; then
            brew install gh
            echo "GitHub CLI installed, continuing with repo creation"
        else
            echo "GitHub CLI not installed, you can install it with 'brew install gh' before running this function again"
            return 1
        fi
    fi

    repo_name=$(echo "$@" | tr ' ' '_')
    local base_dir="$HOME/Documents/Git"
    mkdir -p "$base_dir"

    use_gitignore="n"
    echo -n "Do you want to use a special .gitignore file? (y/n):(default:n) "
    read use_gitignore

    if [[ $use_gitignore =~ ^[Yy]$ ]]; then
        echo "Available gitignore templates:"
        echo "1) Python"
        echo "2) Node/JavaScript"
        echo "3) Markdown"
        echo "4) Shell"
        echo "5) None (basic repo setup)"
        
        echo -n "Select a template (1-5): "
        read template_choice

        case $template_choice in
            1)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Python || return 1
                ;;
            2)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Node || return 1
                ;;
            3)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Markdown || return 1
                ;;
            4)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Shell || return 1
                ;;
            *)
                gh repo create --add-readme "$repo_name" --private --license=mit || return 1
                ;;
        esac
    else
        gh repo create --add-readme "$repo_name" --private --license=mit || return 1
    fi

    git clone "https://github.com/$(gh api user | jq -r '.login')/$repo_name.git" "$base_dir/$repo_name" || return 1
    cd "$base_dir/$repo_name" || return 1
    echo "# $repo_name" >> README.md
    git add README.md
    git commit -m "Initial commit"
    git branch -M main
    git push -u origin main

    echo "Repository $repo_name created and initialized successfully in $base_dir."
}

# ----------------------
# Python Virtual Environment Management
# ----------------------
# Python Aliases 
pyenv(){
  python3 -m venv env  # Create the virtual environment
  source env/bin/activate  # Activate the virtual environment (on Linux/Mac)
  pip install --upgrade pip  # Upgrade pip
  pip install -r requirements.txt  # Install dependencies
}

# Python Aliases 
pyserver(){
    # usage: pyserver file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver file1 file2 ..."
        return 0
    fi
    # check if python3 is installed
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed"
        echo "You can install it with:"
        echo 'brew install python'
        return 1
    fi
    # set port for the python server
    local port=8000
    # create a python server for the passed files or dir
    #get local ip
    local_ip=$(hostname -I | awk '{print $1}')
    # path for the server else use current dir
    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    # if no files passed in arg then use current dir
    if [ -n "$1" ]; then # if there are files passed in arg
        # create temp dir
        mkdir -p /tmp/pyserver
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/pyserver
        done
        # change dir to the temp dir
        cd /tmp/pyserver
        # start the python server
        python3 -m http.server $port
    else
        # use current dir
        cd .
        # start the python server
        python3 -m http.server $port
    fi
    
}

funnel() {
    # usage: funnel file1 file2 dir1 dir2 ...
    # On MacOS you must be using the open source tailscaled distribution to use the funnel command for files. 
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: funnel <target>"
        echo "Funnel enables you to share a local server on the internet using Tailscale."
        return 0
    fi
    
    # Default port and allow override with FUNNEL_PORT env variable
    local port=${FUNNEL_PORT:-8080}
    use_python=true #use this with MacOS or as needed

    # Check if tailscale is running
    if ! tailscale status &> /dev/null; then
        echo "Tailscale is not running. Attempting to start it with 'tailscale up'..."
        tailscale up
        
        # Check again if tailscale is running after attempting to start it
        if ! tailscale status &> /dev/null; then
            echo "Error: Failed to start Tailscale. Please start it manually."
        return 1
        fi
        echo "Tailscale started successfully. Continuing..."
    fi

    # Use current directory if no target is specified
    if [ -z "$1" ]; then
        echo "No target specified. Using current directory as target."
        target="."
    else
        target="$@"
    fi

    # Kill any existing Python HTTP servers on our port
    local existing_pid=$(lsof -ti:$port)
    if [[ -n "$existing_pid" ]]; then
        echo "Killing existing process on port $port (PID: $existing_pid)"
        kill -9 $existing_pid 2>/dev/null
        sleep 1
    fi

    # Function to clean up background processes
    cleanup() {
        echo "Cleaning up..."
        # Find and kill the Python HTTP server process
        if [[ -n "$server_pid" ]]; then
            echo "Killing server process (PID: $server_pid)"
            kill -9 $server_pid 2>/dev/null
            wait $server_pid 2>/dev/null
        fi
        
        # Also try to find any process using our port
        local port_pid=$(lsof -ti:$port)
        if [[ -n "$port_pid" ]]; then
            echo "Killing process on port $port (PID: $port_pid)"
            kill -9 $port_pid 2>/dev/null
        fi
        
        # Clean up temp directory
        if [[ -d "/tmp/funnel" ]]; then
            echo "Removing temporary directory"
            rm -rf /tmp/funnel
        fi
        
        # Return to original directory
        if [[ -n "$original_dir" ]]; then
            cd "$original_dir"
        fi
        
        return 0
    }

    # Save original directory
    original_dir=$(pwd)

    # Trap SIGINT (Ctrl+C) to run cleanup
    trap cleanup INT TERM EXIT

    # if files are passed as arguments
    if [ -n "$1" ]; then
        # Clean up any existing temp directory
        if [[ -d "/tmp/funnel" ]]; then
            rm -rf /tmp/funnel
        fi
        
        # Create temp dir
        mkdir -p /tmp/funnel
        
        # Copy (not link) the files to the temp dir
        for file in "$@"; do
            # Use absolute paths for files
            local abs_path
            if [[ "$file" = /* ]]; then
                abs_path="$file"
            else
                abs_path="$original_dir/$file"
            fi
            
            echo "Checking path: $abs_path"
            
            if [[ -f "$abs_path" ]]; then
                cp "$abs_path" "/tmp/funnel/"
                echo "Copied file: $abs_path"
            elif [[ -d "$abs_path" ]]; then
                # For directories, copy the entire directory structure
                cp -r "$abs_path" "/tmp/funnel/"
                echo "Copied directory: $abs_path"
            else
                echo "Warning: $abs_path does not exist, skipping"
            fi
        done
        
        # Change dir to the temp dir
        cd /tmp/funnel
        
        # List the contents to verify
        echo "Files available for sharing:"
        ls -la
        
        if $use_python; then
            # Start the python server
            python3 -m http.server $port &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:$port >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel localhost:$port
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    else
        # Use current dir
        cd .
        if $use_python; then
            # Start the python server
            python3 -m http.server $port &
            server_pid=$!
            
            # Wait a moment to ensure server starts
            sleep 1
            
            # Check if server started successfully
            if ! lsof -ti:$port >/dev/null 2>&1; then
                echo "Error: Failed to start Python HTTP server on port $port"
                cleanup
                return 1
            fi
            
            # Start the funnel
            tailscale funnel localhost:$port
        else
            # Start the funnel
            tailscale funnel "$target"
        fi
    fi
}

alias tsf=funnel
alias postfile=funnel


# ----------------------
# MAC Address Management
# ----------------------

gen_mac_addr(){
    local mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

change_mac_menu(){
    echo "Choose an option:"
    echo "1. Set a specific MAC address"
    echo "2. Set a random MAC address"
    echo "3. Restore original MAC address"
    echo -n "Enter your choice (1/2/3): "
    read choice

    case $choice in
        1)
            echo -n "Enter the new MAC address (e.g., E6:B8:BA:D2:41:07): "
            read mac_address
            echo -n "Enter the name of the new network location: "
            read location_name
            change_mac_address "$mac_address" "$location_name"
            ;;
        2)
            echo -n "Enter the name of the new network location: "
            read location_name
            mac_address=$(gen_mac_addr)
            change_mac_address "$mac_address" "$location_name"
            ;;
        3)
            restore_original_mac
            ;;
        *)
            echo "Invalid choice. Exiting."
            ;;
    esac
}

# ----------------------
# Matrix Setup
# ----------------------

matrix_setup(){
    # for a list of tags see https://github.com/spantaleev/matrix-docker-ansible-deploy/blob/a1efb78bcbc3a9205a59de3364f47192b6232f0f/docs/playbook-tags.md#L4
    ## Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        # show help
        echo "Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}"
        return 0
    fi

    if ! command -v ansible-playbook &> /dev/null; then
        # show error
        echo "Error: 'ansible-playbook' is not installed."
        return 1
    fi
    # set mode to normal if no mode is passed
    local mode="${1:-normal}"
    # set vars file to the default path if no path is passed $HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com
    local vars_file="${2:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com/vars.yml}"
    # Fix: Go up three directories from vars file to reach inventory directory
    local hosts_file="$(dirname "$(dirname "$(dirname "$vars_file")")")/hosts"
    #set the setup.yml file to the directory above the inventory directory
    local setup_file="${hosts_file%/*/*}/setup.yml"
    # set the matrix repo path to the directory above the inventory directory
    local matrix_repo_path="${hosts_file%/*}/.."
    # check if vars file exists
    if [[ ! -f "$vars_file" ]]; then
        echo "Error: Vars file not found at $vars_file"
        return 1
    fi
    # check if hosts file exists
    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the case statement
    case "$mode" in
        full|1)
            # full will update the repo and make roles then setup and start the services using all the tags
            # git pull && sudo make roles of the matrix repo without moving to the repo dir
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=install-all,setup-all,ensure-matrix-users-created,restart || return 1
            cd - # return to the previous directory
            ;;
        normal)
            # normal will update the repo and make roles then setup and start the services
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=setup-all,start || return 1
            cd - # return to the previous directory
            ;;
        restart)
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=restart || return 1
            cd - # return to the previous directory
            ;;
        *)
            echo "Usage: matrix_setup {full|1|normal|restart} [hosts_file_path]"
            return 1
            ;;
    esac
}

# ----------------------
# Matrix User Setup
# ----------------------

matrix_setup_user(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: matrix_setup_user username [password] [admin] [device_id] [hosts_file_path]"
        return 0
    fi

    if ! command -v curl &> /dev/null || ! command -v ansible-playbook &> /dev/null; then
        echo "Error: Required commands 'curl' or 'ansible-playbook' are not installed."
        return 1
    fi

    local username="$1"
    local password="${2:-$(openssl rand -base64 18)}"
    local admin="${3:-no}"
    local device_id="${4:-${username}_$(openssl rand -hex 3)}"
    local hosts_file="${5:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/hosts}"

    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the ansible playbook to register the user
    sudo ansible-playbook -i "$hosts_file" setup.yml \
        --extra-vars="username=${username} password='${password}' admin=${admin}" \
        --tags=register-user
    # login to the matrix server and obtain the access token
    curl -XPOST -d "{
        \"identifier\": { \"type\": \"m.id.user\", \"user\": \"${username}\" },
        \"password\": \"${password}\",
        \"type\": \"m.login.password\",
        \"device_id\": \"${device_id}\"
    }" 'https://matrix.irregularchat.com/_matrix/client/r0/login'
}

# ----------------------
# Cryptography
# ----------------------
setup_age(){
    # setup age directory and keys
    mkdir -p ~/.age
    #get username
    username=$(whoami)
    #if no argument passed for key name then use username
    if [[ -z "$1" ]]; then
        key_name="$username"
    else
        key_name="$1"
    fi
    
    #echo guidance on storying and using the age keys
    echo "Store the following keys in a secure location:"
    echo "Public key: ~/.age/keys/$key_name.pub"
    echo "Private key: ~/.age/keys/$key_name.key"
    echo "You will see a public key output to the screen that you can share with others"
    echo "For more information on age see https://github.com/FiloSottile/age"
    sleep 1
    # generate keys
    age-keygen -a -o ~/.age/keys/$key_name.key
    ls -l ~/.age/keys
}

scan_file(){
    # check if clamscan is installed
    if ! command -v clamscan &> /dev/null; then
        echo "Error: 'clamscan' is not installed."
        echo "You can install it with: brew install clamscan"
        return 1
    fi
    # check if the file exists
    if [[ ! -f "$path" ]]; then
        echo "Error: File not found at '$path'"
        return 1
    fi
    # update the virus database
    sudo freshclam
    # scan the file for viruses
    clamscan "$path"
}
ocr_files(){
    # Display help if requested
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: ocr_files file1 file2 dir1 dir2 ..."
        echo "Processes PDF files to add OCR text layer."
        return 0
    fi

    # Check if ocrmypdf is installed
    if ! command -v ocrmypdf &> /dev/null; then
        echo "Error: 'ocrmypdf' is not installed."
        echo "You can install it with: brew install ocrmypdf"
        return 1
    fi

    # Process each argument
    for path in "$@"; do
        if [[ -d "$path" ]]; then
            # If it's a directory, find all PDF files and process them
            find "$path" -type f -name "*.pdf" | while read -r file; do
                base_name=$(basename "$file" .pdf)
                output_file="${file%.*}-ocr.pdf"
                echo "Processing $file..."
                ocrmypdf "$file" "$output_file" || echo "Failed to process $file"
            done
        elif [[ -f "$path" && "$path" == *.pdf ]]; then
            # If it's a file, process it directly
            base_name=$(basename "$path" .pdf)
            output_file="${path%.*}-ocr.pdf"
            echo "Processing $path..."
            ocrmypdf "$path" "$output_file" || echo "Failed to process $path"
        else
            echo "Skipping $path: Not a PDF file or directory."
        fi
    done
}
clean_file(){
    # Check if a file path is provided
    if [[ -z "$1" ]]; then
        echo "Error: No file path provided."
        return 1
    fi

    # Use the provided file path
    local path="$1"
    # get full path
    local full_path=$(realpath "$path")

    # Remove spaces and special characters from the file name
    local clean_file=$(echo "$full_path" | tr -cd '[:alnum:]_.-')

    # Move the file to the new name
    mv "$full_path" "$clean_file"

    # Return the cleaned file name with full path
    echo "$clean_file"
}

encrypt_file(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: encrypt_file [-m method] [-r recipient] file1 file2 ..."
        echo "Options:"
        echo "  -m method       Encryption method: age (default), gpg, or aes"
        echo "  -r recipient    Use recipient's public key instead of passphrase (only for age)"
        echo "  -e, --encrypt   Optional flag (for consistency with other functions)"
        return 0
    fi

    # Check if encryption tools are installed
    local has_age=false
    local has_gpg=false
    local has_openssl=false
    
    if command -v age &> /dev/null; then
        has_age=true
    fi
    if command -v gpg &> /dev/null; then
        has_gpg=true
    fi
    if command -v openssl &> /dev/null; then
        has_openssl=true
    fi
    
    # If no encryption tools are available, prompt to install age
    if ! $has_age && ! $has_gpg && ! $has_openssl; then
        echo "Error: No encryption tools found (age, gpg, or openssl)."
        echo -n "Do you want to install 'age'? (y/n):(default:y) "
        read install_age
        if [[ $install_age =~ ^[Yy]$ || -z "$install_age" ]]; then
            brew install age
            has_age=true
        else
            return 1
        fi
    fi

    # Initialize variables
    local recipient=""
    local use_passphrase=true
    local encrypt_method="age"  # Default encryption method
    local zip_file=""
    local password=""

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--encrypt)
                # Just a flag for consistency with other functions
                shift
                ;;
            -m)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -m requires a method argument (age, gpg, or aes)"
                    return 1
                fi
                encrypt_method="$2"
                shift 2
                ;;
            -r)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -r requires a recipient argument"
                    return 1
                fi
                recipient="$2"
                use_passphrase=false
                shift 2
                ;;
            -*)
                echo "Unknown option: $1"
                echo "Usage: encrypt_file [-m method] [-r recipient] file1 file2 ..."
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    # Validate encryption method
    case "$encrypt_method" in
        age)
            if ! $has_age; then
                echo "Error: 'age' is not installed but specified as encryption method."
                return 1
            fi
            ;;
        gpg)
            if ! $has_gpg; then
                echo "Error: 'gpg' is not installed but specified as encryption method."
                return 1
            fi
            ;;
        aes)
            if ! $has_openssl; then
                echo "Error: 'openssl' is not installed but specified as encryption method."
                return 1
            fi
            ;;
        *)
            echo "Error: Invalid encryption method '$encrypt_method'. Use age, gpg, or aes."
            return 1
            ;;
    esac

    # Check if files are provided
    if [[ "$#" -eq 0 ]]; then
        echo "Error: No files provided for encryption."
        return 1
    fi

    # If multiple files are passed, zip them and encrypt the zip file
    local files_to_encrypt
    if [[ "$#" -gt 1 ]]; then
        # zip the files
        zip_file="./$(basename "$1")_encrypted_$(date +%Y%m%d%H%M%S).zip"
        echo "Creating zip file with multiple files..."
        zip -q "$zip_file" "$@"
        files_to_encrypt="$zip_file"
    else
        # if only one file is passed then set the file to encrypt
        files_to_encrypt="$1"
    fi

    # Encrypt the file(s) based on the selected method
    local encrypted_file
    case "$encrypt_method" in
        age)
            encrypted_file="${files_to_encrypt}.age"
            echo "Encrypting with age..."
            
            if $use_passphrase; then
                # Capture the passphrase from age output
                echo "Using passphrase encryption..."
                local age_output=$(age -p -o "$encrypted_file" "$files_to_encrypt" 2>&1)
                # Extract the passphrase from the output
                password=$(echo "$age_output" | grep -o 'passphrase: "[^"]*"' | cut -d '"' -f 2)
                if [[ -z "$password" ]]; then
                    # Try alternate format
                    password=$(echo "$age_output" | grep -o 'passphrase "[^"]*"' | cut -d '"' -f 2)
                fi
                
                if [[ -n "$password" ]]; then
                    echo "Generated passphrase: $password"
                    echo "Save this passphrase securely - you'll need it to decrypt the file."
                fi
            else
                echo "Using recipient key encryption..."
                age -r "$recipient" -o "$encrypted_file" "$files_to_encrypt"
        echo "Recipient key used for encryption: $recipient"
    fi
            ;;
            
        gpg)
            encrypted_file="${files_to_encrypt}.gpg"
            echo "Encrypting with GPG..."
            echo "You will be prompted to enter a passphrase for encryption."
            gpg --output "$encrypted_file" --symmetric "$files_to_encrypt"
            echo "File encrypted with GPG. Remember your passphrase for decryption."
            ;;
            
        aes)
            encrypted_file="${files_to_encrypt}.aes"
            echo "Encrypting with OpenSSL AES-256-CBC..."
            echo "You will be prompted to enter a passphrase for encryption."
            openssl enc -aes-256-cbc -salt -in "$files_to_encrypt" -out "$encrypted_file"
            echo "File encrypted with AES-256. Remember your passphrase for decryption."
            ;;
    esac

    # Verify the encrypted file was created
    if [[ ! -f "$encrypted_file" ]]; then
        echo "Error: Encryption failed. Encrypted file not created."
    # Clean up zip file if it was created
        [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
        return 1
    fi

    # Clean up zip file if it was created
    if [[ -n "$zip_file" && -f "$zip_file" ]]; then
        rm -f "$zip_file"
    fi

    # Instructions for decryption
    echo "Encrypted file created: $encrypted_file"
    echo ""
    echo "To decrypt the file:"
    
    case "$encrypt_method" in
        age)
            if $use_passphrase; then
                echo "age --decrypt --output ${encrypted_file%.age} $encrypted_file"
                echo "You will be prompted for the passphrase shown above."
            else
                echo "age --decrypt --identity ~/.age/keys/your_private_key.key --output ${encrypted_file%.age} $encrypted_file"
            fi
            ;;
            
        gpg)
            echo "gpg --output ${encrypted_file%.gpg} --decrypt $encrypted_file"
            echo "You will be prompted for the passphrase you entered during encryption."
            ;;
            
        aes)
            echo "openssl enc -d -aes-256-cbc -in $encrypted_file -out ${encrypted_file%.aes}"
            echo "You will be prompted for the passphrase you entered during encryption."
            ;;
    esac
    
    echo ""
    echo "File successfully encrypted: $encrypted_file"
    return 0
}

generate_password(){
    # Generate a random password
    # Default password type is phrases using diceware
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: generate_password [-p type] [-l length] [-m]"
        echo "Options:"
        echo "  -p type       Password type: phrases (default), chars (random characters), or numbers"
        echo "  -l length     Length of the password (default: 6 words for phrases, 22 chars for others)"
        echo "  -m            Manual mode - prompt for password instead of generating"
        return 0
    fi
    
    # Check if diceware is installed for phrase passwords
    local has_diceware=false
    if command -v diceware &> /dev/null; then
        has_diceware=true
    fi
    
    local password_type="phrases"
    local length=6  # Default 6 words for phrases
    local char_length=22  # Default 22 chars for character passwords
    local manual_mode=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -p requires a type argument (phrases, chars, numbers)"
                    return 1
                fi
                password_type="$2"
                shift 2
                ;;
            -l)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -l requires a length argument"
                    return 1
                fi
                if [[ "$password_type" == "phrases" ]]; then
                    length="$2"
                else
                    char_length="$2"
                fi
                shift 2
                ;;
            -m)
                manual_mode=true
                shift
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use 'generate_password -h' for help."
                return 1
                ;;
        esac
    done
    
    # If manual mode, prompt for password
    if $manual_mode; then
        echo "Enter your password (input will be hidden):"
        read -s password
        echo "Confirm your password:"
        read -s password_confirm
        
        if [[ "$password" != "$password_confirm" ]]; then
            echo "Error: Passwords do not match."
            return 1
        fi
        
        echo "Password set manually."
        return 0
    fi
    
    # Generate password based on type
    case "$password_type" in
        phrases)
            if ! $has_diceware; then
                echo "Error: 'diceware' is not installed but required for phrase passwords."
                echo "You can install it with: brew install diceware"
                echo -n "Do you want to install diceware now? (y/n): "
                read install_diceware
                if [[ "$install_diceware" =~ ^[Yy]$ ]]; then
                    brew install diceware
                    has_diceware=true
                else
                    echo "Falling back to character-based password."
                    password_type="chars"
                fi
            fi
            
            if $has_diceware; then
                # Use diceware to generate a phrase password
                password=$(diceware -n "$length" -c -s 2)
                echo "Generated passphrase: $password"
            else
                # Fallback if diceware installation failed
                password=$(openssl rand -base64 "$char_length" | tr -d '/+=' | cut -c1-"$char_length")
                echo "Generated password: $password"
            fi
            ;;
            
        chars)
            # Generate a random character password with letters, numbers, and symbols
            password=$(openssl rand -base64 $(($char_length * 2)) | tr -d '/+=' | cut -c1-"$char_length")
            echo "Generated password: $password"
            ;;
            
        numbers)
            # Generate a random numeric password
            password=$(openssl rand -base64 $(($char_length * 2)) | tr -dc '0-9' | cut -c1-"$char_length")
            echo "Generated numeric password: $password"
            ;;
            
        *)
            echo "Error: Invalid password type '$password_type'. Use phrases, chars, or numbers."
            return 1
            ;;
    esac
    
    echo "Save this password securely!"
    return 0
}

# ----------------------
# File Transfer
# ----------------------


#wormhole alias
alias wh="wormhole"
alias wht="wh-transfer"
#transfer file with wormhole many or one file
wh-transfer(){
    trap '[[ -f "$zip_file" ]] && rm -rf "$zip_file"' EXIT INT

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: wh-transfer [-e|--encrypt] path1 path2 ..."
        echo "The default is to send the files as is"
        echo "-e or --encrypt will encrypt the files before sending using age, gpg, or aes"
        return 0
    fi

    encrypt_and_send() {
        local encrypt_tool="$1"
        shift
        local files=("$@")
        local zip_file="./wormhole_$(date +%Y%m%d%H%M%S).zip"
        zip "$zip_file" "${files[@]}"
        
        local encrypted_file="${zip_file}.age"
        if [[ "$encrypt_tool" == "gpg" ]]; then
            encrypted_file="${zip_file}.gpg"
            gpg --output "$encrypted_file" --symmetric "$zip_file"
        elif [[ "$encrypt_tool" == "aes" ]]; then
            encrypted_file="${zip_file}.aes"
            openssl enc -aes-256-cbc -salt -in "$zip_file" -out "$encrypted_file"
        else
            age -o "$encrypted_file" -p "$zip_file"
        fi

        wormhole send "$encrypted_file"
        rm -rf "$zip_file" "$encrypted_file"
    }

    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        shift
        if command -v age &> /dev/null; then
            encrypt_and_send "age" "$@"
        elif command -v gpg &> /dev/null; then
            encrypt_and_send "gpg" "$@"
        else
            encrypt_and_send "aes" "$@"
        fi
    else
        if [[ "$#" -gt 1 ]]; then
            local zip_file="./wormhole_$(date +%Y%m%d%H%M%S).zip"
            zip "$zip_file" "$@"
            wormhole send "$zip_file"
            rm -rf "$zip_file"
        else
            wormhole send "$@"
        fi
    fi
}

upload_to_pcloud(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: upload_to_pcloud [-e|-encrypt] source_path [remote_path]"
        echo "Uploads files or directories to pCloud using rclone."
        echo "Options:"
        echo "  -e, --encrypt   Encrypt the file(s) before uploading using 'age'."
        echo "If remote_path is not provided, files will be uploaded to the root of the remote."
        return 0
    fi

    # Default remote name for pCloud
    local remote="pcloud"
    # Check for encryption option
    local encrypt=false
    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        encrypt=true
        shift
    fi

    # Check for source_path
    if [[ -z "$1" ]]; then
        echo "Error: Source path is required."
        echo "Use 'upload_to_pcloud -h' for help."
        return 1
    fi
    local source_path="$1"
    shift

    # Set the remote path or use the root of the remote
    local remote_path="$1"
    if [[ -z "$remote_path" ]]; then
        remote_path="/"
    fi

    # Debug: Print paths
    echo "Source path: $source_path"
    echo "Remote path: $remote_path"

    # Check if the source path exists
    if [[ ! -e "$source_path" ]]; then
        echo "Error: Source path '$source_path' does not exist."
        return 1
    fi

    # Encrypt the file if requested
    if [[ "$encrypt" == true ]]; then
        echo "Encrypting file..."
        encrypt_file "$source_path"
        local encrypted_path="${source_path}.age"
        echo "Uploading encrypted file to pCloud..."
        rclone copy "$encrypted_path" "$remote:$remote_path" -P || {
            echo "Error: Failed to upload encrypted file to pCloud."
            return 1
        }
        rm "$encrypted_path" # Clean up encrypted file
    else
        # Upload directly
        echo "Uploading '$source_path' to pCloud..."
        rclone copy "$source_path" "$remote:$remote_path" -P || {
            echo "Error: Failed to upload to pCloud."
            return 1
        }
    fi

    echo "Upload to pCloud completed successfully!"
}

# ffsend file transfer including encryption option
fsend(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: fsend [-e|--encrypt] [-m method] [-r recipient] [-p password] [-g] path1 path2 ..."
        echo "Options:"
        echo "  -e, --encrypt    Encrypt the file(s) before sending"
        echo "  -m method        Encryption method: age (default), gpg, or aes"
        echo "  -r recipient     Use recipient's public key instead of passphrase (only for age)"
        echo "  -p password      Specify a password (for gpg and aes methods)"
        echo "  -g               Auto-generate password without prompting"
        return 0
    fi

    # Check if ffsend is installed
    if ! command -v ffsend &> /dev/null; then
        echo "Error: 'ffsend' is not installed."
        echo "You can install it with: brew install ffsend"
        return 1
    fi

    # Define variables at the top level
    local zip_file=""
    local encrypt_method="age"  # Default encryption method
    local password=""
    local link=""
    local encrypt=false
    local recipient=""
    local use_passphrase=true
    local user_password=""
    local auto_generate=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--encrypt)
                encrypt=true
                shift
                ;;
            -m)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -m requires a method argument (age, gpg, or aes)"
                    return 1
                fi
                encrypt_method="$2"
                shift 2
                ;;
            -r)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -r requires a recipient argument"
                    return 1
                fi
                recipient="$2"
                use_passphrase=false
                shift 2
                ;;
            -p)
                if [[ -z "$2" || "$2" == -* ]]; then
                    echo "Error: -p requires a password argument"
                    return 1
                fi
                user_password="$2"
                shift 2
                ;;
            -g)
                auto_generate=true
                shift
                ;;
            -*)
                echo "Unknown option: $1"
                return 1
                ;;
            *)
                break
                ;;
        esac
    done

    # Check if any files were provided
    if [[ $# -eq 0 ]]; then
        echo "Error: No files specified for upload."
        echo "Usage: fsend [-e|--encrypt] [-m method] [-r recipient] path1 path2 ..."
        return 1
    fi

    # Debug: Print the arguments
    echo "Files to upload: $@"

    # Handle multiple files
    local files=("$@")
    local upload_file=""
    
    if [[ "${#files[@]}" -gt 1 ]]; then
        # Set the zip_file variable for the outer scope
        zip_file="./ffsend_$(date +%Y%m%d%H%M%S).zip"
        echo "Creating zip file with multiple files..."
        zip -q "$zip_file" "${files[@]}"
        upload_file="$zip_file"
    else
        # Single file case - use the first argument directly
        upload_file="$1"
        echo "Single file mode: $upload_file"
    fi

    # Verify the file exists before proceeding
    if [[ ! -f "$upload_file" ]]; then
        echo "Error: File '$upload_file' does not exist."
        return 1
    fi

    if $encrypt; then
        # Encryption handling
        if [[ "${#files[@]}" -eq 1 && "$zip_file" == "" ]]; then
            # For single file encryption, create a temporary zip first
            zip_file="./ffsend_$(date +%Y%m%d%H%M%S).zip"
            echo "Creating temporary zip for encryption..."
            zip -q "$zip_file" "$upload_file"
            upload_file="$zip_file"
        fi
        
        local encrypted_file=""
        
        # Handle password for all encryption methods except when using recipient key
        if [[ -z "$user_password" && "$use_passphrase" == true ]]; then
            if [[ "$encrypt_method" != "age" || "$auto_generate" == false ]]; then
                # For non-age methods or when not auto-generating, prompt for password
                if [[ "$auto_generate" == false ]]; then
                    # Prompt for password
                    echo "Enter password for encryption (leave empty to auto-generate):"
                    read -s user_password
                    
                    if [[ -n "$user_password" ]]; then
                        echo "Confirm password:"
                        read -s password_confirm
                        
                        if [[ "$user_password" != "$password_confirm" ]]; then
                            echo "Error: Passwords do not match."
                            [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
                            return 1
                        fi
                    fi
                fi
                
                # If user didn't enter a password or auto-generate is true, generate one
                if [[ -z "$user_password" || "$auto_generate" == true ]]; then
                    # Generate a secure random password using diceware for better memorability
                    if command -v diceware &> /dev/null; then
                        user_password=$(diceware -n 3 -c -s 1)
                    else
                        user_password=$(openssl rand -base64 12)
                    fi
                    echo "Generated password: $user_password"
                    echo "Save this password securely - you'll need it to decrypt the file."
                fi
                
                # For age encryption with manual password, we'll use this later
                if [[ "$encrypt_method" == "age" ]]; then
                    password="$user_password"
                fi
            fi
        fi
        
        # Determine encryption method and encrypt
        case "$encrypt_method" in
            age)
                encrypted_file="${upload_file}.age"
                echo "Encrypting with age..."
                
                if $use_passphrase; then
                    # Use age with passphrase
                    echo "Using passphrase encryption..."
                    
                    if [[ -n "$password" && "$auto_generate" == false ]]; then
                        # Use the manually entered password
                        echo "Using manually entered passphrase"
                        echo "$password" | age --passphrase -o "$encrypted_file" "$upload_file"
                    else
                        # Let age generate a passphrase
                        local age_output=$(age -p -o "$encrypted_file" "$upload_file" 2>&1)
                        echo "$age_output"  # Display the output to the user
                        
                        # Extract the passphrase using regex
                        if [[ "$age_output" =~ using\ autogenerated\ passphrase\ \"([^\"]+)\" ]]; then
                            password="${BASH_REMATCH[1]}"
                            echo "Captured passphrase: $password"
                        else
                            echo "Warning: Could not capture the passphrase automatically."
                            password="[See the passphrase displayed above]"
                        fi
                    fi
                else
                    echo "Using recipient key encryption..."
                    age -r "$recipient" -o "$encrypted_file" "$upload_file"
                    password="[Encrypted with recipient's public key]"
                fi
                ;;
                
            gpg)
                encrypted_file="${upload_file}.gpg"
                echo "Encrypting with GPG..."
                
                if [[ -n "$user_password" ]]; then
                    # Use the provided or generated password
                    echo "Using provided/generated password for GPG encryption"
                    # Create a temporary batch file for GPG with individual echo commands
                    local batch_file=$(mktemp)
                    
                    # Write each line separately with proper indentation
                    echo "%echo Encrypting with GPG" > "$batch_file"
                    echo "%no-protection" >> "$batch_file"
                    echo "%passphrase $user_password" >> "$batch_file"
                    echo "%no-ask-passphrase" >> "$batch_file"
                    echo "%no-symkey-cache" >> "$batch_file"
                    
                    # Use batch mode for GPG
                    gpg --batch --yes --passphrase "$user_password" --output "$encrypted_file" --symmetric "$upload_file"
                    rm -f "$batch_file"
                    password="$user_password"
                else
                    echo "Please enter a passphrase for GPG encryption"
                    gpg --output "$encrypted_file" --symmetric "$upload_file"
                    password="[Use the password you entered during encryption]"
                fi
                ;;
                
            aes)
                encrypted_file="${upload_file}.aes"
                echo "Encrypting with OpenSSL AES-256-CBC..."
                
                if [[ -n "$user_password" ]]; then
                    # Use the provided or generated password
                    echo "Using provided/generated password for AES encryption"
                    # Use echo to provide the password to openssl
                    echo "$user_password" | openssl enc -aes-256-cbc -salt -in "$upload_file" -out "$encrypted_file" -pass stdin
                    password="$user_password"
                else
                    echo "Please enter a passphrase for AES encryption"
                    openssl enc -aes-256-cbc -salt -in "$upload_file" -out "$encrypted_file"
                    password="[Use the password you entered during encryption]"
                fi
                ;;
                
            *)
                echo "Error: Invalid encryption method '$encrypt_method'. Use age, gpg, or aes."
                [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
                return 1
                ;;
        esac
        
        # Verify encrypted file exists
        if [[ ! -f "$encrypted_file" ]]; then
            echo "Error: Encryption failed. Encrypted file not created."
            # Clean up zip file
            [[ -n "$zip_file" && -f "$zip_file" ]] && rm -f "$zip_file"
        return 1
        fi
        
        echo "Uploading encrypted file: $encrypted_file"
        # Capture the upload output and display it
        local upload_output=$(ffsend upload "$encrypted_file")
        echo "$upload_output"
        
        # Extract the link using a more reliable method
        if [[ "$upload_output" =~ https://[^[:space:]]+ ]]; then
            link="${BASH_REMATCH[0]}"
        else
            echo "Warning: Could not capture the download link automatically."
            link="[See the link displayed above]"
        fi
        
        echo "Removing encrypted file..."
        rm -f "$encrypted_file"
    else
        # Non-encrypted upload
        echo "Uploading file without encryption: $upload_file"
        # Capture the upload output and display it
        local upload_output=$(ffsend upload "$upload_file")
        echo "$upload_output"
        
        # Extract the link using a more reliable method
        if [[ "$upload_output" =~ https://[^[:space:]]+ ]]; then
            link="${BASH_REMATCH[0]}"
        else
            echo "Warning: Could not capture the download link automatically."
            link="[See the link displayed above]"
        fi
    fi

    # Clean up zip file if it was created
    if [[ -n "$zip_file" && -f "$zip_file" ]]; then
        echo "Cleaning up temporary zip file..."
        rm -f "$zip_file"
    fi

    echo "Upload completed. Use 'ffsend ls' to see your uploaded files."
    
    # Output sharing information
    if $encrypt; then
        echo "Copy and paste the following into your message to the receiver:"
        echo "Link: $link"
        echo "Password: $password"
        echo "Encryption method: $encrypt_method"
        echo "Command to decrypt the file: "
        if [[ "$encrypt_method" == "age" ]]; then
            echo "age -d -o $upload_file $encrypted_file"
        elif [[ "$encrypt_method" == "gpg" ]]; then
            echo "gpg --decrypt $encrypted_file"
        elif [[ "$encrypt_method" == "aes" ]]; then
            echo "openssl enc -aes-256-cbc -d -in $encrypted_file -out $upload_file -pass pass:$password"
        fi
    else
        echo "Share this link with the recipient: $link"
    fi
}

transfer_file(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: transfer_file path1 path2 ..."
        printf "This command uses rsync to transfer files or directories to a remote host.\n"
        printf "The remote host, port, and base remote path are read from the ~/.env file.\n"
        printf "An example ~/.env file is provided at $HOME/macos/.env-template\n"
        return 0
    fi

    # Source the .env file to load variables
    if [[ -f ~/.env ]]; then
        source ~/.env
    else
        echo "Error: ~/.env file not found"
        echo -n "Do you want to create a new ~/.env file? (y/n):(default:n) "
        read create_env
        if [[ $create_env =~ ^[Yy]$ ]]; then
            echo "REMOTE_HOST=username@192.168.1.xxx" >> $HOME/.env
            echo "REMOTE_PORT=2220" >> $HOME/.env
            echo "REMOTE_BASE_PATH=/path/to/directory" >> $HOME/.env
            echo "source ~/.zshrc" >> $HOME/.env
            echo "~/.env file created, please edit the file with the correct remote host, port, and base remote path"
            return 1
        else
            return 1
        fi
    fi
    # clean up files and directories before starting. 
    for path in "$@"; do
        # remove spaces and special characters from the variables
        path=$(echo "$path" | tr -cd '[:alnum:]_.-')
        # ask if the files should be scanned for viruses
        echo "Do you want to scan the file '$path' for viruses? (y/n):(default:n) "
        read scan_file
        if [[ $scan_file =~ ^[Yy]$ ]]; then
            # scan the file for viruses
            scan_file "$path"
        fi
    done
     

    # Check if vars are set
    if [[ -z "$REMOTE_HOST" || -z "$REMOTE_PORT" || -z "$REMOTE_BASE_PATH" ]]; then
        echo "Error: Remote host, port, or base remote path not set in ~/.env file"
        echo "Please set the variables in the ~/.env file"
    # prompt the user for the variables that are missing loop through the variables and prompt the user for the missing ones
    for var in REMOTE_HOST REMOTE_PORT REMOTE_BASE_PATH; do
        if [[ -z "${!var}" ]]; then
            echo "Please enter the value for $var:"
            read -s "${!var}"
        fi
    done
        return 1
    fi

    for path in "$@"; do
        if [[ ! -e "$path" ]]; then
            echo "Error: '$path' does not exist"
            continue
        fi
        # Set the target path on the remote host
        local target_path="$REMOTE_BASE_PATH/$(basename "$path")"
        if [[ -d "$path" ]]; then # if the path is a directory
            # create the directory on the remote host if it doesn't exist
            command ssh -p "$REMOTE_PORT" "$REMOTE_HOST" "mkdir -p \"$target_path\""
            # transfer the directory to the remote host
            /opt/homebrew/bin/rsync -avz --progress -e "ssh -p $REMOTE_PORT" "$path/" "$REMOTE_HOST:$target_path/" || echo "Failed to transfer directory '$path'"
        elif [[ -f "$path" ]]; then # if the path is a file
            # create the directory on the remote host if it doesn't exist
            command ssh -p "$REMOTE_PORT" "$REMOTE_HOST" "mkdir -p \"$REMOTE_BASE_PATH\""
            # transfer the file to the remote host
            /opt/homebrew/bin/rsync -avz --progress -e "ssh -p $REMOTE_PORT" "$path" "$REMOTE_HOST:$REMOTE_BASE_PATH/" || echo "Failed to transfer file '$path'"
        else
            echo "Error: '$path' is neither a file nor a directory"
        fi
    done
}