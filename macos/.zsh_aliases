# ----------------------
# Git Aliases
# ----------------------
alias gita="git_add"
alias gitcg="git_commit"
alias gitp="git push"
alias gitpl="git pull"
alias gitco="git checkout"
alias gitcb="git checkout -b"
alias gitlog="git log --oneline --graph --all"

# ----------------------
# Git Functions
# ----------------------
git_commit(){
    if [[ -z "$1" ]]; then
        echo "No commit message provided. Opening editor for interactive commit message."
        git commit
    else
        git commit -m "$1"
    fi
}

git_add(){
    if [[ -z "$1" ]]; then
        echo "No files specified. Defaulting to 'git add .'"
        git add .
    else
        git add "$@"
    fi
}

update_git_repos(){
    # Default variables
    search_path="$HOME/Documents/Git/"  # Default search path
    exclude_paths=()                   # Array to store excluded paths

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --search-path)
                search_path="$2"
                shift 2
                ;;
            --exclude)
                exclude_paths+=("$2")
                shift 2
                ;;
            *)
                echo "Unknown argument: $1"
                return 1
                ;;
        esac
    done

    # Build the find command
    find_cmd="find \"$search_path\" -type d -name \".git\""

    for exclude in "${exclude_paths[@]}"; do
        find_cmd+=" ! -path \"$exclude/*\""
    done

    find_cmd+=" -print"

    # Execute the find command and update repositories
    eval "$find_cmd" | while IFS= read -r gitdir; do
        repo_dir=$(dirname "$gitdir")

        # Ensure the directory is marked safe for Git operations
        git config --global --add safe.directory "$repo_dir"

        echo "Updating repository in $repo_dir"
        cd "$repo_dir" || {
            echo "Failed to access $repo_dir"
            continue
        }
        git pull --rebase || echo "Failed to update $repo_dir"
    done
}

## Git Clone Function
### Usage: git_clone repo_name or url
### from any directory will clone the repo to the correct directory in the ~/Documents/Git/ directory
git_clone(){
    if [[ -z "$1" ]]; then
        echo "No repository name or URL provided"
        return 1
    fi

    # Determine the repo name from the URL or input
    if [[ "$1" =~ ^https?:// || "$1" =~ ^git@ ]]; then
        repo_name=$(basename "$1" .git)
        repo_url="$1"
    else
        repo_name=$(basename "$1")
        repo_url="https://github.com/your-username/$repo_name.git"
    fi

    # Check if the repo name is a valid directory name
    if [[ ! "$repo_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo "Invalid repository name: $repo_name"
        return 1
    fi

    # Check if the repo name already exists in the ~/Documents/Git/ directory
    if [[ -d "$HOME/Documents/Git/$repo_name" ]]; then
        echo "Repository already exists: $repo_name"
        return 1
    fi

    # Clone the repo to the ~/Documents/Git/ directory
    git clone "$repo_url" "$HOME/Documents/Git/$repo_name" || {
        echo "Failed to clone repository"
        return 1
    }

    # Change to the cloned repository directory
    cd "$HOME/Documents/Git/$repo_name" || {
        echo "Failed to access $repo_name directory"
        return 1
    }
    # print the current directory and list the files
    pwd
    ls -l
    #prompt user to open the repo dir (./) in vs code or cursor
    echo "Do you want to open the repository? (Y/n): "
    read open_in
    open_in=${open_in:-y}  # Default to 'y' if no input is provided

    if [[ $open_in =~ ^[Yy]$ ]]; then
        if command -v code &> /dev/null && command -v cursor &> /dev/null; then
            echo "Both VS Code and Cursor are available. Open with (v)scode or (c)ursor? (v/c): "
            read editor_choice
            editor_choice=${editor_choice:-v}  # Default to 'v' if no input is provided
            if [[ $editor_choice == "v" ]]; then
                code .
            elif [[ $editor_choice == "c" ]]; then
                cursor .
            fi
        elif command -v code &> /dev/null; then
            code .
        elif command -v cursor &> /dev/null; then
            cursor .
        else
            echo "Neither VS Code nor Cursor is available."
        fi
    fi
}
# ----------------------
# Navigation and File Management Aliases
# ----------------------
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias mkdir="mkdir -p"
alias rmr="rm -rf"
alias untar="tar -zxvf"
alias tarx="tar -xvf"
#TODO: zipfile function
zipfile(){
    # usage: zipfile name file_or_dir1 file_or_dir2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: zipfile name_of_zip_file file_or_dir1 file_or_dir2 ..."
        return 0
    fi
    # check if args are passed
    # check if name is passed or if file or dir is passed
    # If name is passed then zip the file or dir with the name
    # if no name is passed then zip the file or dir with the name of the file or dir
    # if multiple files or dirs are passed then zip them all with the name of the first file or dir + more + .zip
}

## Make Directory and cd to it if only one arg is passed else just make the dir
mcd(){
    if [[ -z "$1" ]]; then
        echo "No directory name provided"
        return 1
    # elif only one arg is passed then make the dir and cd to it
    elif [[ -n "$1" ]]; then
        mkdir -p "$1" && cd "$1"
        pwd # print the current directory
    #else if multiple args are passed then make the dirs and list them
    elif [[ -n "$@" ]]; then
        mkdir -p "$@" && ls -l "$@"
    fi
}

#All updates on macos including brew, macos,git function updates
update_all(){
    sudo echo "Updating brew" # using sudo with echo to get user password , sudo used softwareupdate
    brew update && brew upgrade && brew cleanup && brew doctor
    echo "Updating macos"
    sudo softwareupdate --install --all
    echo "Updating git functions"
    update_git_repos
    echo "Clearing cache"
    clear
}
# ----------------------
# Applications Aliases
# ----------------------
setup_profiles(){
    mkdir -p $HOME/Profiles
    cd $HOME/Profiles
}
alias run-matrix="run-element"
alias run-irregular="run-element irregularchat"
run-element(){
    # usage: run-element
    # open element desktop in the default browser
    # if a profile is passed then use it
    setup_profiles
    /Applications/Element.app/Contents/MacOS/Element --profile "$1"&
    cd - # go back to the previous directory
}

run-firefox(){
    # usage: run-firefox
    # open firefox in the default browser
    # if a profile is passed then use it 
    setup_profiles
    /Applications/Firefox.app/Contents/MacOS/firefox --profile "$1" --new-window "https://sso.irregularchat.com"&
    cd - # go back to the previous directory
}

run-discord(){
    # usage: run-discord
    # open discord in the default browser
    # if a profile is passed then use it
    setup_profiles
    /Applications/Discord.app/Contents/MacOS/Discord --profile "$1"&
    cd - # go back to the previous directory
}
# command line keepassxc
alias kp="keepassxc"
# Open database in keepassxc
alias run-kp="kp --db $1"

#general passphrase with diceware
#3 words, symbols, numbers
alias gen-passphrase="diceware -n 3 -w 3 -s 3 -d 3"
# ----------------------
# Security Tools Aliases
# ----------------------
alias json="jq ."
alias http="curl -I"
alias ports="netstat -tuln"

scan_ports(){
    #usage: scan_ports ip_or_host
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: scan_ports ip_or_host"
        return 0
    fi
    # if no ip_or_host is passed then use the router ip 
    if [[ -z "$1" ]]; then
        local_ip=$(ifconfig | grep "inet " | grep -v 127.0.0.1 | awk '{print $2}' | head -n 1)
        ip_or_host=$local_ip
    else
        ip_or_host=$1
    fi
    #check if package is installed
    if ! command -v nmap &> /dev/null; then
        echo "Error: nmap is not installed"
        #prompt to install if yes install and continue else return 1
        install_nmap="n"
        echo -n "Do you want to install nmap? (y/n): " 
        read install_nmap
        if [[ $install_nmap =~ ^[Yy]$ ]]; then
            brew install nmap
            echo "nmap installed, continuing with scan"
        else
            return 1
        fi
    fi
    sudo nmap -sS -Pn $1
}
# ----------------------
# Helper Functions
# ----------------------
# Colorize the `ls` output and setup useful aliases
export LS_OPTIONS='--color=auto'
alias ls='ls $LS_OPTIONS'
alias ll='ls -lh $LS_OPTIONS'        # Detailed list view
alias la='ls -lha $LS_OPTIONS'       # Show hidden files
alias l='ls -lA $LS_OPTIONS'         # Short list view with hidden files
alias lt='ls -strhal $LS_OPTIONS'       # Sort by date, most recent last

# Safe aliases to prevent accidental file overwrites or deletions
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Navigation Function
# Fast directory navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."

# change dir and List Directory Contents
cdl(){
  if [ -n "$1" ]; then
    cd "$1" && ll
  else
    cd ~ && ll
  fi
}

# create backup of a file or directory
backup(){
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  
  # take files, dictionaries as arguments get full path as needed many args possible
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done
}
# Searching 
# Grep aliases and functions
alias grep='grep -i --color=auto "$@"' # Ignore case and colorize output and pass all arguments to grep in quotes
alias grepv='grep -vi --color=auto' # Ignore case, invert match, and colorize output

# Find aliases and functions
alias findf='find . -type f -name' # Find files by name
alias findd='find . -type d -name' # Find directories by name

#TODO
# findex(){
#   # Skip if being sourced (zsh-specific check)
#   if [[ ${zsh_eval_context[-1]} == "file" ]]; then
#     return 0
#   fi
  
  # Show help menu if -h or --help is passed
#   if [[ "$1" == "-h" || "$1" == "--help" ]]; then
#     echo "Usage: findex <pattern> <command> [args...]"
#     echo "Examples:"
#     echo "  findex '*.txt' ls -l"
#     echo "  findex '*.php' nano"
#     echo "  findex '*.sh' chmod 755"
#     echo "  findex '*.log' grep 'error'"
#     echo "  findex '*.txt' sed 's/old/new/g'"
#     return 0
#   fi

  # Need at least pattern and command
#   if [[ $# -lt 2 ]]; then
#     echo "Error: Missing command. See 'findex --help' for usage."
#     return 1
#   fi

#   local pattern="$1"
#   shift # Remove pattern from arguments
#   find . -iname "$pattern" -exec "$@" \;
# }

# Nano Editor settings
alias nanozsh='nano ~/.zshrc'     # Open the bashrc file in nano
alias reset='reset_file'          # Custom function to erase a file content then open with nano

# Nano Functions
reset_file(){
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
  # Reset the file content to an empty string
  # use the backup function to create a backup of the file before erasing
  #handle one or multiple files
  # catch escapes and errors to handle prompting user to restore backup or delete
  for file in "$@"; do
    backup "$file"
    echo "" > "$file"
    echo "File content backed up and erased."
    echo "Opening $file in nano editor"
    #echo >> the filename to the file with a # at the beginning
    echo "# $file" >> "$file"
    #sleep half a second
    sleep 0.5
    nano "$file"
    # prompt user to restore backup or delete
    ls $file$backup_name
    # default to no
    see_diff="n"
    echo -n "Do you want to see the difference between the original and backup file? (y/n):(default:n) "
    read see_diff
    if [ "$see_diff" == "y" ]; then
      diff "$file" "$file$backup_name"
      restore_backup="n"
      echo -n "Do you want to restore the backup file? (y/n):(default:n) "
      read restore_backup
      if [ "$restore_backup" == "y" ]; then
        echo "This will delete any changes made to the original file"
        restore_backup_confirm="n"
        echo -n "Are you sure you want to restore the backup file? (y/n):(default:n) "
        read restore_backup_confirm
        if [ "$restore_backup_confirm" == "y" ]; then
          mv "$file$backup_name" "$file"
          echo "Backup file restored."
        fi
      fi
    fi
  done
}

# Docker Aliases
alias dc="docker compose"
alias docker-compose="dc" # alias for docker compose instead of docker-compose
alias dcu="dc pull && dc up -d" # pull and start the docker compose services
alias dcd="dc down" # stop the docker compose services
alias dcb="dcu --build" # build the docker compose services
alias dcp="dc pull" # pull the docker compose services
alias dcr="dcd && dcu" # stop and start the docker compose services
#purge docker compose services networks and volumes 
alias dcnet="docker network prune"
alias dcvol="docker volume prune"
alias dcpur="dcd && dcp && dcnet && dcvol" # stop and pull the docker compose services
alias d="docker" # alias for docker
alias dps="d ps"
alias dbash="d exec -it $1 /bin/bash"
alias dsh="d exec -it $1 /bin/sh"


# Networking shortcuts
alias ports='netstat -tulanp'  # List open ports
alias myip='curl ifconfig.me'  # Check external IP address

# Disk usage shortcuts
alias du='du -h --max-depth=1'  # Show disk usage in human-readable format
alias df='df -h'                # Show free disk space in human-readable format


# Menu with all functions in ~/.zsh_aliases and ~/.mac_functions.sh

show_func(){
    # usage: show_help function_name
    # show the help for a specific function
    cat ~/.zsh_aliases|grep "$1()"
}
alias show_function="show_func"
show_alias(){
    # usage: show_alias
    # show all the aliases in the ~/.zsh_aliases file
    cat ~/.zsh_aliases | grep -E "^alias " | cut -d '=' -f 1 | sort | uniq
}

show_help(){
    # usage: show_help function_name
    # show the help for a specific function
    grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" ~/.zsh_aliases
}

helpmenu(){
    echo "Help Menu:"
    echo "----------"
    echo "See all functions: show_function"
    echo "See all aliases: show_alias"
    echo "See help for a function: show_help function_name"
    echo "See help for an alias: show_help alias_name"
}

# ----------------------
# GitHub Repository Management
# ----------------------

create_repo(){
    # "Usage: create_repo repo_name"
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: create_repo repo_name"
        return 0
    fi
    
    if ! command -v gh &> /dev/null; then
        echo "Error: GitHub CLI 'gh' is not installed."
        install_gh="y"
        echo -n "Do you want to install GitHub CLI? (y/n):(default:y) "
        read install_gh
        if [[ $install_gh =~ ^[Yy]$ ]]; then
            brew install gh
            echo "GitHub CLI installed, continuing with repo creation"
        else
            echo "GitHub CLI not installed, you can install it with 'brew install gh' before running this function again"
            return 1
        fi
    fi

    repo_name=$(echo "$@" | tr ' ' '_')
    local base_dir="$HOME/Documents/Git"
    mkdir -p "$base_dir"

    use_gitignore="n"
    echo -n "Do you want to use a special .gitignore file? (y/n):(default:n) "
    read use_gitignore

    if [[ $use_gitignore =~ ^[Yy]$ ]]; then
        echo "Available gitignore templates:"
        echo "1) Python"
        echo "2) Node/JavaScript"
        echo "3) Markdown"
        echo "4) Shell"
        echo "5) None (basic repo setup)"
        
        echo -n "Select a template (1-5): "
        read template_choice

        case $template_choice in
            1)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Python || return 1
                ;;
            2)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Node || return 1
                ;;
            3)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Markdown || return 1
                ;;
            4)
                gh repo create --add-readme "$repo_name" --private --license=mit --gitignore=Shell || return 1
                ;;
            *)
                gh repo create --add-readme "$repo_name" --private --license=mit || return 1
                ;;
        esac
    else
        gh repo create --add-readme "$repo_name" --private --license=mit || return 1
    fi

    git clone "https://github.com/$(gh api user | jq -r '.login')/$repo_name.git" "$base_dir/$repo_name" || return 1
    cd "$base_dir/$repo_name" || return 1
    echo "# $repo_name" >> README.md
    git add README.md
    git commit -m "Initial commit"
    git branch -M main
    git push -u origin main

    echo "Repository $repo_name created and initialized successfully in $base_dir."
}

# ----------------------
# Python Virtual Environment Management
# ----------------------
# Python Aliases 
pyenv(){
  python3 -m venv env  # Create the virtual environment
  source env/bin/activate  # Activate the virtual environment (on Linux/Mac)
  pip install --upgrade pip  # Upgrade pip
  pip install -r requirements.txt  # Install dependencies
}

# Python Aliases 
pyserver(){
    # usage: pyserver file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: pyserver file1 file2 ..."
        return 0
    fi
    # check if python3 is installed
    if ! command -v python3 &> /dev/null; then
        echo "Error: Python 3 is not installed"
        echo "You can install it with:"
        echo 'brew install python'
        return 1
    fi
    # set port for the python server
    local port=8000
    # create a python server for the passed files or dir
    #get local ip
    local_ip=$(hostname -I | awk '{print $1}')
    # path for the server else use current dir
    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    # if no files passed in arg then use current dir
    if [ -n "$1" ]; then # if there are files passed in arg
        # create temp dir
        mkdir -p /tmp/pyserver
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/pyserver
        done
        # change dir to the temp dir
        cd /tmp/pyserver
        # start the python server
        python3 -m http.server $port
    else
        # use current dir
        cd .
        # start the python server
        python3 -m http.server $port
    fi
    
}

funnel() {
    # usage: funnel file1 file2 dir1 dir2 ...
    # On MacOS you must be using the open source tailscaled distribution to use the funnel command for files. 
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: funnel <target>"
        echo "Funnel enables you to share a local server on the internet using Tailscale."
        return 0
    fi
    local port=8080
    use_python=true #use this with MacOS or as needed

    # Check if tailscale is running
    if ! tailscale status &> /dev/null; then
        echo "Error: Tailscale is not running"
        echo "You can start it with: tailscale start"
        return 1
    fi

    # Use current directory if no target is specified
    if [ -z "$1" ]; then
        echo "No target specified. Using current directory as target."
        target="."
    else
        target="$@"
    fi

    # Function to clean up background processes
    cleanup() {
        echo "Cleaning up..."
        kill $server_pid
        exit 0
    }

    # Trap SIGINT (Ctrl+C) to run cleanup
    trap cleanup SIGINT

    # if multiple files passed in arg then create tmp dir and add those passed files or dir via ln to the temp server dir
    # if no files passed in arg then use current dir
    if [ -n "$1" ]; then # if there are files passed in arg
        # create temp dir
        mkdir -p /tmp/funnel
        # add files or dir to the temp dir
        for file in "$@"; do
            ln -s "$file" /tmp/funnel
        done
        # change dir to the temp dir
        cd /tmp/funnel
        if $use_python; then
            # start the python server
            python3 -m http.server $port&
            server_pid=$!
            # start the funnel
            tailscale funnel localhost:$port
        else
            # start the funnel
            tailscale funnel "$target"
        fi
        
    else
        # use current dir
        cd .
        if $use_python; then
            # start the python server
            python3 -m http.server $port&
            server_pid=$!
            # start the funnel
            tailscale funnel localhost:$port
        else
            # start the funnel
            tailscale funnel "$target"
        fi
    fi
}

alias tsf=funnel


# ----------------------
# MAC Address Management
# ----------------------

gen_mac_addr(){
    local mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g; s/.$//')
    echo "$mac"
}

change_mac_menu(){
    echo "Choose an option:"
    echo "1. Set a specific MAC address"
    echo "2. Set a random MAC address"
    echo "3. Restore original MAC address"
    echo -n "Enter your choice (1/2/3): "
    read choice

    case $choice in
        1)
            echo -n "Enter the new MAC address (e.g., E6:B8:BA:D2:41:07): "
            read mac_address
            echo -n "Enter the name of the new network location: "
            read location_name
            change_mac_address "$mac_address" "$location_name"
            ;;
        2)
            echo -n "Enter the name of the new network location: "
            read location_name
            mac_address=$(gen_mac_addr)
            change_mac_address "$mac_address" "$location_name"
            ;;
        3)
            restore_original_mac
            ;;
        *)
            echo "Invalid choice. Exiting."
            ;;
    esac
}

# ----------------------
# Matrix Setup
# ----------------------

matrix_setup(){
    # for a list of tags see https://github.com/spantaleev/matrix-docker-ansible-deploy/blob/a1efb78bcbc3a9205a59de3364f47192b6232f0f/docs/playbook-tags.md#L4
    ## Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        # show help
        echo "Usage: matrix_setup {full|1|normal|restart} {vars_directory_path}"
        return 0
    fi

    if ! command -v ansible-playbook &> /dev/null; then
        # show error
        echo "Error: 'ansible-playbook' is not installed."
        return 1
    fi
    # set mode to normal if no mode is passed
    local mode="${1:-normal}"
    # set vars file to the default path if no path is passed $HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com
    local vars_file="${2:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/host_vars/matrix.irregularchat.com/vars.yml}"
    # Fix: Go up three directories from vars file to reach inventory directory
    local hosts_file="$(dirname "$(dirname "$(dirname "$vars_file")")")/hosts"
    #set the setup.yml file to the directory above the inventory directory
    local setup_file="${hosts_file%/*/*}/setup.yml"
    # set the matrix repo path to the directory above the inventory directory
    local matrix_repo_path="${hosts_file%/*}/.."
    # check if vars file exists
    if [[ ! -f "$vars_file" ]]; then
        echo "Error: Vars file not found at $vars_file"
        return 1
    fi
    # check if hosts file exists
    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi
    # run the case statement
    case "$mode" in
        full|1)
            # full will update the repo and make roles then setup and start the services using all the tags
            # git pull && sudo make roles of the matrix repo without moving to the repo dir
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=install-all,setup-all,ensure-matrix-users-created,restart || return 1
            cd - # return to the previous directory
            ;;
        normal)
            # normal will update the repo and make roles then setup and start the services
            cd "$matrix_repo_path" && git pull && sudo make roles
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=setup-all,start || return 1
            cd - # return to the previous directory
            ;;
        restart)
            sudo ansible-playbook -i "$hosts_file" "$setup_file" --tags=restart || return 1
            cd - # return to the previous directory
            ;;
        *)
            echo "Usage: matrix_setup {full|1|normal|restart} [hosts_file_path]"
            return 1
            ;;
    esac
}

# ----------------------
# Matrix User Setup
# ----------------------

matrix_setup_user(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: matrix_setup_user username [password] [admin] [device_id] [hosts_file_path]"
        return 0
    fi

    if ! command -v curl &> /dev/null || ! command -v ansible-playbook &> /dev/null; then
        echo "Error: Required commands 'curl' or 'ansible-playbook' are not installed."
        return 1
    fi

    local username="$1"
    local password="${2:-$(openssl rand -base64 18)}"
    local admin="${3:-no}"
    local device_id="${4:-${username}_$(openssl rand -hex 3)}"
    local hosts_file="${5:-$HOME/Documents/Git/matrix-docker-ansible-deploy/inventory/hosts}"

    if [[ ! -f "$hosts_file" ]]; then
        echo "Error: Hosts file not found at $hosts_file"
        return 1
    fi

    sudo ansible-playbook -i "$hosts_file" setup.yml \
        --extra-vars="username=${username} password='${password}' admin=${admin}" \
        --tags=register-user

    curl -XPOST -d "{
        \"identifier\": { \"type\": \"m.id.user\", \"user\": \"${username}\" },
        \"password\": \"${password}\",
        \"type\": \"m.login.password\",
        \"device_id\": \"${device_id}\"
    }" 'https://matrix.irregularchat.com/_matrix/client/r0/login'
}

# ----------------------
# Cryptography
# ----------------------
setup_age(){
    # setup age directory and keys
    mkdir -p ~/.age
    #get username
    username=$(whoami)
    #if no argument passed for key name then use username
    if [[ -z "$1" ]]; then
        key_name="$username"
    else
        key_name="$1"
    fi
    
    #echo guidance on storying and using the age keys
    echo "Store the following keys in a secure location:"
    echo "Public key: ~/.age/keys/$key_name.pub"
    echo "Private key: ~/.age/keys/$key_name.key"
    echo "You will see a public key output to the screen that you can share with others"
    echo "For more information on age see https://github.com/FiloSottile/age"
    sleep 1
    # generate keys
    age-keygen -a -o ~/.age/keys/$key_name.key
    ls -l ~/.age/keys
}

scan_file(){
    # check if clamscan is installed
    if ! command -v clamscan &> /dev/null; then
        echo "Error: 'clamscan' is not installed."
        echo "You can install it with: brew install clamscan"
        return 1
    fi
    # check if the file exists
    if [[ ! -f "$path" ]]; then
        echo "Error: File not found at '$path'"
        return 1
    fi
    # update the virus database
    sudo freshclam
    # scan the file for viruses
    clamscan "$path"
}
clean_file(){
    # Check if a file path is provided
    if [[ -z "$1" ]]; then
        echo "Error: No file path provided."
        return 1
    fi

    # Use the provided file path
    local path="$1"
    # get full path
    local full_path=$(realpath "$path")

    # Remove spaces and special characters from the file name
    local clean_file=$(echo "$full_path" | tr -cd '[:alnum:]_.-')

    # Move the file to the new name
    mv "$full_path" "$clean_file"

    # Return the cleaned file name with full path
    echo "$clean_file"
}

encrypt_file(){
    # Check if age is installed, if not, install it
    if ! command -v age &> /dev/null; then
        echo "Error: 'age' is not installed."
        echo -n "Do you want to install 'age'? (y/n):(default:y) "
        read install_age
        if [[ $install_age =~ ^[Yy]$ ]]; then
            brew install age
        else
            return 1
        fi
    fi
    # disregard the first argument if it is -e or --encrypt
    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        shift
    fi

    # Initialize variables
    recipient=""
    use_passphrase=true
    #FIXME: this is not working as expected
    #grep: : age: No such file or directory
    # Error: Could not extract public key from /Users/username/.age/keys/username
    # # Check if ~/.age/keys directory exists
    # if [[ -d ~/.age/keys ]]; then
    #     # List the keys
    #     ls -l ~/.age/keys
    #     echo "Select a key to use for encryption:"
    #     select key_name in ~/.age/keys/*; do
    #         # Extract the public key from the selected key file
    #         recipient=$(grep ": age" "$key_name" | cut -d " " -f 4)
    #         if [[ -z "$recipient" ]]; then
    #             echo "Error: Could not extract public key from $key_name"
    #             return 1
    #         fi
    #         break
    #     done
    # else
    #     # Prompt user to create or use a passphrase
    #     echo -n "Do you want to use a passphrase for encryption? (y/n):(default:y) "
    #     read use_passphrase
    #     if [[ $use_passphrase =~ ^[Yy]$ ]]; then
    #         use_passphrase=true
    #     else
    #         use_passphrase=false
    #     fi
    # fi

    # Parse options
    while getopts "r:" opt; do # r is the recipient key
        case $opt in
            r)
                recipient="$OPTARG"
                use_passphrase=false
                ;;
            *)
                echo "Usage: encrypt_file [-r recipient] file1 file2 ..."
                return 1
                ;;
        esac
    done
    shift $((OPTIND -1)) # shift the arguments to the left to remove the options

    # Check if files are provided
    if [[ "$#" -eq 0 ]]; then
        echo "Error: No files provided for encryption."
        return 1
    fi

    # If multiple files are passed, zip them and encrypt the zip file
    if [[ "$#" -gt 1 ]]; then
        # zip the files
        zip_file="./$(basename "$1").zip"
        zip "$zip_file" "$@"
        files_to_encrypt="$zip_file"
    else
        # if only one file is passed then set the file to encrypt
        files_to_encrypt="$1"
    fi

    # Encrypt the file(s)
    if $use_passphrase; then #default is to use a passphrase
        age -p -o "${files_to_encrypt}.age" "$files_to_encrypt"
    else
        age -r "$recipient" -o "${files_to_encrypt}.age" "$files_to_encrypt"
        echo "Recipient key used for encryption: $recipient"
    fi

    # Clean up zip file if it was created
    if [[ -f "$zip_file" ]]; then
        rm "$zip_file"
    fi

    # Instructions for decryption
    echo "To decrypt the file with age, use the following command:"
    echo "age -d -i ~/.age/keys/$key_name.key -o ${files_to_encrypt%.*} ${files_to_encrypt}.age"
    echo "or"
    echo "age --decrypt --output ${files_to_encrypt%.*} ${files_to_encrypt}.age"
    echo ""
    echo "There is a graphical app called 'Destiny - Secure File Transfer' that can be used to send and receive files securely with wormhole"
}

# ----------------------
# File Transfer
# ----------------------


#wormhole alias
alias wh="wormhole"
alias wht="wh-transfer"
#transfer file with wormhole many or one file
wh-transfer(){
    trap '[[ -f "$zip_file" ]] && rm -rf "$zip_file"' EXIT INT

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: wh-transfer [-e|--encrypt] path1 path2 ..."
        echo "The default is to send the files as is"
        echo "-e or --encrypt will encrypt the files before sending using age, gpg, or aes"
        return 0
    fi

    encrypt_and_send() {
        local encrypt_tool="$1"
        shift
        local files=("$@")
        local zip_file="./wormhole_$(date +%Y%m%d%H%M%S).zip"
        zip "$zip_file" "${files[@]}"
        
        local encrypted_file="${zip_file}.age"
        if [[ "$encrypt_tool" == "gpg" ]]; then
            encrypted_file="${zip_file}.gpg"
            gpg --output "$encrypted_file" --symmetric "$zip_file"
        elif [[ "$encrypt_tool" == "aes" ]]; then
            encrypted_file="${zip_file}.aes"
            openssl enc -aes-256-cbc -salt -in "$zip_file" -out "$encrypted_file"
        else
            age -o "$encrypted_file" -p "$zip_file"
        fi

        wormhole send "$encrypted_file"
        rm -rf "$zip_file" "$encrypted_file"
    }

    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        shift
        if command -v age &> /dev/null; then
            encrypt_and_send "age" "$@"
        elif command -v gpg &> /dev/null; then
            encrypt_and_send "gpg" "$@"
        else
            encrypt_and_send "aes" "$@"
        fi
    else
        if [[ "$#" -gt 1 ]]; then
            local zip_file="./wormhole_$(date +%Y%m%d%H%M%S).zip"
            zip "$zip_file" "$@"
            wormhole send "$zip_file"
            rm -rf "$zip_file"
        else
            wormhole send "$@"
        fi
    fi
}

upload_to_pcloud(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: upload_to_pcloud [-e|-encrypt] source_path [remote_path]"
        echo "Uploads files or directories to pCloud using rclone."
        echo "Options:"
        echo "  -e, --encrypt   Encrypt the file(s) before uploading using 'age'."
        echo "If remote_path is not provided, files will be uploaded to the root of the remote."
        return 0
    fi

    # Default remote name for pCloud
    local remote="pcloud"
    # Check for encryption option
    local encrypt=false
    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        encrypt=true
        shift
    fi

    # Check for source_path
    if [[ -z "$1" ]]; then
        echo "Error: Source path is required."
        echo "Use 'upload_to_pcloud -h' for help."
        return 1
    fi
    local source_path="$1"
    shift

    # Set the remote path or use the root of the remote
    local remote_path="$1"
    if [[ -z "$remote_path" ]]; then
        remote_path="/"
    fi

    # Debug: Print paths
    echo "Source path: $source_path"
    echo "Remote path: $remote_path"

    # Check if the source path exists
    if [[ ! -e "$source_path" ]]; then
        echo "Error: Source path '$source_path' does not exist."
        return 1
    fi

    # Encrypt the file if requested
    if [[ "$encrypt" == true ]]; then
        echo "Encrypting file..."
        encrypt_file "$source_path"
        local encrypted_path="${source_path}.age"
        echo "Uploading encrypted file to pCloud..."
        rclone copy "$encrypted_path" "$remote:$remote_path" -P || {
            echo "Error: Failed to upload encrypted file to pCloud."
            return 1
        }
        rm "$encrypted_path" # Clean up encrypted file
    else
        # Upload directly
        echo "Uploading '$source_path' to pCloud..."
        rclone copy "$source_path" "$remote:$remote_path" -P || {
            echo "Error: Failed to upload to pCloud."
            return 1
        }
    fi

    echo "Upload to pCloud completed successfully!"
}

# ffsend file transfer including encryption option
fsend(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: fsend [-e|--encrypt] path1 path2 ..."
        echo "The default is to send the files as is"
        echo "-e or --encrypt will encrypt the files before sending using age, gpg, or aes"
        return 0
    fi

    # Check if ffsend is installed
    if ! command -v ffsend &> /dev/null; then
        echo "Error: 'ffsend' is not installed."
        echo "You can install it with: brew install ffsend"
        return 1
    fi

    # Function to encrypt files
    encrypt_files() {
        local encrypt_tool="$1"
        shift
        local files=("$@")
        local zip_file="./ffsend_$(date +%Y%m%d%H%M%S).zip"
        zip "$zip_file" "${files[@]}"

        local encrypted_file="${zip_file}.age"
        case "$encrypt_tool" in
            gpg)
                encrypted_file="${zip_file}.gpg"
                gpg --output "$encrypted_file" --symmetric "$zip_file"
                ;;
            aes)
                encrypted_file="${zip_file}.aes"
                openssl enc -aes-256-cbc -salt -in "$zip_file" -out "$encrypted_file"
                ;;
            *)
                age -o "$encrypted_file" -p "$zip_file"
                ;;
        esac

        echo "$encrypted_file"
    }

    # Check for encryption option
    local encrypt=false
    if [[ "$1" == "-e" || "$1" == "--encrypt" ]]; then
        encrypt=true
        shift
    fi

    # Handle multiple files
    local files=("$@")
    if [[ "${#files[@]}" -gt 1 ]]; then
        local zip_file="./ffsend_$(date +%Y%m%d%H%M%S).zip"
        zip "$zip_file" "${files[@]}"
        files=("$zip_file")
    fi

    if $encrypt; then
        local encrypted_file
        if command -v age &> /dev/null; then
            encrypted_file=$(encrypt_files "age" "${files[@]}")
        elif command -v gpg &> /dev/null; then
            encrypted_file=$(encrypt_files "gpg" "${files[@]}")
        else
            encrypted_file=$(encrypt_files "aes" "${files[@]}")
        fi
        ffsend send "$encrypted_file"
        rm -rf "$encrypted_file"
    else
        ffsend send "${files[@]}"
    fi

    # Clean up zip file if it was created
    [[ -f "$zip_file" ]] && rm -rf "$zip_file"

    # Check if the files were sent successfully
    if ffsend list | grep -q "$(basename "${files[0]}")"; then
        echo "Files sent successfully!"
    else
        echo "Error: Files were not sent successfully."
        return 1
    fi
}

transfer_file(){
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: transfer_file path1 path2 ..."
        printf "This command uses rsync to transfer files or directories to a remote host.\n"
        printf "The remote host, port, and base remote path are read from the ~/.env file.\n"
        printf "An example ~/.env file is provided at $HOME/macos/.env-template\n"
        return 0
    fi

    # Read .env file for the remote host, port, and base remote path if file exists
    if [[ -f ~/.env ]]; then
        # Use source to load variables directly
        REMOTE_HOST=$(grep "REMOTE_HOST=" ~/.env | cut -d '=' -f 2)
        REMOTE_PORT=$(grep "REMOTE_PORT=" ~/.env | cut -d '=' -f 2)
        REMOTE_BASE_PATH=$(grep "REMOTE_BASE_PATH=" ~/.env | cut -d '=' -f 2)
    else
        echo "Error: ~/.env file not found"
        echo -n "Do you want to create a new ~/.env file? (y/n):(default:n) "
        read create_env
        if [[ $create_env =~ ^[Yy]$ ]]; then
            echo "REMOTE_HOST=username@192.168.1.xxx" >> ~/.env
            echo "REMOTE_PORT=2220" >> ~/.env
            echo "REMOTE_BASE_PATH=/path/to/directory" >> ~/.env
            echo "source ~/.zshrc" >> ~/.env
            echo "~/.env file created, please edit the file with the correct remote host, port, and base remote path"
            return 1
        else
            return 1
        fi
    fi

    # Check if vars are set
    if [[ -z "$REMOTE_HOST" || -z "$REMOTE_PORT" || -z "$REMOTE_BASE_PATH" ]]; then
        echo "Error: Remote host, port, or base remote path not set in ~/.env file"
        return 1
    fi

    # Check if can connect to remote host
    # if ! command ssh -q -p "$REMOTE_PORT" "$REMOTE_HOST" "exit"; then
    #     echo "Error: Cannot connect to remote host"
    #     return 1
    # fi

    for path in "$@"; do
        if [[ ! -e "$path" ]]; then
            echo "Error: '$path' does not exist"
            continue
        fi
        # Set the target path on the remote host
        local target_path="$REMOTE_BASE_PATH/$(basename "$path")"
        if [[ -d "$path" ]]; then
            command ssh -p "$REMOTE_PORT" "$REMOTE_HOST" "mkdir -p \"$target_path\""
            /opt/homebrew/bin/rsync -avz --progress -e "ssh -p $REMOTE_PORT" "$path/" "$REMOTE_HOST:$target_path/" || echo "Failed to transfer directory '$path'"
        elif [[ -f "$path" ]]; then
            command ssh -p "$REMOTE_PORT" "$REMOTE_HOST" "mkdir -p \"$REMOTE_BASE_PATH\""
            /opt/homebrew/bin/rsync -avz --progress -e "ssh -p $REMOTE_PORT" "$path" "$REMOTE_HOST:$REMOTE_BASE_PATH/" || echo "Failed to transfer file '$path'"
        else
            echo "Error: '$path' is neither a file nor a directory"
        fi
    done
}