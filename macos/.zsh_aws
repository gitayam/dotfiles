# Disable history expansion to prevent issues with ! in commands
if [[ -n "$ZSH_VERSION" ]]; then # Only set for zsh
  setopt NO_BANG_HIST
fi

# AWS Zsh helper functions for IAM management and environment loading

# Load environment variables from .env file
load_env() {
  if [[ -f .env ]]; then
    source .env
    echo "Environment variables loaded from .env"
  else
    echo "‚ö†Ô∏è  .env not found"
    return 1
  fi
}

alias awshelp="aws_command_list | less -R"

# Helper function to run AWS commands with proper profile handling
run_aws_cmd() {
    # First argument is the command, rest are passed through
    local cmd="$1"
    shift
    
    # Check if we have AWS credentials in the environment
    if [[ -n "$AWS_ACCESS_KEY_ID" && -n "$AWS_SECRET_ACCESS_KEY" ]]; then
        # Use the environment variables directly
        aws "$cmd" "$@"
        return $?
    fi
    
    if [[ -n "$AWS_PROFILE" ]]; then
        # Check if the profile exists
        if ! aws configure list-profiles 2>/dev/null | grep -q "^${AWS_PROFILE}$"; then
            echo "‚ö†Ô∏è The config profile ($AWS_PROFILE) could not be found"
            echo "Available profiles:"
            aws configure list-profiles 2>/dev/null || echo "No profiles found"
            
            echo -n "Would you like to enter temporary credentials? (y/n): "
            read use_temp
            if [[ "$use_temp" == "y" ]]; then
                # Prompt for temporary credentials
                echo "Enter temporary AWS credentials:"
                echo -n "AWS Access Key ID: "
                read temp_key
                echo -n "AWS Secret Access Key: "
                read -s temp_secret
                echo ""
                echo -n "AWS Session Token (optional, press Enter to skip): "
                read temp_token
                
                # Export temporary credentials
                export AWS_ACCESS_KEY_ID="$temp_key"
                export AWS_SECRET_ACCESS_KEY="$temp_secret"
                if [[ -n "$temp_token" ]]; then
                    export AWS_SESSION_TOKEN="$temp_token"
                fi
                
                # Unset profile to use environment variables instead
                unset AWS_PROFILE
                
                echo "Using temporary credentials for this command"
                aws "$cmd" "$@"
                return $?
            else
                echo -n "Would you like to create this profile now? (y/n): "
                read create_profile
                if [[ "$create_profile" == "y" ]]; then
                    aws configure --profile "$AWS_PROFILE"
                    # Try again with the newly created profile
                    aws "$cmd" "$@" --profile "$AWS_PROFILE"
                    return $?
                else
                    echo "Operation cancelled. No valid AWS credentials available."
                    return 1
                fi
            fi
        else
            # Profile exists, use it
            aws "$cmd" "$@" --profile "$AWS_PROFILE"
            return $?
        fi
    else
        # No profile specified, use default credentials
        aws "$cmd" "$@"
        return $?
    fi
}

# Function to check AWS profile and credentials
aws_check_profile() {
  local profile="$1"
  
  if [[ -z "$profile" ]]; then
    # If no profile specified, use AWS_PROFILE from environment or "default"
    profile="${AWS_PROFILE:-default}"
  fi
  
  echo "Checking AWS profile: $profile"
  
  # Check if the profile is configured in credentials file
  if ! aws configure list --profile "$profile" &>/dev/null; then
    echo "‚ùå Profile '$profile' is not properly configured"
    echo "Run 'aws configure --profile $profile' to set it up"
    return 1
  fi
  
  # Check if we can make authenticated calls
  echo "Verifying credentials for profile '$profile'..."
  if ! aws sts get-caller-identity --profile "$profile" &>/dev/null; then
    echo "‚ùå Authentication failed for profile '$profile'"
    echo "Your credentials might be expired or invalid"
    return 1
  fi
  
  # Display information about the profile
  echo "‚úÖ AWS profile '$profile' is properly configured"
  echo "Current identity:"
  aws sts get-caller-identity --profile "$profile"
  
  # Check if this profile has proper IAM permissions
  echo "Testing IAM permissions..."
  if ! aws iam list-users --max-items 1 --profile "$profile" &>/dev/null; then
    echo "‚ö†Ô∏è This profile may not have IAM management permissions"
    echo "IAM operations might fail with this profile"
  else
    echo "‚úÖ Profile has IAM permissions"
  fi
  
  # Export this profile for other functions to use
  export AWS_PROFILE="$profile"
  echo "Set AWS_PROFILE=$profile for this session"
  return 0
}

# Function to list available AWS profiles
aws_list_profiles() {
  if [[ ! -f ~/.aws/credentials && ! -f ~/.aws/config ]]; then
    echo "‚ùå No AWS configuration files found"
    echo "Run 'aws configure' to set up your first profile"
    return 1
  fi
  
  echo "Available AWS profiles:"
  aws configure list-profiles
  
  if [[ -n "$AWS_PROFILE" ]]; then
    echo ""
    echo "Current active profile: $AWS_PROFILE"
  fi
}

# Function to set the active AWS profile for this session
aws_use_profile() {
  local profile="$1"
  
  if [[ -z "$profile" ]]; then
    echo "Usage: aws_use_profile <profile_name>"
    aws_list_profiles
    return 1
  fi
  
  # Check if profile exists
  if ! aws configure list-profiles | grep -q "^$profile$"; then
    echo "‚ùå Profile '$profile' not found"
    aws_list_profiles
    return 1
  fi
  
  export AWS_PROFILE="$profile"
  echo "‚úÖ Now using AWS profile: $profile"
  
  # Verify profile works
  aws_check_profile "$profile"
}

# Update AWS command list
aws_command_list() {
    # Existing functionality
    echo "List of commands:"
    echo "Profile and credential management:"
    echo "  aws_list_profiles - List all available AWS profiles"
    echo "  aws_use_profile <name> - Set and validate the active AWS profile"
    echo "  aws_check_profile [name] - Verify a profile is working correctly"
    echo "  aws_config [name] - Set up a new profile"
    echo "  aws_temp_credentials - Set temporary credentials for this session"
    echo "  aws_region [region] - Set or change AWS region"
    echo "  aws_check_permissions - Test what AWS permissions you have"
    echo "  aws_install - Install AWS CLI and related tools"
    echo ""
    echo "IAM user management:"
    echo "  aws_list_users - List all IAM users"
    echo "  aws_list_groups - List all IAM groups"
    echo "  aws_list_users_in_group [group] - List users in a group (interactive)"
    echo "  aws_create_user <user_name> [--group/-g <group>] [--region/-r <region>] [--debug/-d] - Create a new IAM user"
    echo "  aws_delete_user <user_name> - Delete an IAM user (alias: awsrmuser)"
    echo "  aws_reset_password <user_name> - Reset a user's password"
    echo "  aws_add_user_to_group [user_name] [group_name] - Add a user to a group (interactive)"
    echo "  aws_create_group <group_name> [--type <role-type>] [--policies <policies>] - Create IAM group with predefined permissions"
    echo "  aws_user_activation - Show user activation options (placeholder)"
    
    echo ""
    echo "VPC management:"
    echo "  aws_vpc_list [region] [output_format] - List all VPCs"
    echo "  aws_vpc_info <vpc_id> [region] - Show detailed information about a VPC"
    echo "  aws_vpc_create [--cidr/-c <cidr>] [--name/-n <name>] [--region/-r <region>] [--subnets/-s <count>] [--internet-gateway/-i] - Create a new VPC"
    echo "  aws_vpc_delete <vpc_id> [region] [force] - Delete a VPC and its dependencies"
    echo "  aws_vpc_secure <vpc_id> [region] [force] - Secure a VPC by restricting public internet access"
    
    echo ""
    echo "AWS Config management:"
    echo "  aws_config_enable <region> [s3_bucket] [role_name] - Enable AWS Config in a region"
    echo "  aws_config_add_rule <rule_name> <rule_id> [region] [description] - Add a managed Config rule"
    echo "  aws_config_check_rule <rule_name> [region] - Check rule compliance status"
    echo "  aws_config_list_rules [region] - List all Config rules in a region"
    echo "  aws_config_restrict_ssh [region] - Quickly add the SSH restriction rule"
    
    echo ""
    echo "Debugging tips:"
    echo "  export AWS_DEBUG=1 - Enable AWS CLI debug mode"
    echo "  unset AWS_PROFILE - Use environment credentials instead of profile"
    
    echo ""
    echo "MFA security management:"
    echo "  aws_enforce_mfa <group_name> - Enforce MFA for users in a group"
    echo "  aws_add_mfa <username> - Add MFA for a specific user"
    echo "  aws_list_users_without_mfa - List users without MFA devices"
    
    echo ""
    echo "EC2 Instance management:"
    echo "  aws_list_instances [region] [filter] - List EC2 instances with optional region and name/ID filter"
    echo "  aws_instance_vpc_info <instance-id> [region] - Get VPC information for an EC2 instance"
    
    echo ""
    echo "Security Group management:"
    echo "  aws_secure_sg <security-group-id> [region] [your-ip-address] - Restrict SSH access to your IP only"
}

#Install AWScLI and other packages
aws_install(){
    brew install awscli
    brew install aws-vault
    brew install jq
}

aws_config(){
    load_env
    
    # Allow specifying a profile
    local profile="${1:-myprofile}"
    
    echo "Setting up AWS profile: $profile"
    echo "You'll need your AWS Access Key ID and Secret Access Key"
    
    # First check if aws-vault is installed
    if command -v aws-vault &> /dev/null; then
        echo "Using aws-vault for secure credential storage"
        aws-vault add "$profile"
    else
        # Fall back to regular aws configure
        echo "Using standard AWS CLI configuration"
        aws configure --profile "$profile"
    fi
    
    # Set this as the active profile
    export AWS_PROFILE="$profile"
    echo "Profile $profile is now active"
    
    # Verify the new profile works
    aws_check_profile "$profile"
    
    # Save the profile to .env if it exists
    if [[ -f .env ]]; then
        if grep -q "AWS_PROFILE=" .env; then
            # Update existing AWS_PROFILE
            sed -i '' "s/AWS_PROFILE=.*/AWS_PROFILE=$profile/" .env
        else
            # Add AWS_PROFILE if it doesn't exist
            echo "AWS_PROFILE=$profile" >> .env
        fi
        echo "Updated .env with AWS_PROFILE=$profile"
    fi
}

# Create a new IAM group with optional predefined permissions
# Usage: aws_create_group <group_name> [--type <permission-type>] [--policies <policy1,policy2>]
aws_create_group() {
    load_env
    local group_name=""
    local permission_type=""
    local custom_policies=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --type|-t)
                if [[ -n "$2" ]]; then
                    permission_type="$2"
                    shift 2
                else
                    echo "Error: Permission type required after --type"
                    return 1
                fi
                ;;
            --policies|-p)
                if [[ -n "$2" ]]; then
                    custom_policies="$2"
                    shift 2
                else
                    echo "Error: Policy list required after --policies"
                    return 1
                fi
                ;;
            *)
                if [[ -z "$group_name" ]]; then
                    group_name="$1"
                    shift
                else
                    echo "Error: Unexpected argument '$1'"
                    echo "Usage: aws_create_group <group_name> [--type <permission-type>] [--policies <policy1,policy2>]"
                    return 1
                fi
                ;;
        esac
    done
    
    if [[ -z "$group_name" ]]; then
        echo "Usage: aws_create_group <group_name> [--type <permission-type>] [--policies <policy1,policy2>]"
        echo ""
        echo "Available permission types:"
        echo "  readonly       - Read-only access to most AWS resources"
        echo "  fullstack      - Broad access for full stack developers"
        echo "  frontend       - Access for frontend developers (S3, CloudFront, Route53)"
        echo "  backend        - Access for backend developers (EC2, Lambda, API Gateway, DynamoDB)"
        echo "  devops         - Access for DevOps engineers (EC2, ECS, CloudFormation, etc.)"
        echo "  database       - Access for database administrators (RDS, DynamoDB, etc.)"
        echo "  security       - Access for security engineers (IAM, Config, Security Hub)"
        echo ""
        echo "Example: aws_create_group dev-team --type fullstack"
        echo "Example: aws_create_group custom-group --policies 'AmazonS3ReadOnlyAccess,AmazonDynamoDBReadOnlyAccess'"
        return 1
    fi
    
    echo "Creating group '$group_name'..."
    if ! run_aws_cmd iam create-group --group-name "$group_name"; then
        echo "‚ùå Failed to create group '$group_name'"
        return 1
    fi
    
    echo "‚úÖ Group '$group_name' created successfully."
    
    # If a permission type is specified, attach the corresponding policies
    if [[ -n "$permission_type" ]]; then
        echo "Adding '$permission_type' permissions to the group..."
        
        local policies=()
        
        case "$permission_type" in
            readonly)
                policies=(
                    "ReadOnlyAccess"  # Provides read-only access to all AWS services
                )
                ;;
            fullstack)
                policies=(
                    "AmazonS3FullAccess"
                    "AmazonDynamoDBFullAccess"
                    "AmazonEC2FullAccess"
                    "AmazonRDSFullAccess"
                    "AmazonRoute53FullAccess"
                    "AmazonAPIGatewayAdministrator"
                    "AWSLambda_FullAccess"
                    "CloudFrontFullAccess"
                )
                ;;
            frontend)
                policies=(
                    "AmazonS3FullAccess"
                    "CloudFrontFullAccess"
                    "AmazonRoute53ReadOnlyAccess"
                    "AWSLambda_ReadOnlyAccess"
                    "AmazonAPIGatewayInvokeFullAccess"
                )
                ;;
            backend)
                policies=(
                    "AmazonEC2ReadOnlyAccess"
                    "AmazonRDSDataFullAccess"
                    "AmazonDynamoDBFullAccess"
                    "AWSLambda_FullAccess"
                    "AmazonAPIGatewayAdministrator"
                    "AmazonSQSFullAccess"
                    "AmazonSNSFullAccess"
                )
                ;;
            devops)
                policies=(
                    "AmazonEC2FullAccess"
                    "AmazonECR-FullAccess"
                    "AmazonECS-FullAccess"
                    "AmazonS3FullAccess"
                    "AmazonRDSFullAccess"
                    "AmazonRoute53FullAccess"
                    "CloudWatchFullAccess"
                    "AWSCloudFormationFullAccess"
                    "AmazonVPCFullAccess"
                )
                ;;
            database)
                policies=(
                    "AmazonRDSFullAccess"
                    "AmazonDynamoDBFullAccess"
                    "AmazonRedshiftFullAccess"
                    "AmazonElastiCacheFullAccess"
                )
                ;;
            security)
                policies=(
                    "IAMReadOnlyAccess"
                    "AmazonInspector2FullAccess"
                    "AWSSecurityHubFullAccess"
                    "AmazonGuardDutyFullAccess"
                    "AWSConfigUserAccess"
                )
                ;;
            *)
                echo "‚ùå Unknown permission type: $permission_type"
                echo "Available types: readonly, fullstack, frontend, backend, devops, database, security"
                return 1
                ;;
        esac
        
        # Attach each policy
        for policy in "${policies[@]}"; do
            echo "Attaching policy: $policy"
            if run_aws_cmd iam attach-group-policy --group-name "$group_name" --policy-arn "arn:aws:iam::aws:policy/$policy"; then
                echo "‚úÖ Attached $policy"
            else
                echo "‚ùå Failed to attach $policy"
            fi
        done
    fi
    
    # If custom policies are specified, attach them
    if [[ -n "$custom_policies" ]]; then
        echo "Adding custom policies to the group..."
        
        # Split the comma-separated list
        IFS=',' read -ra policy_array <<< "$custom_policies"
        
        for policy in "${policy_array[@]}"; do
            # Trim whitespace
            policy=$(echo "$policy" | xargs)
            
            echo "Attaching policy: $policy"
            if [[ "$policy" == arn:* ]]; then
                # If full ARN is provided
                if run_aws_cmd iam attach-group-policy --group-name "$group_name" --policy-arn "$policy"; then
                    echo "‚úÖ Attached $policy"
                else
                    echo "‚ùå Failed to attach $policy"
                fi
            else
                # If just the policy name is provided
                if run_aws_cmd iam attach-group-policy --group-name "$group_name" --policy-arn "arn:aws:iam::aws:policy/$policy"; then
                    echo "‚úÖ Attached $policy"
                else
                    echo "‚ùå Failed to attach $policy"
                fi
            fi
        done
    fi
    
    # Summary
    echo ""
    echo "Group '$group_name' created successfully."
    
    # List attached policies
    echo "Policies attached to the group:"
    run_aws_cmd iam list-attached-group-policies --group-name "$group_name" --output table
    
    return 0
}

# Reset an IAM user's console password using generate_password
# Usage: reset_password <user_name>
aws_reset_password() {
    load_env
    local user_name="$1"
    
    if [[ -z "$user_name" ]]; then
      echo "Usage: reset_password <user_name>"
      return 1
    fi
    
    # Generate a compliant password
    local password
    password=$(generate_password -q)
    
    echo "Resetting password for user '$user_name'..."
    if ! run_aws_cmd iam update-login-profile \
      --user-name "$user_name" \
      --password "$password" \
      --password-reset-required; then
        echo "‚ùå Failed to reset password for user '$user_name'"
        return 1
    fi
    
    # Get the account ID from sts get-caller-identity
    local org_id
    if [[ -n "$AWS_ORG_ID" ]]; then
        # Use environment variable if available
        org_id="$AWS_ORG_ID"
    else
        # Get account ID from STS
        org_id=$(run_aws_cmd sts get-caller-identity --query "Account" --output text 2>/dev/null)
        if [[ -z "$org_id" ]]; then
            # Fallback to placeholder if we couldn't get the ID
            org_id="your-org-id"
        fi
    fi
    
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "üîê New password for '$user_name':"
    echo ""
    echo "  Username: $user_name"
    echo "  Password: $password"
    echo ""
    echo "  Login URL: https://${org_id}.signin.aws.amazon.com/console"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    return 0
}

# Add a user to an existing IAM group (with interactive selection)
# Usage: add_user_to_group [user_name] [group_name]
aws_add_user_to_group() {
    load_env
    local user_name="$1"
    local group_name="$2"
    
    # If no group provided, show interactive selection
    if [[ -z "$group_name" ]]; then
      # Fetch list of groups
      echo "Fetching groups..."
      local groups
      if ! groups=$(run_aws_cmd iam list-groups --query 'Groups[].GroupName' --output text); then
        echo "‚ùå Failed to fetch groups"
        return 1
      fi
      
      # Convert to array
      IFS=$'\n' read -rd '' -a group_array <<< "$groups"
      
      # Check if we got any groups
      if [[ ${#group_array[@]} -eq 0 ]]; then
        echo "‚ö†Ô∏è No IAM groups found."
        return 1
      fi
      
      # Interactive selection
      echo "Select a group to add a user to:"
      select group_name in "${group_array[@]}"; do
        if [[ -n "$group_name" ]]; then
          break
        else
          echo "Invalid selection."
        fi
      done
    fi
    
    # If no user provided, prompt for it
    if [[ -z "$user_name" ]]; then
      echo -n "Enter the user name to add to group '$group_name': "
      read user_name
      if [[ -z "$user_name" ]]; then
        echo "No user name provided"
        return 1
      fi
    fi
    
    echo "Adding user '$user_name' to group '$group_name'..."
    if ! run_aws_cmd iam add-user-to-group --group-name "$group_name" --user-name "$user_name"; then
      echo "‚ùå Failed to add user '$user_name' to group '$group_name'"
      return 1
    fi
    
    echo "‚úÖ User '$user_name' added to group '$group_name' successfully."
    return 0
}

# Create a new IAM user
# Usage: create_user <user_name> [--group|-g <group_name>]... [--region|-r <region>] [--debug|-d]
aws_create_user() {
    load_env
    local user_name=""
    local groups=()
    local create_password=true
    local debug_mode=false
    local region=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --group|-g)
          if [[ -n "$2" ]]; then
            groups+=("$2")
            shift 2
          else
            echo "Error: Group name required after --group/-g"
            return 1
          fi
          ;;
        --region|-r)
          if [[ -n "$2" ]]; then
            region="$2"
            shift 2
          else
            echo "Error: Region name required after --region/-r"
            return 1
          fi
          ;;
        --debug|-d)
          debug_mode=true
          shift
          ;;
        --password|-p)
          create_password=true
          shift
          ;;
        *)
          if [[ -z "$user_name" ]]; then
            user_name="$1"
            shift
          else
            echo "Error: Unexpected argument '$1'"
            echo "Usage: aws_create_user <user_name> [--group|-g <group_name>]... [--region|-r <region>] [--debug|-d]"
            return 1
          fi
          ;;
      esac
    done
    
    if [[ -z "$user_name" ]]; then
      echo "Usage: aws_create_user <user_name> [--group|-g <group_name>]... [--region|-r <region>] [--debug|-d]"
      return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
      export AWS_DEFAULT_REGION="$region"
      export AWS_REGION="$region"
      echo "Using region: $region"
    fi
    
    # Enable debug mode if requested
    if [[ "$debug_mode" == true ]]; then
      export AWS_DEBUG=1
      echo "Debug mode enabled"
    fi
    
    # Create the user
    echo "Creating user '$user_name'..."
    if ! run_aws_cmd iam create-user --user-name "$user_name"; then
      echo "‚ùå Failed to create user '$user_name'"
      if [[ "$debug_mode" != true ]]; then
        echo "For more details, try adding --debug/-d to see the API error responses"
      fi
      # Clean up
      unset AWS_DEBUG
      return 1
    fi
    echo "‚úÖ User '$user_name' created successfully."
    
    # Add user to specified groups
    if [[ ${#groups[@]} -gt 0 ]]; then
      echo "üîÑ Adding user to groups..."
      for group in "${groups[@]}"; do
        echo "  Adding to group '$group'..."
        if ! run_aws_cmd iam add-user-to-group --group-name "$group" --user-name "$user_name"; then
          echo "  ‚ùå Failed to add user to group '$group'"
        else
          echo "  ‚úÖ Added to group '$group' successfully"
        fi
      done
    fi
    
    # Create a login profile with password if requested
    if [[ "$create_password" = true ]]; then
      local password
      password=$(generate_password -q)
      
      echo "Creating login profile with password..."
      if ! run_aws_cmd iam create-login-profile \
        --user-name "$user_name" \
        --password "$password" \
        --password-reset-required; then
          echo "‚ùå Failed to create login profile for user '$user_name'"
      else
          # Get the account ID from sts get-caller-identity
          local org_id
          if [[ -n "$AWS_ORG_ID" ]]; then
              # Use environment variable if available
              org_id="$AWS_ORG_ID"
          else
              # Get account ID from STS
              org_id=$(run_aws_cmd sts get-caller-identity --query "Account" --output text 2>/dev/null)
              if [[ -z "$org_id" ]]; then
                  # Fallback to placeholder if we couldn't get the ID
                  org_id="your-org-id"
              fi
          fi
          
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          echo "üîê Console login details for '$user_name':"
          echo ""
          echo "  Username: $user_name"
          echo "  Password: $password"
          echo ""
          echo "  Login URL: https://${org_id}.signin.aws.amazon.com/console"
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      fi
    fi
    
    # Clean up
    unset AWS_DEBUG
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
      unset AWS_DEFAULT_REGION AWS_REGION
      if [[ -n "$AWS_PROFILE" ]]; then
        echo "Restored region from profile"
      fi
    fi
}

# Delete an AWS user
aws_delete_user() {
    load_env
    local user_name="$1"
    
    if [[ -z "$user_name" ]]; then
        echo "Usage: aws_delete_user <user_name>"
        #remind of aws list user function available 
        aws_command_list
        return 1
    fi
    
    # Confirm deletion
    echo -n "Are you sure you want to delete user '$user_name'? (y/n): "
    read confirm
    if [[ "$confirm" != "y" ]]; then
        echo "Operation cancelled."
        return 0
    fi
    
    echo "Deleting user '$user_name'..."
    if ! run_aws_cmd iam delete-user --user-name "$user_name"; then
        echo "‚ùå Failed to delete user '$user_name'"
        return 1
    fi
    
    echo "‚úÖ User '$user_name' deleted successfully."
    return 0
}

alias awsrmuser="aws_delete_user"

aws_user_activation(){
    #Allow Activation, Deactivation, Status for users. 
    echo "Function not yet implemented"
}

# Aliases for convenience
alias awslgroups="aws iam list-groups"
alias awslusers="aws iam list-users"

# Let users know AWS functions are loaded
echo "Loading AWS functions..."

# Create quick aliases for common AWS operations
alias aws_list_users="run_aws_cmd iam list-users"
alias aws_list_groups="run_aws_cmd iam list-groups"

# Interactive function to list users in a group
aws_list_users_in_group() {
  local group="$1"
  
  # If no group provided, show interactive selection
  if [[ -z "$group" ]]; then
    # Fetch list of groups
    echo "Fetching groups..."
    local groups
    if ! groups=$(run_aws_cmd iam list-groups --query 'Groups[].GroupName' --output text); then
      echo "‚ùå Failed to fetch groups"
      return 1
    fi
    
    # Convert to array
    IFS=$'\n' read -rd '' -a group_array <<< "$groups"
    
    # Check if we got any groups
    if [[ ${#group_array[@]} -eq 0 ]]; then
      echo "‚ö†Ô∏è No IAM groups found."
      return 1
    fi
    
    # Interactive selection
    echo "Select a group to list users:"
    select group in "${group_array[@]}"; do
      if [[ -n "$group" ]]; then
        break
      else
        echo "Invalid selection."
      fi
    done
  fi
  
  # Now we have a group name, list users
  echo "Users in group '$group':"
  if ! run_aws_cmd iam get-group --group-name "$group" --query 'Users[].UserName' --output table; then
    echo "‚ùå Failed to get users in group '$group'"
    return 1
  fi
}

# Add function to set temporary credentials for the session
aws_temp_credentials() {
    echo "Setting temporary AWS credentials for this session"
    echo "Note: These will only last until you close your terminal"
    
    # Clear any existing credentials
    unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN AWS_PROFILE
    
    # Prompt for temporary credentials
    echo "Enter AWS credentials:"
    echo -n "AWS Access Key ID: "
    read temp_key
    echo -n "AWS Secret Access Key: "
    read -s temp_secret
    echo ""
    echo -n "AWS Session Token (optional, press Enter to skip): "
    read temp_token
    
    # Ask for region
    echo -n "AWS Region (default: us-east-1): "
    read temp_region
    temp_region=${temp_region:-us-east-1}
    
    # Export temporary credentials
    export AWS_ACCESS_KEY_ID="$temp_key"
    export AWS_SECRET_ACCESS_KEY="$temp_secret"
    if [[ -n "$temp_token" ]]; then
        export AWS_SESSION_TOKEN="$temp_token"
    fi
    export AWS_DEFAULT_REGION="$temp_region"
    export AWS_REGION="$temp_region"
    
    # Unset profile to use environment variables instead
    unset AWS_PROFILE
    
    echo "‚úÖ Temporary credentials set for this session"
    echo "‚úÖ Region set to: $temp_region"
    echo "To verify they work, run: aws sts get-caller-identity"
    
    # Optionally, verify the credentials
    echo -n "Would you like to verify the credentials now? (y/n): "
    read verify
    if [[ "$verify" == "y" ]]; then
        if aws sts get-caller-identity; then
            echo "‚úÖ Credentials verified successfully"
            echo -n "Would you like to test IAM permissions? (y/n): "
            read test_iam
            if [[ "$test_iam" == "y" ]]; then
                aws_check_permissions
            fi
        else
            echo "‚ùå Credential verification failed"
        fi
    fi
    
    # Ask if user wants debug mode
    echo -n "Enable AWS debug mode? (y/n): "
    read debug_mode
    if [[ "$debug_mode" == "y" ]]; then
        export AWS_DEBUG=1
        echo "‚úÖ AWS debug mode enabled"
    fi
}

# Function to check AWS permissions
aws_check_permissions() {
    echo "Testing basic AWS permissions..."
    
    # Test listing users (read permission)
    echo "Testing IAM user listing..."
    if aws iam list-users --max-items 1 &>/dev/null; then
        echo "‚úÖ Can list IAM users"
    else
        echo "‚ùå Cannot list IAM users"
    fi
    
    # Test listing groups (read permission)
    echo "Testing IAM group listing..."
    if aws iam list-groups --max-items 1 &>/dev/null; then
        echo "‚úÖ Can list IAM groups"
    else
        echo "‚ùå Cannot list IAM groups"
    fi
    
    # Check if we have admin access using get-account-summary
    echo "Testing for admin privileges..."
    if aws iam get-account-summary &>/dev/null; then
        echo "‚úÖ Has administrative query permissions"
    else
        echo "‚ùå Limited administrative access"
    fi
    
    # Get caller identity for role/user info
    echo "Getting identity information..."
    aws sts get-caller-identity
    
    # Summarize
    echo ""
    echo "If you're getting permission errors when creating users or groups:"
    echo "1. Your IAM user/role may not have the required permissions"
    echo "2. Try a different region (some operations are region-specific)"
    echo "3. Check for any permission boundaries on your IAM user/role"
    echo ""
    echo "To see detailed permission errors, run with debug mode:"
    echo "export AWS_DEBUG=1"
}

# Set AWS region
aws_region() {
    local region="$1"
    
    if [[ -z "$region" ]]; then
        echo "Current AWS region: ${AWS_REGION:-not set}"
        echo "Available regions:"
        aws ec2 describe-regions --query "Regions[].RegionName" --output table 2>/dev/null || \
        echo "us-east-1 us-east-2 us-west-1 us-west-2 eu-west-1 eu-west-2 eu-central-1 ap-northeast-1 ap-northeast-2 ap-southeast-1 ap-southeast-2 sa-east-1 ca-central-1"
        
        echo -n "Enter region to set: "
        read region
    fi
    
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "‚úÖ AWS region set to: $region"
    fi
}

# ----------------------------------------
# VPC Management Functions
# ----------------------------------------

# List all VPCs in the account with details
aws_vpc_list() {
    local region="$1"
    local output_format="${2:-table}"
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    echo "Listing VPCs..."
    if [[ "$output_format" == "table" ]]; then
        # For table format, show selected fields in a readable format
        run_aws_cmd ec2 describe-vpcs \
            --query "Vpcs[].{ID:VpcId,CIDR:CidrBlock,Name:Tags[?Key=='Name'].Value|[0],State:State,Default:IsDefault}" \
            --output table
    else
        # For other formats (json, text, yaml), show all fields
        run_aws_cmd ec2 describe-vpcs --output "$output_format"
    fi
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
}

# Get detailed information about a specific VPC
aws_vpc_info() {
    local vpc_id="$1"
    local region="$2"
    
    if [[ -z "$vpc_id" ]]; then
        echo "Usage: aws_vpc_info <vpc-id> [region]"
        echo "Example: aws_vpc_info vpc-1234abcd us-east-1"
        
        # List VPCs to help user
        echo ""
        echo "Available VPCs:"
        aws_vpc_list "$region"
        return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    echo "Getting details for VPC $vpc_id..."
    echo "--------------------------"
    echo "VPC Details:"
    run_aws_cmd ec2 describe-vpcs --vpc-ids "$vpc_id" --output table
    
    echo "--------------------------"
    echo "Subnets in VPC:"
    run_aws_cmd ec2 describe-subnets \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "Subnets[].{ID:SubnetId,CIDR:CidrBlock,AZ:AvailabilityZone,Public:MapPublicIpOnLaunch,Name:Tags[?Key=='Name'].Value|[0]}" \
        --output table
    
    echo "--------------------------"
    echo "Route Tables:"
    run_aws_cmd ec2 describe-route-tables \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "RouteTables[].{ID:RouteTableId,Main:Associations[?Main].RouteTableAssociationId|[0],Name:Tags[?Key=='Name'].Value|[0]}" \
        --output table
    
    echo "--------------------------"
    echo "Security Groups:"
    run_aws_cmd ec2 describe-security-groups \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "SecurityGroups[].{ID:GroupId,Name:GroupName,Description:Description}" \
        --output table
    
    echo "--------------------------"
    echo "NACL Details:"
    run_aws_cmd ec2 describe-network-acls \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "NetworkAcls[].{ID:NetworkAclId,Default:IsDefault}" \
        --output table
    
    echo "--------------------------"
    echo "VPC Endpoints:"
    run_aws_cmd ec2 describe-vpc-endpoints \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "VpcEndpoints[].{ID:VpcEndpointId,Type:VpcEndpointType,Service:ServiceName,State:State}" \
        --output table 2>/dev/null || echo "No VPC endpoints found"
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
}

# Create a new VPC with customizable settings
aws_vpc_create() {
    local cidr_block="10.0.0.0/16"  # Default CIDR
    local vpc_name="MyVPC"
    local region=""
    local subnet_count=2
    local enable_dns=true
    local create_igw=false
    
    # Process named arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --cidr|-c)
                cidr_block="$2"
                shift 2
                ;;
            --name|-n)
                vpc_name="$2"
                shift 2
                ;;
            --region|-r)
                region="$2"
                shift 2
                ;;
            --subnets|-s)
                subnet_count="$2"
                shift 2
                ;;
            --internet-gateway|-i)
                create_igw=true
                shift
                ;;
            --help|-h)
                echo "Usage: aws_vpc_create [options]"
                echo "Options:"
                echo "  --cidr, -c <cidr>          CIDR block for VPC (default: 10.0.0.0/16)"
                echo "  --name, -n <name>          Name for the VPC (default: MyVPC)"
                echo "  --region, -r <region>      AWS region to create VPC in"
                echo "  --subnets, -s <count>      Number of subnets to create (default: 2)"
                echo "  --internet-gateway, -i     Create and attach an Internet Gateway"
                echo "  --help, -h                 Show this help message"
                echo ""
                echo "Example: aws_vpc_create --name 'Production VPC' --cidr 172.16.0.0/16 --region us-west-2 -i"
                return 0
                ;;
            *)
                echo "Unknown option: $1"
                echo "Use --help for usage information"
                return 1
                ;;
        esac
    done
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    # Validate CIDR block format
    if ! [[ "$cidr_block" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        echo "‚ùå Invalid CIDR block format: $cidr_block"
        echo "Expected format: x.x.x.x/y (e.g., 10.0.0.0/16)"
        return 1
    fi
    
    # Create VPC
    echo "Creating VPC '$vpc_name' with CIDR block $cidr_block..."
    local vpc_id
    vpc_id=$(run_aws_cmd ec2 create-vpc \
        --cidr-block "$cidr_block" \
        --query "Vpc.VpcId" \
        --output text)
    
    if [[ -z "$vpc_id" ]]; then
        echo "‚ùå Failed to create VPC"
        return 1
    fi
    
    echo "‚úÖ VPC created: $vpc_id"
    
    # Tag the VPC with a name
    echo "Tagging VPC with name: $vpc_name"
    run_aws_cmd ec2 create-tags \
        --resources "$vpc_id" \
        --tags "Key=Name,Value=$vpc_name"
    
    # Enable DNS hostnames and support
    if [[ "$enable_dns" == true ]]; then
        echo "Enabling DNS hostnames and support..."
        run_aws_cmd ec2 modify-vpc-attribute \
            --vpc-id "$vpc_id" \
            --enable-dns-hostnames "{\"Value\":true}"
        
        run_aws_cmd ec2 modify-vpc-attribute \
            --vpc-id "$vpc_id" \
            --enable-dns-support "{\"Value\":true}"
    fi
    
    # Create and attach Internet Gateway if requested
    if [[ "$create_igw" == true ]]; then
        echo "Creating Internet Gateway..."
        local igw_id
        igw_id=$(run_aws_cmd ec2 create-internet-gateway \
            --query "InternetGateway.InternetGatewayId" \
            --output text)
        
        if [[ -n "$igw_id" ]]; then
            echo "‚úÖ Internet Gateway created: $igw_id"
            
            echo "Attaching Internet Gateway to VPC..."
            run_aws_cmd ec2 attach-internet-gateway \
                --vpc-id "$vpc_id" \
                --internet-gateway-id "$igw_id"
            
            echo "‚úÖ Internet Gateway attached to VPC"
            
            # Tag the IGW
            run_aws_cmd ec2 create-tags \
                --resources "$igw_id" \
                --tags "Key=Name,Value=${vpc_name}-IGW"
        else
            echo "‚ùå Failed to create Internet Gateway"
        fi
    fi
    
    # Create subnets if requested
    if [[ "$subnet_count" -gt 0 ]]; then
        echo "Creating $subnet_count subnets..."
        
        # Get available AZs
        local azs
        azs=($(run_aws_cmd ec2 describe-availability-zones \
            --query "AvailabilityZones[].ZoneName" \
            --output text))
        
        # Split the VPC CIDR into subnet CIDRs
        local vpc_ip prefix_size
        IFS='/' read -r vpc_ip prefix_size <<< "$cidr_block"  # Split at the '/'
        # prefix_size is already set by the read command
        
        # Calculate subnet size (increment prefix by 8 - log2(subnet_count))
        local subnet_increment=0
        case $subnet_count in
            1) subnet_increment=0 ;;
            2) subnet_increment=1 ;;
            3|4) subnet_increment=2 ;;
            5|6|7|8) subnet_increment=3 ;;
            9|10|11|12|13|14|15|16) subnet_increment=4 ;;
            *) 
                echo "‚ùå Subnet count too large, defaulting to 4 subnets"
                subnet_count=4
                subnet_increment=2
                ;;
        esac
        
        local subnet_prefix=$((prefix_size + subnet_increment))
        
        # Create the subnets
        for ((i=0; i<subnet_count && i<${#azs[@]}; i++)); do
            local subnet_cidr="${vpc_ip}/$subnet_prefix"
            local subnet_name="${vpc_name}-subnet-$((i+1))"
            local is_public=$((i % 2 == 0))  # Alternate public/private
            
            echo "Creating subnet $subnet_name in ${azs[$i]}..."
            local subnet_id
            subnet_id=$(run_aws_cmd ec2 create-subnet \
                --vpc-id "$vpc_id" \
                --cidr-block "$subnet_cidr" \
                --availability-zone "${azs[$i]}" \
                --query "Subnet.SubnetId" \
                --output text)
            
            if [[ -n "$subnet_id" ]]; then
                echo "‚úÖ Subnet created: $subnet_id"
                
                # Tag the subnet
                local pub_priv
                if [[ "$is_public" == true ]]; then
                    pub_priv="Public"
                else
                    pub_priv="Private"
                fi
                run_aws_cmd ec2 create-tags \
                    --resources "$subnet_id" \
                    --tags "Key=Name,Value=${subnet_name}" "Key=Type,Value=$pub_priv"
            else
                echo "‚ùå Failed to create subnet"
            fi
        done
    fi
    
    echo ""
    echo "‚úÖ VPC setup completed successfully"
    echo "VPC ID: $vpc_id"
    echo ""
    echo "To view details about your new VPC:"
    echo "aws_vpc_info $vpc_id"
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# Delete a VPC and its dependencies
aws_vpc_delete() {
    local vpc_id="$1"
    local region="$2"
    local force="${3:-false}"
    
    if [[ -z "$vpc_id" ]]; then
        echo "Usage: aws_vpc_delete <vpc-id> [region] [force]"
        echo "Example: aws_vpc_delete vpc-1234abcd us-east-1 true"
        echo ""
        echo "Parameters:"
        echo "  vpc-id    The ID of the VPC to delete"
        echo "  region    Optional AWS region"
        echo "  force     Set to 'true' to force deletion of dependencies (default: false)"
        
        # List VPCs to help user
        echo ""
        echo "Available VPCs:"
        aws_vpc_list "$region"
        return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    # Check if VPC exists
    if ! run_aws_cmd ec2 describe-vpcs --vpc-ids "$vpc_id" &>/dev/null; then
        echo "‚ùå VPC $vpc_id does not exist in the current region"
        return 1
    fi
    
    # Confirm deletion
    echo -n "Are you sure you want to delete VPC $vpc_id? This cannot be undone. (y/n): "
    read confirm
    if [[ "$confirm" != "y" ]]; then
        echo "Operation cancelled."
        return 0
    fi
    
    # Delete dependencies if forced
    if [[ "$force" == "true" ]]; then
        echo "Force deletion enabled, removing dependencies..."
        
        # Detach and delete Internet Gateways
        echo "Checking for Internet Gateways..."
        local igw_ids
        igw_ids=$(run_aws_cmd ec2 describe-internet-gateways \
            --filters "Name=attachment.vpc-id,Values=$vpc_id" \
            --query "InternetGateways[].InternetGatewayId" \
            --output text)
        
        for igw_id in $igw_ids; do
            echo "Detaching Internet Gateway $igw_id..."
            run_aws_cmd ec2 detach-internet-gateway \
                --internet-gateway-id "$igw_id" \
                --vpc-id "$vpc_id"
            
            echo "Deleting Internet Gateway $igw_id..."
            run_aws_cmd ec2 delete-internet-gateway \
                --internet-gateway-id "$igw_id"
        done
        
        # Delete subnets
        echo "Checking for subnets..."
        local subnet_ids
        subnet_ids=$(run_aws_cmd ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$vpc_id" \
            --query "Subnets[].SubnetId" \
            --output text)
        
        for subnet_id in $subnet_ids; do
            echo "Deleting subnet $subnet_id..."
            run_aws_cmd ec2 delete-subnet \
                --subnet-id "$subnet_id"
        done
        
        # Delete route tables (except main)
        echo "Checking for custom route tables..."
        local route_table_ids
        route_table_ids=$(run_aws_cmd ec2 describe-route-tables \
            --filters "Name=vpc-id,Values=$vpc_id" \
            --query "RouteTables[?Associations[?Main==\`false\`]].RouteTableId" \
            --output text)
        
        for rt_id in $route_table_ids; do
            echo "Deleting route table $rt_id..."
            run_aws_cmd ec2 delete-route-table \
                --route-table-id "$rt_id"
        done
        
        # Delete security groups (except default)
        echo "Checking for security groups..."
        local sg_ids
        sg_ids=$(run_aws_cmd ec2 describe-security-groups \
            --filters "Name=vpc-id,Values=$vpc_id" 'Name=group-name,Values=!default' \
            --query "SecurityGroups[].GroupId" \
            --output text)
        
        for sg_id in $sg_ids; do
            echo "Deleting security group $sg_id..."
            run_aws_cmd ec2 delete-security-group \
                --group-id "$sg_id"
        done
        
        # Delete NAT Gateways
        echo "Checking for NAT Gateways..."
        local nat_ids
        nat_ids=$(run_aws_cmd ec2 describe-nat-gateways \
            --filter "Name=vpc-id,Values=$vpc_id" \
            --query "NatGateways[].NatGatewayId" \
            --output text 2>/dev/null) || true
        
        for nat_id in $nat_ids; do
            echo "Deleting NAT Gateway $nat_id..."
            run_aws_cmd ec2 delete-nat-gateway \
                --nat-gateway-id "$nat_id"
            
            echo "Waiting for NAT Gateway to delete (this may take a few minutes)..."
            run_aws_cmd ec2 wait nat-gateway-deleted \
                --nat-gateway-ids "$nat_id"
        done
        
        # Delete VPC endpoints
        echo "Checking for VPC endpoints..."
        local endpoint_ids
        endpoint_ids=$(run_aws_cmd ec2 describe-vpc-endpoints \
            --filters "Name=vpc-id,Values=$vpc_id" \
            --query "VpcEndpoints[].VpcEndpointId" \
            --output text 2>/dev/null) || true
        
        for endpoint_id in $endpoint_ids; do
            echo "Deleting VPC endpoint $endpoint_id..."
            run_aws_cmd ec2 delete-vpc-endpoints \
                --vpc-endpoint-ids "$endpoint_id"
        done
    fi
    
    # Finally delete the VPC
    echo "Deleting VPC $vpc_id..."
    if run_aws_cmd ec2 delete-vpc --vpc-id "$vpc_id"; then
        echo "‚úÖ VPC $vpc_id deleted successfully"
    else
        echo "‚ùå Failed to delete VPC $vpc_id"
        echo "This may be because the VPC still has dependencies. Try using the force option:"
        echo "aws_vpc_delete $vpc_id $region true"
        return 1
    fi
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# Secure a VPC by restricting public internet access
aws_vpc_secure() {
    local vpc_id="$1"
    local region="$2"
    local force="${3:-false}"
    
    if [[ -z "$vpc_id" ]]; then
        echo "Usage: aws_vpc_secure <vpc-id> [region] [force]"
        echo "Example: aws_vpc_secure vpc-1234abcd us-east-1 true"
        echo ""
        echo "Parameters:"
        echo "  vpc-id    The ID of the VPC to secure"
        echo "  region    Optional AWS region"
        echo "  force     Set to 'true' to apply changes without confirmation (default: false)"
        
        # List VPCs to help user
        echo ""
        echo "Available VPCs:"
        aws_vpc_list "$region"
        return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    # Check if VPC exists
    if ! run_aws_cmd ec2 describe-vpcs --vpc-ids "$vpc_id" &>/dev/null; then
        echo "‚ùå VPC $vpc_id does not exist in the current region"
        return 1
    fi
    
    echo "üîí Securing VPC $vpc_id against public internet access"
    echo "Running security assessment..."
    
    # Get VPC information
    local vpc_info
    vpc_info=$(run_aws_cmd ec2 describe-vpcs --vpc-ids "$vpc_id")
    
    # Check if it's the default VPC
    local is_default
    is_default=$(echo "$vpc_info" | grep -o '"IsDefault": true' || echo "false")
    
    if [[ "$is_default" == *"true"* ]]; then
        echo "‚ö†Ô∏è This is the default VPC. Be careful as many AWS services use this by default."
        echo "   Consider creating a new VPC for production workloads instead of modifying the default."
    fi
    
    # Check for Internet Gateways
    echo ""
    echo "1. Checking for Internet Gateways..."
    local igw_ids
    igw_ids=$(run_aws_cmd ec2 describe-internet-gateways \
        --filters "Name=attachment.vpc-id,Values=$vpc_id" \
        --query "InternetGateways[].InternetGatewayId" \
        --output text)
    
    if [[ -n "$igw_ids" ]]; then
        echo "üö® Found Internet Gateway(s): $igw_ids"
        echo "   Internet Gateways allow traffic between your VPC and the public internet."
        
        if [[ "$force" == "true" ]]; then
            local detach_igw="y"
        else
            echo -n "   Do you want to detach the Internet Gateway(s)? (y/n): "
            read detach_igw
        fi
        
        if [[ "$detach_igw" == "y" ]]; then
            for igw_id in $igw_ids; do
                echo "   Detaching Internet Gateway $igw_id..."
                run_aws_cmd ec2 detach-internet-gateway \
                    --internet-gateway-id "$igw_id" \
                    --vpc-id "$vpc_id"
                
                echo "   ‚úÖ Internet Gateway detached"
                
                # Optionally delete it
                echo -n "   Do you want to delete this Internet Gateway? (y/n): "
                read delete_igw
                if [[ "$delete_igw" == "y" ]]; then
                    run_aws_cmd ec2 delete-internet-gateway \
                        --internet-gateway-id "$igw_id"
                    echo "   ‚úÖ Internet Gateway deleted"
                fi
            done
        else
            echo "   ‚ö†Ô∏è Leaving Internet Gateway(s) attached. VPC remains publicly accessible."
        fi
    else
        echo "   ‚úÖ No Internet Gateways found"
    fi
    
    # Check route tables for internet routes
    echo ""
    echo "2. Checking route tables for internet routes..."
    local route_tables
    route_tables=$(run_aws_cmd ec2 describe-route-tables \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "RouteTables[].RouteTableId" \
        --output text)
    
    local found_internet_routes=false
    
    for rt_id in $route_tables; do
        echo "   Checking route table $rt_id..."
        local internet_routes
        internet_routes=$(run_aws_cmd ec2 describe-route-tables \
            --route-table-ids "$rt_id" \
            --query "RouteTables[].Routes[?DestinationCidrBlock=='0.0.0.0/0']" \
            --output text)
        
        if [[ -n "$internet_routes" ]]; then
            found_internet_routes=true
            echo "   üö® Found internet route in $rt_id"
            
            if [[ "$force" == "true" ]]; then
                local remove_route="y"
            else
                echo -n "   Do you want to remove the internet route? (y/n): "
                read remove_route
            fi
            
            if [[ "$remove_route" == "y" ]]; then
                run_aws_cmd ec2 delete-route \
                    --route-table-id "$rt_id" \
                    --destination-cidr-block "0.0.0.0/0"
                echo "   ‚úÖ Internet route removed"
            else
                echo "   ‚ö†Ô∏è Leaving internet route. Subnets using this route table remain publicly accessible."
            fi
        else
            echo "   ‚úÖ No internet routes found in $rt_id"
        fi
    done
    
    if [[ "$found_internet_routes" == "false" ]]; then
        echo "   ‚úÖ No internet routes found in any route tables"
    fi
    
    # Check security groups for overly permissive rules
    echo ""
    echo "3. Checking security groups for public access rules..."
    local security_groups
    security_groups=$(run_aws_cmd ec2 describe-security-groups \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "SecurityGroups[].GroupId" \
        --output text)
    
    for sg_id in $security_groups; do
        local sg_name
        sg_name=$(run_aws_cmd ec2 describe-security-groups \
            --group-ids "$sg_id" \
            --query "SecurityGroups[].GroupName" \
            --output text)
            
        echo "   Checking security group $sg_name ($sg_id)..."
        
        # Check for public inbound rules (0.0.0.0/0)
        local public_rules
        public_rules=$(run_aws_cmd ec2 describe-security-groups \
            --group-ids "$sg_id" \
            --query "SecurityGroups[].IpPermissions[?contains(IpRanges[].CidrIp, '0.0.0.0/0')]" \
            --output json)
        
        if [[ "$public_rules" != "[]" && "$public_rules" != "" ]]; then
            echo "   üö® Found public access rules in security group $sg_name"
            echo "$public_rules" | grep -o "FromPort\".*ToPort\".*" | sed 's/,/\n/g' | sed 's/"//g' | grep -v "IpRanges"
            
            if [[ "$force" == "true" ]]; then
                local restrict_sg="y"
            else
                echo -n "   Do you want to restrict this security group? (y/n): "
                read restrict_sg
            fi
            
            if [[ "$restrict_sg" == "y" ]]; then
                echo "   Creating new rules to replace public access..."
                
                echo -n "   Enter CIDR to restrict access to (e.g., 10.0.0.0/8 or your office IP): "
                read restricted_cidr
                
                if [[ -z "$restricted_cidr" ]]; then
                    echo "   ‚ö†Ô∏è No CIDR provided, skipping security group restriction"
                    continue
                fi
                
                # Extract all the public rules to be replaced
                local ports_to_restrict
                ports_to_restrict=$(echo "$public_rules" | grep -o "\"FromPort\": [0-9]*,.*\"ToPort\": [0-9]*" | sed 's/.*: //g' | sed 's/,//g')
                
                # For each port range, create new restricted rule and remove the public one
                while read -r from_port && read -r to_port; do
                    if [[ -n "$from_port" && -n "$to_port" ]]; then
                        # Get protocol
                        local protocol
                        protocol=$(echo "$public_rules" | grep -A 2 "\"FromPort\": $from_port" | grep "IpProtocol" | head -1 | awk -F '"' '{print $4}')
                        
                        echo "   Creating restricted rule for ports $from_port-$to_port ($protocol)..."
                        
                        # Add the restricted rule first
                        run_aws_cmd ec2 authorize-security-group-ingress \
                            --group-id "$sg_id" \
                            --protocol "$protocol" \
                            --port "$from_port-$to_port" \
                            --cidr "$restricted_cidr"
                        
                        # Remove the public rule
                        run_aws_cmd ec2 revoke-security-group-ingress \
                            --group-id "$sg_id" \
                            --protocol "$protocol" \
                            --port "$from_port-$to_port" \
                            --cidr "0.0.0.0/0"
                        
                        echo "   ‚úÖ Rule updated to restrict access to $restricted_cidr"
                    fi
                done <<< "$ports_to_restrict"
            else
                echo "   ‚ö†Ô∏è Leaving public access rules in place"
            fi
        else
            echo "   ‚úÖ No public access rules found in security group $sg_name"
        fi
    done
    
    # Check network ACLs for public access
    echo ""
    echo "4. Checking Network ACLs for public access rules..."
    local nacls
    nacls=$(run_aws_cmd ec2 describe-network-acls \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "NetworkAcls[].NetworkAclId" \
        --output text)
    
    for nacl_id in $nacls; do
        echo "   Checking NACL $nacl_id..."
        
        # Check for open inbound rules
        local public_nacl_rules
        public_nacl_rules=$(run_aws_cmd ec2 describe-network-acls \
            --network-acl-ids "$nacl_id" \
            --query "NetworkAcls[].Entries[?CidrBlock=='0.0.0.0/0' && Egress==\`false\` && RuleAction=='allow']" \
            --output json)
        
        if [[ "$public_nacl_rules" != "[]" && "$public_nacl_rules" != "" ]]; then
            echo "   üö® Found public inbound rules in NACL $nacl_id"
            
            if [[ "$force" == "true" ]]; then
                local restrict_nacl="y"
            else
                echo -n "   Do you want to restrict this NACL? (y/n): "
                read restrict_nacl
            fi
            
            if [[ "$restrict_nacl" == "y" ]]; then
                echo "   Creating restricted rules to replace public access..."
                
                echo -n "   Enter CIDR to restrict access to (e.g., 10.0.0.0/8 or your office IP): "
                read restricted_nacl_cidr
                
                if [[ -z "$restricted_nacl_cidr" ]]; then
                    echo "   ‚ö†Ô∏è No CIDR provided, skipping NACL restriction"
                    continue
                fi
                
                # Find all rule numbers
                local rule_numbers
                rule_numbers=$(echo "$public_nacl_rules" | grep -o "\"RuleNumber\": [0-9]*" | awk '{print $2}' | sed 's/,//g')
                
                for rule_number in $rule_numbers; do
                    if [[ -n "$rule_number" ]]; then
                        # Get the port range
                        local port_range
                        port_range=$(echo "$public_nacl_rules" | grep -A 5 "\"RuleNumber\": $rule_number" | grep "PortRange" -A 2 | grep "From\|To" | awk '{print $2}' | sed 's/,//g')
                        
                        # Get the protocol
                        local nacl_protocol
                        nacl_protocol=$(echo "$public_nacl_rules" | grep -A 5 "\"RuleNumber\": $rule_number" | grep "Protocol" | awk '{print $2}' | sed 's/,//g')
                        
                        # Delete the public rule
                        run_aws_cmd ec2 delete-network-acl-entry \
                            --network-acl-id "$nacl_id" \
                            --rule-number "$rule_number" \
                            --egress false
                        
                        # Create new restricted rule
                        # For simplicity we're using rule number + 1
                        run_aws_cmd ec2 create-network-acl-entry \
                            --network-acl-id "$nacl_id" \
                            --rule-number $((rule_number + 1)) \
                            --protocol "$nacl_protocol" \
                            --port-range "From=${port_range%-*},To=${port_range#*-}" \
                            --cidr-block "$restricted_nacl_cidr" \
                            --rule-action allow \
                            --egress false
                        
                        echo "   ‚úÖ NACL rule $rule_number updated to restrict access to $restricted_nacl_cidr"
                    fi
                done
            else
                echo "   ‚ö†Ô∏è Leaving public NACL rules in place"
            fi
        else
            echo "   ‚úÖ No public inbound rules found in NACL $nacl_id"
        fi
    done
    
    # Check subnets with public IP assignment
    echo ""
    echo "5. Checking for subnets with automatic public IP assignment..."
    local public_subnets
    public_subnets=$(run_aws_cmd ec2 describe-subnets \
        --filters "Name=vpc-id,Values=$vpc_id" "Name=map-public-ip-on-launch,Values=true" \
        --query "Subnets[].SubnetId" \
        --output text)
    
    if [[ -n "$public_subnets" ]]; then
        echo "   üö® Found subnets that automatically assign public IPs:"
        
        for subnet_id in $public_subnets; do
            local subnet_az
            subnet_az=$(run_aws_cmd ec2 describe-subnets \
                --subnet-ids "$subnet_id" \
                --query "Subnets[].AvailabilityZone" \
                --output text)
                
            local subnet_cidr
            subnet_cidr=$(run_aws_cmd ec2 describe-subnets \
                --subnet-ids "$subnet_id" \
                --query "Subnets[].CidrBlock" \
                --output text)
                
            echo "     - $subnet_id ($subnet_cidr in $subnet_az)"
        done
        
        if [[ "$force" == "true" ]]; then
            local disable_public_ip="y"
        else
            echo -n "   Do you want to disable public IP assignment for these subnets? (y/n): "
            read disable_public_ip
        fi
        
        if [[ "$disable_public_ip" == "y" ]]; then
            for subnet_id in $public_subnets; do
                run_aws_cmd ec2 modify-subnet-attribute \
                    --subnet-id "$subnet_id" \
                    --no-map-public-ip-on-launch
                    
                echo "   ‚úÖ Disabled public IP assignment for subnet $subnet_id"
            done
        else
            echo "   ‚ö†Ô∏è Leaving public IP assignment enabled"
        fi
    else
        echo "   ‚úÖ No subnets with automatic public IP assignment"
    fi
    
    # Final summary
    echo ""
    echo "üîí VPC Security Assessment Complete"
    echo "===================================="
    
    # Check for remaining issues
    igw_ids=$(run_aws_cmd ec2 describe-internet-gateways \
        --filters "Name=attachment.vpc-id,Values=$vpc_id" \
        --query "InternetGateways[].InternetGatewayId" \
        --output text)
        
    if [[ -n "$igw_ids" ]]; then
        echo "‚ö†Ô∏è VPC still has Internet Gateway(s) attached"
    fi
    
    found_internet_routes=$(run_aws_cmd ec2 describe-route-tables \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "RouteTables[].Routes[?DestinationCidrBlock=='0.0.0.0/0']" \
        --output text)
        
    if [[ -n "$found_internet_routes" ]]; then
        echo "‚ö†Ô∏è VPC still has internet routes in route tables"
    fi
    
    public_rules=$(run_aws_cmd ec2 describe-security-groups \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "SecurityGroups[].IpPermissions[?contains(IpRanges[].CidrIp, '0.0.0.0/0')]" \
        --output text)
        
    if [[ -n "$public_rules" ]]; then
        echo "‚ö†Ô∏è VPC still has public access rules in security groups"
    fi
    
    public_subnets=$(run_aws_cmd ec2 describe-subnets \
        --filters "Name=vpc-id,Values=$vpc_id" "Name=map-public-ip-on-launch,Values=true" \
        --query "Subnets[].SubnetId" \
        --output text)
        
    if [[ -n "$public_subnets" ]]; then
        echo "‚ö†Ô∏è VPC still has subnets with automatic public IP assignment"
    fi
    
    if [[ -z "$igw_ids" && -z "$found_internet_routes" && -z "$public_rules" && -z "$public_subnets" ]]; then
        echo "‚úÖ VPC is now secured against public internet access"
    else
        echo "‚ö†Ô∏è VPC may still have public internet access. Review the warnings above."
    fi
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# ----------------------------------------
# AWS Config Management Functions
# ----------------------------------------

# Enable AWS Config in a region
aws_config_enable() {
    local region="$1"
    local s3_bucket="$2"
    local role_name="$3"
    
    if [[ -z "$region" ]]; then
        echo "Usage: aws_config_enable <region> [s3_bucket] [role_name]"
        echo ""
        echo "Parameters:"
        echo "  region      AWS region to enable Config in"
        echo "  s3_bucket   Optional S3 bucket for AWS Config (created if not specified)"
        echo "  role_name   Optional IAM role name for AWS Config (created if not specified)"
        
        # Get current region to suggest
        local current_region="${AWS_REGION:-us-east-1}"
        echo ""
        echo "Example: aws_config_enable $current_region"
        return 1
    fi
    
    # Set region
    export AWS_DEFAULT_REGION="$region"
    export AWS_REGION="$region"
    echo "Using region: $region"
    
    # Get account ID
    local account_id
    account_id=$(run_aws_cmd sts get-caller-identity --query "Account" --output text)
    if [[ -z "$account_id" ]]; then
        echo "‚ùå Failed to get AWS account ID"
        return 1
    fi
    
    # Set default role name if not provided
    if [[ -z "$role_name" ]]; then
        role_name="AWS-ConfigRole"
        echo "Using default role name: $role_name"
    fi
    
    # Check if role exists, create if not
    if ! run_aws_cmd iam get-role --role-name "$role_name" &>/dev/null; then
        echo "Creating AWS Config service role: $role_name"
        
        # Create trust policy document for the role
        local trust_policy='{
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Sid": "",
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "config.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                }
            ]
        }'
        
        # Save trust policy to temporary file
        local tmp_file
        tmp_file=$(mktemp)
        echo "$trust_policy" > "$tmp_file"
        
        # Create the role
        if ! run_aws_cmd iam create-role --role-name "$role_name" --assume-role-policy-document "file://$tmp_file"; then
            echo "‚ùå Failed to create AWS Config role"
            rm "$tmp_file"
            return 1
        fi
        
        # Attach necessary policies to the role
        echo "Attaching policies to AWS Config role..."
        run_aws_cmd iam attach-role-policy \
            --role-name "$role_name" \
            --policy-arn "arn:aws:iam::aws:policy/service-role/AWS_ConfigRole"
        
        # Clean up temp file
        rm "$tmp_file"
    else
        echo "‚úÖ Using existing AWS Config role: $role_name"
    fi
    
    # Get role ARN
    local role_arn
    role_arn=$(run_aws_cmd iam get-role --role-name "$role_name" --query "Role.Arn" --output text)
    
    # Handle S3 bucket for AWS Config
    if [[ -z "$s3_bucket" ]]; then
        s3_bucket="config-bucket-$account_id-$region"
        echo "Using default S3 bucket name: $s3_bucket"
    fi
    
    # Check if bucket exists
    if ! run_aws_cmd s3api head-bucket --bucket "$s3_bucket" 2>/dev/null; then
        echo "Creating S3 bucket for AWS Config: $s3_bucket"
        # Create the bucket with SSE encryption
        run_aws_cmd s3 mb "s3://$s3_bucket" \
            --region "$region"
        
        # Apply bucket policy for AWS Config
        local bucket_policy='{
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Sid": "AWSConfigBucketPermissionsCheck",
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "config.amazonaws.com"
                    },
                    "Action": "s3:GetBucketAcl",
                    "Resource": "arn:aws:s3:::'$s3_bucket'"
                },
                {
                    "Sid": "AWSConfigBucketDelivery",
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "config.amazonaws.com"
                    },
                    "Action": "s3:PutObject",
                    "Resource": "arn:aws:s3:::'$s3_bucket'/AWSLogs/'$account_id'/Config/*",
                    "Condition": {
                        "StringEquals": {
                            "s3:x-amz-acl": "bucket-owner-full-control"
                        }
                    }
                }
            ]
        }'
        
        # Save bucket policy to temporary file
        local bucket_policy_file
        bucket_policy_file=$(mktemp)
        echo "$bucket_policy" > "$bucket_policy_file"
        
        # Apply the bucket policy
        run_aws_cmd s3api put-bucket-policy \
            --bucket "$s3_bucket" \
            --policy "file://$bucket_policy_file"
        
        # Clean up temp file
        rm "$bucket_policy_file"
    else
        echo "‚úÖ Using existing S3 bucket: $s3_bucket"
    fi
    
    # Enable AWS Config
    echo "Enabling AWS Config in region $region..."
    
    # Create configuration recorder
    echo "Setting up configuration recorder..."
    run_aws_cmd configservice put-configuration-recorder \
        --configuration-recorder "name=default,roleARN=$role_arn" \
        --recording-group '{"allSupported":true,"includeGlobalResourceTypes":true}'
    
    # Set up delivery channel
    echo "Setting up delivery channel..."
    run_aws_cmd configservice put-delivery-channel \
        --delivery-channel "name=default,s3BucketName=$s3_bucket,configSnapshotDeliveryProperties={deliveryFrequency=One_Hour}"
    
    # Start the configuration recorder
    echo "Starting configuration recorder..."
    run_aws_cmd configservice start-configuration-recorder \
        --configuration-recorder-name default
    
    echo "‚úÖ AWS Config enabled successfully in region $region"
    echo "Delivery channel configured to write to S3 bucket: $s3_bucket"
    
    return 0
}

# Add a managed rule to AWS Config
aws_config_add_rule() {
    local rule_name="$1"
    local rule_id="$2"
    local region="$3"
    local description="${4:-AWS Managed Config Rule}"
    
    if [[ -z "$rule_name" || -z "$rule_id" ]]; then
        echo "Usage: aws_config_add_rule <rule_name> <rule_id> [region] [description]"
        echo ""
        echo "Parameters:"
        echo "  rule_name     Name for the AWS Config rule"
        echo "  rule_id       AWS managed rule identifier (e.g., INCOMING_SSH_DISABLED)"
        echo "  region        Optional AWS region (uses current region if not specified)"
        echo "  description   Optional description for the rule"
        echo ""
        echo "Example: aws_config_add_rule restricted-ssh INCOMING_SSH_DISABLED us-east-1"
        echo ""
        echo "Common AWS Managed Rules:"
        echo "  INCOMING_SSH_DISABLED     - Checks for unrestricted SSH access"
        echo "  RESTRICTED_INCOMING_TRAFFIC - Checks for unrestricted access on specific ports"
        echo "  S3_BUCKET_PUBLIC_READ_PROHIBITED - Prevents public read access for S3 buckets"
        echo "  IAM_PASSWORD_POLICY - Checks if password policy meets specified requirements"
        echo "  ROOT_ACCOUNT_MFA_ENABLED - Checks if root account has MFA enabled"
        return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    # Check if AWS Config is enabled
    if ! run_aws_cmd configservice describe-configuration-recorders &>/dev/null; then
        echo "‚ùå AWS Config is not enabled in this region"
        echo "Please enable AWS Config first with: aws_config_enable <region>"
        return 1
    fi
    
    # Create rule JSON
    local rule_json='{
        "ConfigRuleName": "'$rule_name'",
        "Description": "'$description'",
        "Scope": {
            "ComplianceResourceTypes": []
        },
        "Source": {
            "Owner": "AWS",
            "SourceIdentifier": "'$rule_id'"
        },
        "MaximumExecutionFrequency": "TwentyFour_Hours"
    }'
    
    # Set resource types based on rule ID
    case "$rule_id" in
        INCOMING_SSH_DISABLED|RESTRICTED_INCOMING_TRAFFIC)
            rule_json=${rule_json/"ComplianceResourceTypes": \[\]/"ComplianceResourceTypes": \["AWS::EC2::SecurityGroup"\]}
            ;;
        S3_BUCKET_PUBLIC_READ_PROHIBITED|S3_BUCKET_PUBLIC_WRITE_PROHIBITED)
            rule_json=${rule_json/"ComplianceResourceTypes": \[\]/"ComplianceResourceTypes": \["AWS::S3::Bucket"\]}
            ;;
        IAM_PASSWORD_POLICY|ROOT_ACCOUNT_MFA_ENABLED)
            # These are account-level checks, so we leave resource types empty
            ;;
        *)
            # Default: keep empty array for all resource types
            ;;
    esac
    
    # Save rule JSON to temporary file
    local tmp_file
    tmp_file=$(mktemp)
    echo "$rule_json" > "$tmp_file"
    
    # Add the rule to AWS Config
    echo "Adding AWS Config rule: $rule_name ($rule_id)"
    if run_aws_cmd configservice put-config-rule --config-rule "file://$tmp_file"; then
        echo "‚úÖ AWS Config rule '$rule_name' added successfully"
    else
        echo "‚ùå Failed to add AWS Config rule '$rule_name'"
        rm "$tmp_file"
        return 1
    fi
    
    # Clean up temporary file
    rm "$tmp_file"
    
    # Check the rule status
    echo "Checking rule status..."
    run_aws_cmd configservice describe-config-rules \
        --config-rule-names "$rule_name" \
        --query "ConfigRules[0].[ConfigRuleName,ConfigRuleState]" \
        --output table
    
    echo "Note: It may take up to 24 hours for the initial compliance evaluation"
    echo "To check compliance status later, use: aws_config_check_rule $rule_name"
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# Check the compliance status of a Config rule
aws_config_check_rule() {
    local rule_name="$1"
    local region="$2"
    
    if [[ -z "$rule_name" ]]; then
        echo "Usage: aws_config_check_rule <rule_name> [region]"
        echo ""
        echo "Parameters:"
        echo "  rule_name    Name of the AWS Config rule to check"
        echo "  region       Optional AWS region"
        
        # List all rules if none specified
        echo ""
        echo "Available Config rules:"
        run_aws_cmd configservice describe-config-rules \
            --query "ConfigRules[*].[ConfigRuleName,Description]" \
            --output table 2>/dev/null || echo "No Config rules found or AWS Config not enabled"
            
        return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    # Check if rule exists
    if ! run_aws_cmd configservice describe-config-rules --config-rule-names "$rule_name" &>/dev/null; then
        echo "‚ùå Config rule '$rule_name' not found"
        return 1
    fi
    
    # Get rule details
    echo "Details for Config rule '$rule_name':"
    run_aws_cmd configservice describe-config-rules \
        --config-rule-names "$rule_name" \
        --output json
    
    # Get compliance status
    echo ""
    echo "Compliance status:"
    local compliance_json
    compliance_json=$(run_aws_cmd configservice describe-compliance-by-config-rule \
        --config-rule-names "$rule_name" \
        --output json)
    
    # Extract compliance type using jq-like approach with sed
    local compliance_type
    compliance_type=$(echo "$compliance_json" | sed -n 's/.*"ComplianceType": "\([^"]*\)".*/\1/p')
    
    # Show compliance results based on what we found
    echo "Summary:"
    if [[ -z "$compliance_type" ]]; then
        echo "EVALUATION IN PROGRESS or INSUFFICIENT_DATA"
    elif [[ "$compliance_type" == *"NOT_APPLICABLE"* ]]; then
        echo "‚ö†Ô∏è Rule evaluation not applicable to any resources"
    else
        echo "$compliance_type"
    fi
    
    # Get non-compliant resources if applicable
    if [[ "$compliance_type" == *"NON_COMPLIANT"* ]]; then
        echo ""
        echo "Non-compliant resources:"
        run_aws_cmd configservice get-compliance-details-by-config-rule \
            --config-rule-name "$rule_name" \
            --compliance-types NON_COMPLIANT \
            --query "EvaluationResults[*].{ResourceID:EvaluationResultIdentifier.EvaluationResultQualifier.ResourceId, ResourceType:EvaluationResultIdentifier.EvaluationResultQualifier.ResourceType, Status:ComplianceType, Reason:Annotation}" \
            --output table
    fi
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# List all AWS Config rules in a region
aws_config_list_rules() {
    local region="$1"
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    # Check if AWS Config is enabled
    if ! run_aws_cmd configservice describe-configuration-recorders &>/dev/null; then
        echo "‚ùå AWS Config is not enabled in this region"
        echo "Please enable AWS Config first with: aws_config_enable <region>"
        return 1
    fi
    
    # List all Config rules
    echo "AWS Config rules in region ${AWS_REGION:-default}:"
    run_aws_cmd configservice describe-config-rules \
        --query "ConfigRules[*].{Rule:ConfigRuleName, Type:Source.Owner, ManagedRule:Source.SourceIdentifier, State:ConfigRuleState}" \
        --output table
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# Setup the restricted-ssh AWS Config rule (convenience function)
aws_config_restrict_ssh() {
    local region="$1"
    
    echo "===================================================="
    echo "üîí Setting up SSH security monitoring for your AWS environment"
    echo "===================================================="
    echo "This function sets up automated monitoring to detect security groups"
    echo "that allow unrestricted SSH access from the internet (0.0.0.0/0)."
    echo "Think of it as a security camera for your AWS account that alerts"
    echo "you to potential insecure configurations."
    echo ""
    
    # First ensure AWS Config is enabled
    if ! run_aws_cmd configservice describe-configuration-recorders &>/dev/null; then
        echo "Step 1: AWS Config needs to be enabled first"
        echo "AWS Config is the security monitoring service that will track your resources"
        echo ""
        echo "AWS Config is not enabled. Would you like to enable it now? (y/n): "
        read enable_config
        if [[ "$enable_config" == "y" ]]; then
            echo "Enabling AWS Config - this sets up the security monitoring service..."
            aws_config_enable "$region"
        else
            echo "AWS Config must be enabled to add security monitoring rules."
            return 1
        fi
    else
        echo "‚úÖ Step 1: AWS Config is already enabled"
    fi
    
    echo ""
    echo "Step 2: Creating SSH security monitoring rule"
    echo "This rule will continuously check for and report any security groups"
    echo "that allow unrestricted SSH access from the internet"
    echo ""
    
    # Create the rule
    aws_config_add_rule "restricted-ssh" "INCOMING_SSH_DISABLED" "$region" \
        "Checks whether security groups allow unrestricted incoming SSH traffic from 0.0.0.0/0 or ::/0"
    
    echo ""
    echo "===================================================="
    echo "‚úÖ SSH security monitoring successfully set up!"
    echo "===================================================="
    echo "What this means:"
    echo "- AWS is now continuously checking your security groups"
    echo "- Any security groups allowing unrestricted SSH access will be flagged"
    echo "- This helps prevent unauthorized access to your systems"
    echo ""
    echo "To verify the rule configuration:"
    echo "  aws_config_check_rule restricted-ssh"
    echo ""
    echo "To find non-compliant security groups (after evaluation):"
    echo "  aws configservice get-compliance-details-by-config-rule \\"
    echo "    --config-rule-name restricted-ssh \\"
    echo "    --compliance-types NON_COMPLIANT"
    echo ""
    echo "Note: The initial evaluation may take up to 24 hours to complete"
}

# Test function to check for syntax issues
test_syntax() {
    echo "If this function runs, the file has no syntax errors."
}

# ----------------------------------------
# IAM MFA Security Functions 
# ----------------------------------------

# Enforce MFA for users in an IAM group
aws_enforce_mfa() {
    local group_name="$1"
    local force="${2:-false}"
    
    if [[ -z "$group_name" ]]; then
        echo "Usage: aws_enforce_mfa <group_name> [force]"
        echo "Example: aws_enforce_mfa Mil-Dev true"
        echo ""
        echo "Available groups:"
        aws_list_groups
        return 1
    fi
    
    # Check if group exists
    if ! run_aws_cmd iam get-group --group-name "$group_name" &>/dev/null; then
        echo "‚ùå Group '$group_name' not found"
        return 1
    fi
    
    echo "Creating MFA enforcement policy for group: $group_name"
    
    # Generate a policy name
    local policy_name="Require-MFA-${group_name}"
    
    # Create the MFA enforcement policy document
    local policy_json='{
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "AllowViewAccountInfo",
                "Effect": "Allow",
                "Action": [
                    "iam:GetAccountPasswordPolicy",
                    "iam:GetAccountSummary",
                    "iam:ListVirtualMFADevices"
                ],
                "Resource": "*"
            },
            {
                "Sid": "AllowManageOwnPasswords",
                "Effect": "Allow",
                "Action": [
                    "iam:ChangePassword",
                    "iam:GetUser"
                ],
                "Resource": "arn:aws:iam::*:user/${aws:username}"
            },
            {
                "Sid": "AllowManageOwnAccessKeys",
                "Effect": "Allow",
                "Action": [
                    "iam:CreateAccessKey",
                    "iam:DeleteAccessKey",
                    "iam:ListAccessKeys",
                    "iam:UpdateAccessKey"
                ],
                "Resource": "arn:aws:iam::*:user/${aws:username}"
            },
            {
                "Sid": "AllowManageOwnSigningCertificates",
                "Effect": "Allow",
                "Action": [
                    "iam:DeleteSigningCertificate",
                    "iam:ListSigningCertificates",
                    "iam:UpdateSigningCertificate",
                    "iam:UploadSigningCertificate"
                ],
                "Resource": "arn:aws:iam::*:user/${aws:username}"
            },
            {
                "Sid": "AllowManageOwnSSHPublicKeys",
                "Effect": "Allow",
                "Action": [
                    "iam:DeleteSSHPublicKey",
                    "iam:GetSSHPublicKey",
                    "iam:ListSSHPublicKeys",
                    "iam:UpdateSSHPublicKey",
                    "iam:UploadSSHPublicKey"
                ],
                "Resource": "arn:aws:iam::*:user/${aws:username}"
            },
            {
                "Sid": "AllowManageOwnVirtualMFADevice",
                "Effect": "Allow",
                "Action": [
                    "iam:CreateVirtualMFADevice",
                    "iam:DeleteVirtualMFADevice"
                ],
                "Resource": "arn:aws:iam::*:mfa/${aws:username}"
            },
            {
                "Sid": "AllowManageOwnUserMFA",
                "Effect": "Allow",
                "Action": [
                    "iam:DeactivateMFADevice",
                    "iam:EnableMFADevice",
                    "iam:ListMFADevices",
                    "iam:ResyncMFADevice"
                ],
                "Resource": "arn:aws:iam::*:user/${aws:username}"
            },
            {
                "Sid": "DenyAllExceptListedIfNoMFA",
                "Effect": "Deny",
                "NotAction": [
                    "iam:CreateVirtualMFADevice",
                    "iam:EnableMFADevice",
                    "iam:GetUser",
                    "iam:ListMFADevices",
                    "iam:ListVirtualMFADevices",
                    "iam:ResyncMFADevice",
                    "iam:ChangePassword",
                    "sts:GetSessionToken"
                ],
                "Resource": "*",
                "Condition": {
                    "BoolIfExists": {
                        "aws:MultiFactorAuthPresent": "false"
                    }
                }
            }
        ]
    }'
    
    # Create temporary policy file
    local tmp_file
    tmp_file=$(mktemp)
    echo "$policy_json" > "$tmp_file"
    
    # Check if policy already exists
    local policy_exists=false
    local policy_arn=""
    
    # Try to get policy
    policy_output=$(run_aws_cmd iam list-policies --scope Local --query "Policies[?PolicyName=='$policy_name']" --output json 2>/dev/null)
    if [[ "$policy_output" != *"[]"* && "$policy_output" != "" ]]; then
        policy_exists=true
        policy_arn=$(echo "$policy_output" | grep -o '"Arn": "[^"]*' | head -1 | cut -d'"' -f4)
        echo "‚úÖ MFA enforcement policy already exists: $policy_name"
    fi
    
    # Create policy if it doesn't exist
    if [[ "$policy_exists" == "false" ]]; then
        echo "Creating new MFA enforcement policy: $policy_name"
        policy_output=$(run_aws_cmd iam create-policy --policy-name "$policy_name" --policy-document "file://$tmp_file" --output json)
        if [[ $? -ne 0 || -z "$policy_output" ]]; then
            echo "‚ùå Failed to create MFA policy"
            rm "$tmp_file"
            return 1
        fi
        policy_arn=$(echo "$policy_output" | grep -o '"Arn": "[^"]*' | head -1 | cut -d'"' -f4)
        echo "‚úÖ Created MFA enforcement policy: $policy_name"
    fi
    
    # Clean up temp file
    rm "$tmp_file"
    
    if [[ -z "$policy_arn" ]]; then
        echo "‚ùå Failed to get policy ARN"
        return 1
    fi
    
    # Check if policy is already attached to the group
    attached_check=$(run_aws_cmd iam list-attached-group-policies --group-name "$group_name" --output json)
    if [[ "$attached_check" == *"$policy_arn"* ]]; then
        echo "‚úÖ MFA policy is already attached to group: $group_name"
    else
        # Attach policy to group
        echo "Attaching MFA enforcement policy to group: $group_name"
        if run_aws_cmd iam attach-group-policy --group-name "$group_name" --policy-arn "$policy_arn"; then
            echo "‚úÖ Successfully attached MFA enforcement policy to group: $group_name"
        else
            echo "‚ùå Failed to attach MFA policy to group"
            return 1
        fi
    fi
    
    # Get users in the group
    local users
    users=$(run_aws_cmd iam get-group --group-name "$group_name" --query "Users[].UserName" --output text)
    
    echo ""
    echo "‚óé Users in group '$group_name' will now be required to set up MFA"
    echo "‚óé Users without MFA will only be able to access enough permissions to set up MFA"
    
    # List users without MFA
    echo ""
    echo "Checking MFA status for users in group $group_name:"
    echo "------------------------------------------------------"
    for user in $users; do
        # Check if user has MFA enabled
        mfa_devices=$(run_aws_cmd iam list-mfa-devices --user-name "$user" --query "MFADevices[*]" --output text)
        if [[ -z "$mfa_devices" ]]; then
            echo "‚ö†Ô∏è $user: No MFA device configured"
        else
            echo "‚úÖ $user: MFA enabled"
        fi
    done
    
    echo ""
    echo "To add MFA for users, use: aws_add_mfa <username>"
    
    return 0
}

# Add MFA for a specific user
aws_add_mfa() {
    local user_name="$1"
    
    if [[ -z "$user_name" ]]; then
        echo "Usage: aws_add_mfa <username>"
        echo "Example: aws_add_mfa john.doe"
        
        # List users to help user
        echo ""
        echo "Available users:"
        aws_list_users
        return 1
    fi
    
    # Check if user exists
    if ! run_aws_cmd iam get-user --user-name "$user_name" &>/dev/null; then
        echo "‚ùå User '$user_name' not found"
        return 1
    fi
    
    # Check if user already has MFA
    local mfa_devices
    mfa_devices=$(run_aws_cmd iam list-mfa-devices --user-name "$user_name" --query "MFADevices[*]" --output text)
    if [[ -n "$mfa_devices" ]]; then
        echo "User '$user_name' already has MFA devices configured:"
        run_aws_cmd iam list-mfa-devices --user-name "$user_name" --output table
        
        echo -n "Do you want to add an additional MFA device? (y/n): "
        read add_additional
        if [[ "$add_additional" != "y" ]]; then
            echo "Operation cancelled."
            return 0
        fi
    fi
    
    # Prompt for MFA type
    echo "Select MFA type to add:"
    echo "1. Virtual MFA device (like Google Authenticator or Authy)"
    echo "2. Hardware MFA device (like YubiKey)"
    echo -n "Enter choice (1/2): "
    read mfa_type
    
    case "$mfa_type" in
        1)
            # Create virtual MFA device
            echo "Creating a virtual MFA device for user: $user_name"
            
            # Generate a unique name for the device
            local device_name="$user_name-mfa-device-$(date +%s)"
            
            # Create the virtual MFA device
            local create_output
            create_output=$(run_aws_cmd iam create-virtual-mfa-device \
                --virtual-mfa-device-name "$device_name" \
                --outfile "/tmp/qrcode.png" \
                --bootstrap-method QRCodePNG \
                --output json)
                
            if [[ $? -ne 0 || -z "$create_output" ]]; then
                echo "‚ùå Failed to create virtual MFA device"
                return 1
            fi
            
            # Extract the ARN of the virtual MFA device
            local virtual_mfa_arn
            virtual_mfa_arn=$(echo "$create_output" | grep -o '"SerialNumber": "[^"]*' | cut -d'"' -f4)
            
            if [[ -z "$virtual_mfa_arn" ]]; then
                echo "‚ùå Failed to extract virtual MFA device ARN"
                return 1
            fi
            
            echo "‚úÖ Virtual MFA device created: $device_name"
            echo "‚úÖ QR code saved to: /tmp/qrcode.png"
            echo "   Please open this file with an image viewer and scan with authenticator app"
            
            echo ""
            echo "After scanning the QR code with your authenticator app (like Google Authenticator),"
            echo "you'll need to enter two consecutive one-time passwords (OTPs)"
            echo ""
            
            echo -n "Enter the first one-time password from your app: "
            read -r auth_code1
            echo -n "Enter the second one-time password from your app: "
            read -r auth_code2
            
            # Attach the virtual MFA device to the user
            if run_aws_cmd iam enable-mfa-device \
                --user-name "$user_name" \
                --serial-number "$virtual_mfa_arn" \
                --authentication-code1 "$auth_code1" \
                --authentication-code2 "$auth_code2"; then
                
                echo "‚úÖ Successfully enabled MFA for user: $user_name"
                echo "‚úÖ The user can now authenticate with MFA"
                
                # Clean up the QR code file
                rm -f "/tmp/qrcode.png"
            else
                echo "‚ùå Failed to enable MFA device"
                echo "The codes may have been incorrect or expired. Please try again."
                return 1
            fi
            ;;
            
        2)
            # Hardware MFA device
            echo "To add a hardware MFA device like a YubiKey:"
            echo "1. Get the serial number or ARN of your hardware MFA device"
            echo -n "Enter hardware MFA device serial number or ARN: "
            read hardware_mfa_arn
            
            if [[ -z "$hardware_mfa_arn" ]]; then
                echo "No serial number provided. Operation cancelled."
                return 1
            fi
            
            echo "You'll need to generate two consecutive MFA codes from your hardware device:"
            echo -n "Enter the first code from your hardware MFA device: "
            read -r auth_code1
            echo -n "Enter the second code from your hardware MFA device: "
            read -r auth_code2
            
            # Enable the hardware MFA device
            if run_aws_cmd iam enable-mfa-device \
                --user-name "$user_name" \
                --serial-number "$hardware_mfa_arn" \
                --authentication-code1 "$auth_code1" \
                --authentication-code2 "$auth_code2"; then
                
                echo "‚úÖ Successfully enabled hardware MFA for user: $user_name"
                echo "‚úÖ The user can now authenticate with their hardware MFA device"
            else
                echo "‚ùå Failed to enable hardware MFA device"
                echo "The codes may have been incorrect or the device serial number is invalid."
                return 1
            fi
            ;;
            
        *)
            echo "Invalid choice. Operation cancelled."
            return 1
            ;;
    esac
    
    return 0
}

# List users without MFA
aws_list_users_without_mfa() {
    echo "Identifying users without MFA devices..."
    
    # Get all users
    local users
    users=$(run_aws_cmd iam list-users --query "Users[].UserName" --output text)
    
    echo "Users without MFA:"
    echo "------------------"
    local found_users_without_mfa=false
    
    for user in $users; do
        # Check if user has MFA enabled
        mfa_devices=$(run_aws_cmd iam list-mfa-devices --user-name "$user" --query "MFADevices[*]" --output text)
        if [[ -z "$mfa_devices" ]]; then
            echo "$user"
            found_users_without_mfa=true
        fi
    done
    
    if [[ "$found_users_without_mfa" == "false" ]]; then
        echo "‚úÖ All users have MFA enabled"
    else
        echo ""
        echo "To add MFA for a user, use: aws_add_mfa <username>"
    fi
    
    return 0
}

# Get VPC info for an EC2 instance
aws_instance_vpc_info() {
    local instance_id="$1"
    local region="$2"
    
    if [[ -z "$instance_id" ]]; then
        echo "Usage: aws_instance_vpc_info <instance-id> [region]"
        echo "Example: aws_instance_vpc_info i-038fb3978b3f8f5ca us-east-1"
        return 1
    fi
    
    # Set region if specified
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    echo "Looking up VPC for instance $instance_id..."
    
    # Get the VPC ID directly using the query parameter
    local vpc_id
    vpc_id=$(aws ec2 describe-instances \
              --instance-ids "$instance_id" \
              --query "Reservations[0].Instances[0].VpcId" \
              --output text 2>/dev/null)
    
    # Check if the command failed or returned empty/None
    if [[ $? -ne 0 || -z "$vpc_id" || "$vpc_id" == "None" ]]; then
        echo "‚ùå Could not find VPC ID for instance $instance_id"
        echo "Please check if the instance exists in this region."
        return 1
    fi
    
    echo "‚úÖ Found VPC: $vpc_id for instance $instance_id"
    echo ""
    
    echo "Gathering information about VPC $vpc_id..."
    echo "--------------------------"
    echo "VPC Details:"
    aws ec2 describe-vpcs --vpc-ids "$vpc_id" --output table
    
    echo "--------------------------"
    echo "Subnets in VPC:"
    aws ec2 describe-subnets \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "Subnets[].{ID:SubnetId,CIDR:CidrBlock,AZ:AvailabilityZone,Public:MapPublicIpOnLaunch,Name:Tags[?Key=='Name'].Value|[0]}" \
        --output table
    
    echo "--------------------------"
    echo "Route Tables:"
    aws ec2 describe-route-tables \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "RouteTables[].{ID:RouteTableId,Main:Associations[?Main].RouteTableAssociationId|[0],Name:Tags[?Key=='Name'].Value|[0]}" \
        --output table
    
    echo "--------------------------"
    echo "Security Groups:"
    aws ec2 describe-security-groups \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "SecurityGroups[].{ID:GroupId,Name:GroupName,Description:Description}" \
        --output table
    
    echo "--------------------------"
    echo "NACL Details:"
    aws ec2 describe-network-acls \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "NetworkAcls[].{ID:NetworkAclId,Default:IsDefault}" \
        --output table
    
    echo "--------------------------"
    echo "Instance Details in the VPC:"
    aws ec2 describe-instances \
        --filters "Name=vpc-id,Values=$vpc_id" \
        --query "Reservations[].Instances[].{ID:InstanceId,Type:InstanceType,State:State.Name,Name:Tags[?Key=='Name'].Value|[0],PrivateIP:PrivateIpAddress,PublicIP:PublicIpAddress}" \
        --output table
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
    
    return 0
}

# List EC2 instances with basic info
aws_list_instances() {
    local region="$1"
    local filter="$2"
    
    if [[ -n "$region" ]]; then
        export AWS_DEFAULT_REGION="$region"
        export AWS_REGION="$region"
        echo "Using region: $region"
    fi
    
    echo "Listing EC2 instances..."
    
    # Check if a filter was provided
    local filter_args=""
    if [[ -n "$filter" ]]; then
        echo "Filtering by: $filter"
        filter_args="--filters Name=tag:Name,Values=*${filter}* Name=instance-id,Values=*${filter}*"
    fi
    
    # Use eval to properly handle the filter arguments
    eval "aws ec2 describe-instances $filter_args --query \"Reservations[].Instances[].{InstanceId:InstanceId,Name:Tags[?Key=='Name'].Value|[0],Type:InstanceType,State:State.Name,PrivateIP:PrivateIpAddress,PublicIP:PublicIpAddress,VPC:VpcId,AZ:Placement.AvailabilityZone}\" --output text"
    
    # Return to previous region if we changed it
    if [[ -n "$region" ]]; then
        unset AWS_DEFAULT_REGION AWS_REGION
    fi
}

# Simple function to get the VPC ID for an EC2 instance
aws_get_vpc_id() {
    local instance_id="$1"
    local region="$2"
    
    if [[ -z "$instance_id" ]]; then
        echo "Usage: aws_get_vpc_id <instance-id> [region]"
        echo "Example: aws_get_vpc_id i-038fb3978b3f8f5ca us-east-2"
        return 1
    fi
    
    # Default to current region if not specified
    if [[ -z "$region" ]]; then
        region=$(aws configure get region)
        if [[ -z "$region" ]]; then
            region="us-east-1"  # Default AWS region
        fi
    fi
    
    echo "Looking up instance $instance_id in region $region..."
    
    # Try to get the instance information
    local vpc_id
    vpc_id=$(AWS_REGION=$region aws ec2 describe-instances --instance-ids "$instance_id" --query "Reservations[0].Instances[0].VpcId" --output text 2>/dev/null)
    
    # Check the result
    if [[ $? -ne 0 || -z "$vpc_id" || "$vpc_id" == "None" ]]; then
        echo "‚ùå Could not find instance $instance_id in region $region"
        return 1
    fi
    
    echo "‚úÖ Instance $instance_id is in VPC: $vpc_id"
    
    # Add command suggestions for next steps
    echo ""
    echo "To view more information about this VPC, run:"
    echo "AWS_REGION=$region aws ec2 describe-vpcs --vpc-ids $vpc_id"
    echo ""
    echo "To list subnets in this VPC, run:"
    echo "AWS_REGION=$region aws ec2 describe-subnets --filters \"Name=vpc-id,Values=$vpc_id\""
    
    return 0
}

# Secure a security group by restricting SSH access
aws_secure_sg() {
    local sg_id="$1"
    local region="$2"
    local ip_address="$3"
    
    if [[ -z "$sg_id" ]]; then
        echo "Usage: aws_secure_sg <security-group-id> [region] [your-ip-address]"
        echo "Example: aws_secure_sg sg-048cf7e0b6433df0b us-east-2"
        echo "If no IP address is provided, your current public IP will be used."
        return 1
    fi
    
    # Default to current region if not specified
    if [[ -z "$region" ]]; then
        region=$(aws configure get region)
        if [[ -z "$region" ]]; then
            region="us-east-1"  # Default AWS region
        fi
    fi
    
    # If IP address not provided, get the current public IP
    if [[ -z "$ip_address" ]]; then
        echo "Detecting your current public IP address..."
        ip_address=$(curl -s https://checkip.amazonaws.com)
        if [[ -z "$ip_address" ]]; then
            echo "‚ùå Failed to detect your public IP address"
            echo "Please provide your IP address manually"
            return 1
        fi
        echo "Detected IP: $ip_address"
    fi
    
    # Add /32 suffix if not already present (to create a single IP CIDR)
    if [[ ! "$ip_address" =~ /[0-9]+$ ]]; then
        ip_address="${ip_address}/32"
    fi
    
    echo "Checking security group $sg_id in region $region..."
    
    # Check if the security group exists
    if ! AWS_REGION=$region aws ec2 describe-security-groups --group-ids "$sg_id" &>/dev/null; then
        echo "‚ùå Security group $sg_id not found in region $region"
        return 1
    fi
    
    # Check for wide-open SSH access
    echo "Looking for unrestricted SSH access..."
    local has_open_ssh=false
    local ssh_rules
    ssh_rules=$(AWS_REGION=$region aws ec2 describe-security-groups \
        --group-ids "$sg_id" \
        --query "SecurityGroups[0].IpPermissions[?FromPort==\`22\` && contains(IpRanges[].CidrIp, '0.0.0.0/0')]" \
        --output json)
    
    if [[ "$ssh_rules" != "[]" && -n "$ssh_rules" ]]; then
        has_open_ssh=true
        echo "‚ö†Ô∏è Found unrestricted SSH access (0.0.0.0/0)"
        
        echo -n "Do you want to remove the unrestricted SSH rule? (y/n): "
        read remove_rule
        if [[ "$remove_rule" == "y" ]]; then
            echo "Removing unrestricted SSH access..."
            if AWS_REGION=$region aws ec2 revoke-security-group-ingress \
                --group-id "$sg_id" \
                --protocol tcp \
                --port 22 \
                --cidr 0.0.0.0/0; then
                echo "‚úÖ Unrestricted SSH access removed"
            else
                echo "‚ùå Failed to remove unrestricted SSH access"
                return 1
            fi
        else
            echo "‚ö†Ô∏è Keeping unrestricted SSH access (not recommended)"
        fi
    else
        echo "‚úÖ No unrestricted SSH access found"
    fi
    
    # Check if SSH access from the specific IP already exists
    local has_specific_rule=false
    local specific_rules
    specific_rules=$(AWS_REGION=$region aws ec2 describe-security-groups \
        --group-ids "$sg_id" \
        --query "SecurityGroups[0].IpPermissions[?FromPort==\`22\` && contains(IpRanges[].CidrIp, '$ip_address')]" \
        --output json)
    
    if [[ "$specific_rules" != "[]" && -n "$specific_rules" ]]; then
        has_specific_rule=true
        echo "‚úÖ SSH access already allowed from your IP ($ip_address)"
    else
        echo "No SSH access rule found for your IP ($ip_address)"
        
        echo -n "Do you want to add SSH access for your IP only? (y/n): "
        read add_rule
        if [[ "$add_rule" == "y" ]]; then
            echo "Adding SSH access for your IP ($ip_address)..."
            if AWS_REGION=$region aws ec2 authorize-security-group-ingress \
                --group-id "$sg_id" \
                --protocol tcp \
                --port 22 \
                --cidr "$ip_address"; then
                echo "‚úÖ SSH access added for your IP only"
            else
                echo "‚ùå Failed to add SSH access for your IP"
                return 1
            fi
        else
            echo "No SSH access added for your IP"
        fi
    fi
    
    # Final summary
    echo ""
    echo "Security Group: $sg_id"
    echo "Region: $region"
    
    # Check current SSH rules to show final state
    local current_ssh_rules
    current_ssh_rules=$(AWS_REGION=$region aws ec2 describe-security-groups \
        --group-ids "$sg_id" \
        --query "SecurityGroups[0].IpPermissions[?FromPort==\`22\`].IpRanges[].CidrIp" \
        --output json)
    
    echo "Current SSH access allowed from: $current_ssh_rules"
    
    # Verify if security group is now secure
    if [[ "$current_ssh_rules" == "[]" ]]; then
        echo "‚ö†Ô∏è No SSH access is currently allowed"
    elif [[ "$current_ssh_rules" == *"0.0.0.0/0"* ]]; then
        echo "‚ö†Ô∏è WARNING: SSH is still accessible from anywhere (0.0.0.0/0)"
        echo "This is a security risk. Consider restricting access."
    else
        echo "‚úÖ SSH access is properly restricted"
    fi
    
    return 0
}