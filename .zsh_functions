# ----------------------
# General Shell Functions
# ----------------------

# Unalias any conflicting aliases that may have been defined in other config files
# This prevents "defining function based on alias" errors
unalias ccopy cpaste clipls clipcat clippwd clipip fhist sanitize_filename download_video \
        igtok trim_vid mkd reset_file zipfile backup cdl show_func show_alias show_help helpmenu \
        dl dlvid dlaudio dl720 dl1080 dlfix vcheck vfix vinfo check_video_format \
        2>/dev/null

# Disable glob expansion for these aliases to allow URLs with special characters
# This prevents "no matches found" errors when using URLs with ? or * characters
# Now you can use: dl https://example.com/video?id=123 (without quotes!)
alias dl='noglob download_video'
alias dlvid='noglob download_video'
alias dlaudio='noglob download_video --audio-only'
alias dl720='noglob download_video --quality 720p'
alias dl1080='noglob download_video --quality 1080p'

# Download with automatic format checking for QuickTime/macOS compatibility
alias dlfix='noglob download_video --check-format'

# Video format checking aliases
alias vcheck='check_video_format'  # Check only (no fix)
alias vfix='check_video_format'    # Check and fix
alias vinfo='check_video_format'   # Alias for checking info

# Note: igtok is a function and handles URLs correctly without noglob
  # Normalize time to hh:mm:ss.
  # If only seconds are provided (e.g. "10"), prepend "00:00:".
  # If minutes and seconds are provided (e.g. "01:00"), prepend "00:".
  normalize_time() {
    local input="$1"
    if [[ "$input" =~ ^[0-9]+$ ]]; then
      printf "00:00:%02d" "$input"
    elif [[ "$input" =~ ^[0-9]+:[0-9]+$ ]]; then
      printf "00:%s" "$input"
    else
      echo "$input"
    fi
  }

# ----------------------
# Clip Board
# ----------------------
ccopy()  { pbcopy < "$1"; } # copy to clipboard
cpaste() { pbpaste; } # paste from clipboard
clipls() { ls -l | pbcopy; } # list directory contents and copy to clipboard
clipcat() { cat "$1" | pbcopy; } # copy file contents to clipboard
clippwd() { pwd | pbcopy; } # copy current directory to clipboard
clipip() { ipconfig getifaddr en0 | pbcopy; } # copy en0 ip address to clipboard
# temp copy to clipboard by backing up current clipboard, then copying to clipboard, then restoring clipboard


# Fuzzy-search your shell history and re-run a command
fhist() {
  local cmd
  cmd=$(fc -l 1 | sed 's/ *[0-9]* *//' | fzf --height 40% --reverse) && print -s -- "$cmd" && eval "$cmd"
}

# ----------------------
# Video and Audio Manipulation
# These functions are used to trim videos and audio files as well as convert them to different formats

# Sanitize filename - remove spaces and special characters
sanitize_filename() {
  local filename="$1"
  # Convert to lowercase, replace spaces with underscores, keep only alphanumeric, underscores, dots, and dashes
  echo "$filename" | tr '[:upper:]' '[:lower:]' | tr ' ' '_' | tr -cd '[:alnum:]_.-'
}

# Check and fix video format compatibility issues
# Converts incompatible videos to macOS-compatible format (H.264 + AAC in MP4)
check_video_format() {
  local video_file="$1"
  local auto_fix="${2:-true}"  # Auto-fix by default
  local output_path="${3:-}"    # Optional output path

  if [[ -z "$video_file" ]]; then
    echo "Usage: check_video_format <video_file> [auto_fix:true|false] [output_path]"
    echo ""
    echo "Checks video format compatibility with macOS/QuickTime and optionally fixes issues."
    echo "Output defaults to /tmp/, falls back to ./ or ~/ if permission issues."
    echo ""
    echo "Examples:"
    echo "  check_video_format video.mp4                      # Check and auto-fix to /tmp/"
    echo "  check_video_format video.mp4 false                # Check only, don't fix"
    echo "  check_video_format video.webm                     # Convert WebM to /tmp/"
    echo "  check_video_format video.mp4 true ~/Downloads    # Fix to specific directory"
    return 1
  fi

  if [[ ! -f "$video_file" ]]; then
    echo "‚ùå Error: File not found: $video_file"
    return 1
  fi

  # Check if ffprobe and ffmpeg are installed
  if ! command -v ffprobe &>/dev/null; then
    echo "‚ùå ffprobe not found. Install with: brew install ffmpeg"
    return 1
  fi

  if ! command -v ffmpeg &>/dev/null; then
    echo "‚ùå ffmpeg not found. Install with: brew install ffmpeg"
    return 1
  fi

  echo "üîç Analyzing video format: $video_file"
  echo ""

  # Get video information
  local video_codec=$(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null)
  local audio_codec=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null)
  local container=$(ffprobe -v error -show_entries format=format_name -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null)
  local duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null)
  local width=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null)
  local height=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of default=noprint_wrappers=1:nokey=1 "$video_file" 2>/dev/null)

  # Display current format
  echo "üìä Current Format:"
  echo "   Container: $container"
  echo "   Video Codec: ${video_codec:-none}"
  echo "   Audio Codec: ${audio_codec:-none}"
  [[ -n "$width" && -n "$height" ]] && echo "   Resolution: ${width}x${height}"
  [[ -n "$duration" ]] && printf "   Duration: %.2f seconds\n" "$duration"
  echo ""

  # Check compatibility
  local needs_fix=false
  local issues=()

  # macOS/QuickTime prefers: H.264 video, AAC audio, MP4 container
  if [[ "$video_codec" != "h264" && -n "$video_codec" ]]; then
    needs_fix=true
    issues+=("Video codec '$video_codec' may not be compatible (prefer H.264)")
  fi

  if [[ "$audio_codec" != "aac" && -n "$audio_codec" ]]; then
    needs_fix=true
    issues+=("Audio codec '$audio_codec' may not be compatible (prefer AAC)")
  fi

  if [[ "$container" != *"mp4"* && "$container" != *"mov"* ]]; then
    needs_fix=true
    issues+=("Container format '$container' may not be compatible (prefer MP4/MOV)")
  fi

  # Special cases
  if [[ "$container" == *"matroska"* || "$container" == *"webm"* ]]; then
    needs_fix=true
    issues+=("MKV/WebM containers often have QuickTime compatibility issues")
  fi

  if [[ "$video_codec" == "vp9" || "$video_codec" == "vp8" || "$video_codec" == "av1" ]]; then
    needs_fix=true
    issues+=("VP8/VP9/AV1 codecs are not natively supported by QuickTime")
  fi

  if [[ "$video_codec" == "hevc" ]]; then
    echo "‚ö†Ô∏è  HEVC/H.265 detected - may require newer macOS version"
    # HEVC is supported on macOS, but older versions may have issues
  fi

  # Report issues
  if [[ ${#issues[@]} -eq 0 ]]; then
    echo "‚úÖ Video format is compatible with macOS/QuickTime!"
    echo "   No conversion needed."
    return 0
  fi

  echo "‚ö†Ô∏è  Compatibility Issues Found:"
  for issue in "${issues[@]}"; do
    echo "   ‚Ä¢ $issue"
  done
  echo ""

  # Ask to fix if not auto-fixing
  if [[ "$auto_fix" != "true" ]]; then
    echo "Run with auto_fix=true to convert, or use:"
    echo "  check_video_format \"$video_file\" true"
    return 1
  fi

  # Determine output directory with fallback logic
  local input_name=$(basename "$video_file")
  local input_base="${input_name%.*}"
  local output_dir=""
  local tried_locations=()

  # Function to test if directory is writable
  _test_write_permission() {
    local test_dir="$1"
    local test_file="${test_dir}/.write_test_$$"

    if [[ ! -d "$test_dir" ]]; then
      return 1
    fi

    if touch "$test_file" 2>/dev/null; then
      rm -f "$test_file" 2>/dev/null
      return 0
    else
      return 1
    fi
  }

  # Try user-specified path first
  if [[ -n "$output_path" ]]; then
    # Expand ~ to home directory
    output_path="${output_path/#\~/$HOME}"

    if _test_write_permission "$output_path"; then
      output_dir="$output_path"
      echo "üìÅ Using specified output directory: $output_dir"
    else
      tried_locations+=("$output_path (no write permission)")
    fi
  fi

  # Try /tmp/ if no output dir yet
  if [[ -z "$output_dir" ]]; then
    if _test_write_permission "/tmp"; then
      output_dir="/tmp"
      echo "üìÅ Using /tmp/ for output"
    else
      tried_locations+=("/tmp (no write permission)")
    fi
  fi

  # Fall back to current directory
  if [[ -z "$output_dir" ]]; then
    if _test_write_permission "."; then
      output_dir="."
      echo "üìÅ Falling back to current directory"
    else
      tried_locations+=("./ (no write permission)")
    fi
  fi

  # Fall back to home directory
  if [[ -z "$output_dir" ]]; then
    if _test_write_permission "$HOME"; then
      output_dir="$HOME"
      echo "üìÅ Falling back to home directory"
    else
      tried_locations+=("~/ (no write permission)")
    fi
  fi

  # If still no writable location found, error out
  if [[ -z "$output_dir" ]]; then
    echo "‚ùå Error: Cannot find writable directory for output"
    echo "Tried locations:"
    for loc in "${tried_locations[@]}"; do
      echo "  ‚Ä¢ $loc"
    done
    return 1
  fi

  # Create output filename
  local output_file="${output_dir}/${input_base}_fixed.mp4"

  # Check if output already exists
  if [[ -f "$output_file" ]]; then
    echo "‚ö†Ô∏è  Output file already exists: $output_file"
    read -p "Overwrite? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "Aborted."
      return 1
    fi
  fi

  echo "üîß Converting to macOS-compatible format..."
  echo "   Output: $output_file"
  echo ""

  # Convert with progress
  # Use H.264 video codec, AAC audio codec, MP4 container
  # -c:v libx264 = H.264 video codec
  # -preset medium = encoding speed (ultrafast, fast, medium, slow, slower)
  # -crf 23 = quality (0-51, lower = better quality, 23 is default)
  # -c:a aac = AAC audio codec
  # -b:a 192k = audio bitrate
  # -movflags +faststart = optimize for streaming/quick preview

  local start_time=$(date +%s)

  if ffmpeg -i "$video_file" \
    -c:v libx264 \
    -preset medium \
    -crf 23 \
    -c:a aac \
    -b:a 192k \
    -movflags +faststart \
    -y \
    "$output_file" 2>&1 | grep -E 'time=|Duration:'; then

    local end_time=$(date +%s)
    local elapsed=$((end_time - start_time))

    echo ""
    echo "‚úÖ Conversion complete! (took ${elapsed}s)"
    echo ""
    echo "üìä New Format:"

    # Show new format info
    local new_video_codec=$(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$output_file" 2>/dev/null)
    local new_audio_codec=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$output_file" 2>/dev/null)

    echo "   Container: MP4"
    echo "   Video Codec: $new_video_codec"
    echo "   Audio Codec: $new_audio_codec"
    echo ""

    # Compare file sizes
    local original_size=$(stat -f%z "$video_file" 2>/dev/null || stat -c%s "$video_file" 2>/dev/null)
    local new_size=$(stat -f%z "$output_file" 2>/dev/null || stat -c%s "$output_file" 2>/dev/null)

    printf "   Original: %.2f MB\n" $((original_size / 1024.0 / 1024.0))
    printf "   New:      %.2f MB\n" $((new_size / 1024.0 / 1024.0))

    local size_diff=$((new_size - original_size))
    if [[ $size_diff -gt 0 ]]; then
      printf "   Increase: +%.2f MB\n" $((size_diff / 1024.0 / 1024.0))
    else
      printf "   Decrease: -%.2f MB\n" $((-size_diff / 1024.0 / 1024.0))
    fi

    echo ""
    echo "üé¨ Fixed video: $output_file"
    echo "   You can now open it in QuickTime Player!"

    return 0
  else
    echo ""
    echo "‚ùå Conversion failed. Check the error messages above."
    return 1
  fi
}

download_video() {
  # Usage: download_video url [options]
  # Options:
  #   --output/-o FILENAME    Output filename (default: auto-generated from title)
  #   --start/-s TIME         Start time (format: HH:MM:SS or seconds)
  #   --end/-e TIME           End time (format: HH:MM:SS or seconds)
  #   --quality/-q QUALITY    Video quality (best, 1080p, 720p, 480p, 360p, worst)
  #   --format/-f FORMAT      Format (mp4, webm, mp3, etc.)
  #   --subtitles/-sub        Download subtitles if available (default: false, default language: en)
  #   --language/-l LANGUAGE  Language (default: en)
  #   --audio-only/-a         Download audio only
  #   --help/-h               Show this help message

  # Show help if requested or no arguments provided
  if [[ "$1" == "--help" || "$1" == "-h" || -z "$1" ]]; then
    echo "Usage: download_video url [options]"
    echo "Options:"
    echo "  --output, -o FILENAME    Output filename (default: auto-generated from title)"
    echo "  --start, -s TIME         Start time (format: HH:MM:SS or seconds)"
    echo "  --end, -e TIME           End time (format: HH:MM:SS or seconds)"
    echo "  --quality, -q QUALITY    Video quality (best, 1080p, 720p, 480p, 360p, worst)"
    echo "  --format, -f FORMAT      Format (mp4, webm, mp3, etc.)"
    echo "  --subtitles, -sub        Download subtitles if available (default: false, default language: en)"
    echo "  --language, -l LANGUAGE  Language (default: en)"
    echo "  --audio-only, -a         Download audio only"
    echo "  --no-sanitize            Keep original filename (don't remove spaces/special chars)"
    echo "  --check-format           Check and fix video format after download (for QuickTime compatibility)"
    echo "  --output-dir, -d DIR     Output directory (default: /tmp/, falls back to ./ or ~/)"
    echo "  --help, -h               Show this help message"
    echo ""
    echo "Note: Filenames are sanitized by default (lowercase, underscores instead of spaces)"
    echo "      Downloads save to /tmp/ by default (with fallback to ./ or ~/)"
    echo "      Use --check-format to ensure QuickTime/macOS compatibility"
    return 0
  fi

  # Check if yt-dlp or youtube-dl is installed (prefer yt-dlp)
  local downloader=""
  if command -v yt-dlp &> /dev/null; then
    downloader="yt-dlp"
  elif command -v youtube-dl &> /dev/null; then
    downloader="youtube-dl"
  else
    echo "‚ùå Neither yt-dlp nor youtube-dl could be found"
    echo "yt-dlp is the recommended modern replacement for youtube-dl"
    # Prompt the user to install yt-dlp
    read -p "Do you want to install yt-dlp? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      brew install yt-dlp
      downloader="yt-dlp"
    else
      return 1
    fi
  fi

  echo "üì• Using downloader: $downloader"

  # Parse arguments
  local url="$1"
  local output_filename=""
  local start_time=""
  local end_time=""
  local quality="best"
  local format=""
  local subtitles=false
  local language="en"
  local audio_only=false
  local sanitize=true
  local check_format=false
  local output_dir_override=""
  local ytdl_args=()
  
  shift # Skip the URL arg

  # Validate the URL
  if [[ ! "$url" =~ ^https?:// ]]; then
    echo "‚ùå Invalid URL: $url"
    echo "URL must start with http:// or https://"
    return 1
  fi

  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --output|-o)
        shift
        output_filename="$1"
        ;;
      --start|-s)
        shift
        start_time=$(normalize_time "$1")
        ;;
      --end|-e)
        shift
        end_time=$(normalize_time "$1")
        ;;
      --quality|-q)
        shift
        quality="$1"
        ;;
      --format|-f)
        shift
        format="$1"
        ;;
      --subtitles|-sub)
        subtitles=true
        ;;
      --language|-l)
        shift
        language="$1"
        ;;
      --audio-only|-a)
        audio_only=true
        ;;
      --no-sanitize)
        sanitize=false
        ;;
      --check-format)
        check_format=true
        ;;
      --output-dir|-d)
        shift
        output_dir_override="$1"
        ;;
      *)
        echo "‚ùå Unknown option: $1"
        echo "Use 'download_video --help' to see available options"
        return 1
        ;;
    esac
    shift
  done

  # Build youtube-dl arguments
  if [[ "$audio_only" == true ]]; then
    ytdl_args+=("-x" "--audio-format" "mp3")
  else
    # Handle video quality
    case "$quality" in
      best)
        ytdl_args+=("-f" "bestvideo+bestaudio/best")
        ;;
      1080p)
        ytdl_args+=("-f" "bestvideo[height<=1080]+bestaudio/best[height<=1080]")
        ;;
      720p)
        ytdl_args+=("-f" "bestvideo[height<=720]+bestaudio/best[height<=720]")
        ;;
      480p)
        ytdl_args+=("-f" "bestvideo[height<=480]+bestaudio/best[height<=480]")
        ;;
      360p)
        ytdl_args+=("-f" "bestvideo[height<=360]+bestaudio/best[height<=360]")
        ;;
      worst)
        ytdl_args+=("-f" "worstvideo+worstaudio/worst")
        ;;
      *)
        ytdl_args+=("-f" "best") # Default to best quality
        ;;
    esac
  fi

  # Handle format if specified
  if [[ -n "$format" ]]; then
    ytdl_args+=(--recode-video "$format")
  fi

  # Handle subtitles
  if [[ "$subtitles" == true ]]; then
    ytdl_args+=(--write-sub --convert-subs srt --sub-lang "$language")
  fi

  # Determine output directory (prefer /tmp/, fall back to ./ or ~/)
  local download_dir=""

  # Use user-specified directory if provided
  if [[ -n "$output_dir_override" ]]; then
    # Expand ~ to home directory
    output_dir_override="${output_dir_override/#\~/$HOME}"

    if [[ ! -d "$output_dir_override" ]]; then
      echo "‚ùå Error: Directory does not exist: $output_dir_override"
      return 1
    fi

    if [[ -w "$output_dir_override" ]]; then
      download_dir="$output_dir_override"
    else
      echo "‚ùå Error: No write permission for: $output_dir_override"
      return 1
    fi
  # Try /tmp/ first
  elif [[ -w "/tmp" ]]; then
    download_dir="/tmp"
  # Fall back to current directory
  elif [[ -w "." ]]; then
    download_dir="."
  # Fall back to home directory
  elif [[ -w "$HOME" ]]; then
    download_dir="$HOME"
  else
    echo "‚ùå Error: Cannot find writable directory for download"
    return 1
  fi

  # Handle output filename
  if [[ -n "$output_filename" ]]; then
    # Sanitize filename: replace spaces with underscores, remove special characters
    output_filename=$(echo "$output_filename" | tr ' ' '_' | tr -cd '[:alnum:]._-')
    ytdl_args+=(-o "${download_dir}/${output_filename}.%(ext)s")
  else
    # Auto-generate filename from title
    ytdl_args+=(-o "${download_dir}/%(title)s.%(ext)s")
  fi

  echo "üìÅ Download directory: $download_dir"

  # Download the video
  echo "üé¨ Downloading from: $url"
  echo "‚öôÔ∏è Options: quality=$quality, format=$format"
  [[ -n "$start_time" ]] && echo "Starting at: $start_time"
  [[ -n "$end_time" ]] && echo "Ending at: $end_time"
  
  # Download with yt-dlp or youtube-dl - capture output for error detection
  local download_output=$(mktemp)
  local download_error=$(mktemp)

  if $downloader "${ytdl_args[@]}" "$url" > "$download_output" 2> "$download_error"; then
    echo "‚úÖ Download complete!"

    # Get the downloaded filename (with full path)
    local downloaded_file="${download_dir}/$($downloader --get-filename -o "%(title)s.%(ext)s" "$url" 2>/dev/null)"

    # Sanitize filename if enabled
    if [[ "$sanitize" == true && -f "$downloaded_file" ]]; then
      local dir=$(dirname "$downloaded_file")
      local basename=$(basename "$downloaded_file")
      local extension="${basename##*.}"
      local filename_no_ext="${basename%.*}"

      # Sanitize the filename (without extension)
      local sanitized_name=$(sanitize_filename "$filename_no_ext")
      local new_file="${dir}/${sanitized_name}.${extension}"

      if [[ "$downloaded_file" != "$new_file" ]]; then
        echo "üìù Sanitizing filename..."
        echo "   From: $basename"
        echo "   To: $(basename "$new_file")"
        mv "$downloaded_file" "$new_file"
        downloaded_file="$new_file"
      fi
    fi

    # Post-processing: trim if start/end times were specified
    if [[ -n "$start_time" || -n "$end_time" ]]; then
      echo "üî™ Trimming video..."
      # Call trim_vid to handle the trimming
      trim_vid "$downloaded_file" --start "$start_time" --end "$end_time"
    fi

    # Check and fix format if requested
    if [[ "$check_format" == true && "$audio_only" == false ]]; then
      echo ""
      echo "üîç Checking video format compatibility..."
      check_video_format "$downloaded_file" true

      # If a _fixed version was created, update the downloaded_file reference
      local fixed_file="${downloaded_file%.*}_fixed.mp4"
      if [[ -f "$fixed_file" ]]; then
        downloaded_file="$fixed_file"
      fi
    fi

    echo "üìÅ Final file: $downloaded_file"
    rm -f "$download_output" "$download_error"
    return 0
  else
    # Check error output for specific known errors
    local error_msg=$(cat "$download_error")

    if [[ "$error_msg" =~ "No video could be found" ]]; then
      echo "üì≠ No video found in this URL"
      echo "   This URL may contain:"
      echo "   ‚Ä¢ Text-only content"
      echo "   ‚Ä¢ Images only"
      echo "   ‚Ä¢ External links without embedded video"
    elif [[ "$error_msg" =~ "Unsupported URL" ]]; then
      echo "‚ùå Unsupported URL or platform"
      echo "   The downloader doesn't support this website"
    elif [[ "$error_msg" =~ "Private video" || "$error_msg" =~ "This video is private" ]]; then
      echo "üîí This video is private or requires authentication"
    elif [[ "$error_msg" =~ "Video unavailable" ]]; then
      echo "üìµ Video unavailable (may be deleted or restricted)"
    else
      echo "‚ùå Download failed!"
      # Show first line of error for debugging
      echo "   Error: $(echo "$error_msg" | head -1 | sed 's/ERROR: //')"
    fi

    rm -f "$download_output" "$download_error"
    return 1
  fi
}

# Quick download for Instagram/TikTok/etc
igtok() {
  if [[ -z "$1" ]]; then
    echo "Usage: igtok <instagram/tiktok/twitter url> [output_name]"
    echo "Quick download for Instagram, TikTok, Twitter, etc."
    return 1
  fi

  local url="$1"
  local output="${2:-}"

  if [[ -n "$output" ]]; then
    download_video "$url" --output "$output"
  else
    download_video "$url"
  fi
}


trim_vid() {
  local file=""
  local start=""
  local end=""
  # Parse arguments.
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --start|-ss)
        shift
        start=$(normalize_time "$1")
        ;;
      --end|-to)
        shift
        end=$(normalize_time "$1")
        ;;
      *)
        # Assume the first non-option is the filename.
        if [[ -z "$file" ]]; then
          file="$1"
        fi
        ;;
    esac
    shift
  done

  if [[ -z "$file" ]]; then
    echo "‚ùå No valid input file provided."
    return 1
  fi

  if [[ ! -f "$file" ]]; then
    echo "‚ùå File not found: $file"
    return 1
  fi

  # Generate output filename by replacing spaces and special characters with underscores.
  local filename="${file##*/}"
  local basename="${filename%.*}"
  local extension="${filename##*.}"
  local cleanname
  cleanname="$(echo "$basename" | tr -cs '[:alnum:]' '_')_trimmed.$extension"

  # Build and run ffmpeg command.
  local cmd=(ffmpeg)
  [[ -n "$start" ]] && cmd+=(-ss "$start")
  cmd+=(-i "$file")
  [[ -n "$end" ]] && cmd+=(-to "$end")
  cmd+=(-c:v libx264 -c:a aac "$cleanname")

  echo "üé¨ Trimming: $file"
  echo "‚û°Ô∏è Output:   $cleanname"
  echo "Running: ${cmd[*]}"
  "${cmd[@]}"
}

# Create a directory and cd to it if only one arg is passed else just make the dir
mkd(){
    if [[ -z "$1" ]]; then
        echo "No directory name provided"
        return 1
    # If multiple args are passed then make the dirs and list them
    elif [[ $# -gt 1 ]]; then
        mkdir -p "$@" && ls -l "$@"
    # Otherwise, make the dir and cd to it (single argument case)
    else
        mkdir -p "$1" && cd "$1"
        pwd # print the current directory
        lt # list the directory contents 
    fi
}

# Reset file content
reset_file(){
    # usage: reset_file file1 file2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "Usage: reset_file file1 file2 ..."
        return 0
    fi
    
    # Check if arguments are provided
    if [[ $# -eq 0 ]]; then
        echo "Error: No files specified"
        echo "Usage: reset_file file1 file2 ..."
        return 1
    fi
    
    # Reset the file content to an empty string
    # use the backup function to create a backup of the file before erasing
    #handle one or multiple files
    # catch escapes and errors to handle prompting user to restore backup or delete
    for file in "$@"; do
        # Check if file exists
        if [[ ! -f "$file" ]]; then
            echo "Error: File '$file' does not exist"
            continue
        fi
        
        # Generate backup filename first
        local backup_suffix=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
        local backup_filename="${file}${backup_suffix}"
        
        # Create backup manually
        if command -v rsync &> /dev/null; then
            rsync "$file" "$backup_filename"
        else
            cp "$file" "$backup_filename"
        fi
        echo "Backup of $file created as $backup_filename"
        
        # Clear the file content
        echo "" > "$file"
        echo "File content backed up and erased."
        echo "Opening $file in nano editor"
        
        # Add a comment with the filename
        echo "# $file" >> "$file"
        
        # Sleep briefly
        sleep 0.5
        
        # Open in nano editor
        nano "$file"
        
        # Show the backup file
        ls "$backup_filename"
        
        # Ask user about seeing diff
        local see_diff="n"
        echo -n "Do you want to see the difference between the original and backup file? (y/n):(default:n) "
        read see_diff
        
        if [[ "$see_diff" == "y" ]]; then
            # Use diff command safely
            if command -v diff &> /dev/null; then
                diff "$file" "$backup_filename"
            else
                echo "diff command not found"
            fi
            
            # Ask about restoring backup
            local restore_backup="n"
            echo -n "Do you want to restore the backup file? (y/n):(default:n) "
            read restore_backup
            
            if [[ "$restore_backup" == "y" ]]; then
                mv "$backup_filename" "$file"
                echo "Backup file restored."
            fi
        fi
    done
}

# Create a zip archive
zipfile(){
    # usage: zipfile name file_or_dir1 file_or_dir2 ...
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        echo "usage: zipfile name_of_zip_file file_or_dir1 file_or_dir2 ..."
        return 0
    fi
    # check if args are passed
    # check if name is passed or if file or dir is passed
    # If name is passed then zip the file or dir with the name
    # if no name is passed then zip the file or dir with the name of the file or dir
    # if multiple files or dirs are passed then zip them all with the name of the first file or dir + more + .zip
}

# create backup of a file or directory
backup(){
  # human readiable date and time with backup
  # check if dir or files exists
  backup_name=".bak_$(date +%Y-%m-%d_%H-%M-%S)"
  # check if rsync is installed if not set copy command to cp
  if command -v rsync &> /dev/null; then
    COPY_CMD="rsync"
  else
    COPY_CMD="cp"
  fi
  
  # take files, dictionaries as arguments get full path as needed many args possible
  for file in "$@"; do
    if [ -f "$file" ]; then
      $COPY_CMD "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    elif [ -d "$file" ]; then
      $COPY_CMD -r "$file" "$file$backup_name"
      echo "Backup of $file created as $file$backup_name"
    else
      echo "$file does not exist"
    fi
  done
}

# change dir and List Directory Contents
cdl(){
  if [ -n "$1" ]; then
    cd "$1" && ll
  else
    cd ~ && ll
  fi
}

# Help functions
show_func(){
    # usage: show_help function_name
    # show the help for a specific function
    local files=("$HOME/.zsh_aliases" "$HOME/.zsh_functions" "$HOME/.zsh_git" "$HOME/.zsh_apps" "$HOME/.zsh_network" "$HOME/.zsh_transfer" "$HOME/.zsh_security" "$HOME/.zsh_utils")
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" "$file"
        fi
    done
}

alias show_function="show_func"

show_alias(){
    # usage: show_alias
    # show all the aliases in all zsh config files
    local files=("$HOME/.zsh_aliases" "$HOME/.zsh_functions" "$HOME/.zsh_git" "$HOME/.zsh_apps" "$HOME/.zsh_network" "$HOME/.zsh_transfer" "$HOME/.zsh_security" "$HOME/.zsh_utils")
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            echo "Aliases in $file:"
            grep -E "^alias " "$file" | cut -d '=' -f 1 | sort | uniq
            echo ""
        fi
    done
}

show_help(){
    # usage: show_help function_name
    # show the help for a specific function
    local files=("$HOME/.zsh_aliases" "$HOME/.zsh_functions" "$HOME/.zsh_git" "$HOME/.zsh_apps" "$HOME/.zsh_network" "$HOME/.zsh_transfer" "$HOME/.zsh_security" "$HOME/.zsh_utils")
    
    if [[ -z "$1" ]]; then
        # If no argument provided, show helpmenu
        helpmenu
        return 0
    fi
    
    for file in "${files[@]}"; do
        if [ -f "$file" ]; then
            grep -E "^\s*${1}\s*\(\)|^\s*function\s+${1}" "$file"
        fi
    done
}

helpmenu(){
    echo "Help Menu:"
    echo "----------"
    echo "See all functions: show_function"
    echo "See all aliases: show_alias"
    echo "See help for a function: show_help function_name"
    echo "See help for an alias: show_help alias_name"
} 